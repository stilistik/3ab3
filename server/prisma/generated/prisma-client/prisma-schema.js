module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateChat {
  count: Int!
}

type AggregateClient {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateDocument {
  count: Int!
}

type AggregateEvent {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregateMessage {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregatePurchase {
  count: Int!
}

type AggregateTodo {
  count: Int!
}

type AggregateTransaction {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Chat {
  id: ID!
  title: String!
  creator: User!
  members(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message!]
  lastSeen: Json
  usersTyping: Json
}

type ChatConnection {
  pageInfo: PageInfo!
  edges: [ChatEdge]!
  aggregate: AggregateChat!
}

input ChatCreateInput {
  id: ID
  title: String!
  creator: UserCreateOneWithoutOwnChatsInput!
  members: UserCreateManyWithoutChatsInput
  messages: MessageCreateManyWithoutChatInput
  lastSeen: Json
  usersTyping: Json
}

input ChatCreateManyWithoutCreatorInput {
  create: [ChatCreateWithoutCreatorInput!]
  connect: [ChatWhereUniqueInput!]
}

input ChatCreateManyWithoutMembersInput {
  create: [ChatCreateWithoutMembersInput!]
  connect: [ChatWhereUniqueInput!]
}

input ChatCreateOneWithoutMessagesInput {
  create: ChatCreateWithoutMessagesInput
  connect: ChatWhereUniqueInput
}

input ChatCreateWithoutCreatorInput {
  id: ID
  title: String!
  members: UserCreateManyWithoutChatsInput
  messages: MessageCreateManyWithoutChatInput
  lastSeen: Json
  usersTyping: Json
}

input ChatCreateWithoutMembersInput {
  id: ID
  title: String!
  creator: UserCreateOneWithoutOwnChatsInput!
  messages: MessageCreateManyWithoutChatInput
  lastSeen: Json
  usersTyping: Json
}

input ChatCreateWithoutMessagesInput {
  id: ID
  title: String!
  creator: UserCreateOneWithoutOwnChatsInput!
  members: UserCreateManyWithoutChatsInput
  lastSeen: Json
  usersTyping: Json
}

type ChatEdge {
  node: Chat!
  cursor: String!
}

enum ChatOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  lastSeen_ASC
  lastSeen_DESC
  usersTyping_ASC
  usersTyping_DESC
}

type ChatPreviousValues {
  id: ID!
  title: String!
  lastSeen: Json
  usersTyping: Json
}

input ChatScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  AND: [ChatScalarWhereInput!]
  OR: [ChatScalarWhereInput!]
  NOT: [ChatScalarWhereInput!]
}

type ChatSubscriptionPayload {
  mutation: MutationType!
  node: Chat
  updatedFields: [String!]
  previousValues: ChatPreviousValues
}

input ChatSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ChatWhereInput
  AND: [ChatSubscriptionWhereInput!]
  OR: [ChatSubscriptionWhereInput!]
  NOT: [ChatSubscriptionWhereInput!]
}

input ChatUpdateInput {
  title: String
  creator: UserUpdateOneRequiredWithoutOwnChatsInput
  members: UserUpdateManyWithoutChatsInput
  messages: MessageUpdateManyWithoutChatInput
  lastSeen: Json
  usersTyping: Json
}

input ChatUpdateManyDataInput {
  title: String
  lastSeen: Json
  usersTyping: Json
}

input ChatUpdateManyMutationInput {
  title: String
  lastSeen: Json
  usersTyping: Json
}

input ChatUpdateManyWithoutCreatorInput {
  create: [ChatCreateWithoutCreatorInput!]
  delete: [ChatWhereUniqueInput!]
  connect: [ChatWhereUniqueInput!]
  set: [ChatWhereUniqueInput!]
  disconnect: [ChatWhereUniqueInput!]
  update: [ChatUpdateWithWhereUniqueWithoutCreatorInput!]
  upsert: [ChatUpsertWithWhereUniqueWithoutCreatorInput!]
  deleteMany: [ChatScalarWhereInput!]
  updateMany: [ChatUpdateManyWithWhereNestedInput!]
}

input ChatUpdateManyWithoutMembersInput {
  create: [ChatCreateWithoutMembersInput!]
  delete: [ChatWhereUniqueInput!]
  connect: [ChatWhereUniqueInput!]
  set: [ChatWhereUniqueInput!]
  disconnect: [ChatWhereUniqueInput!]
  update: [ChatUpdateWithWhereUniqueWithoutMembersInput!]
  upsert: [ChatUpsertWithWhereUniqueWithoutMembersInput!]
  deleteMany: [ChatScalarWhereInput!]
  updateMany: [ChatUpdateManyWithWhereNestedInput!]
}

input ChatUpdateManyWithWhereNestedInput {
  where: ChatScalarWhereInput!
  data: ChatUpdateManyDataInput!
}

input ChatUpdateOneRequiredWithoutMessagesInput {
  create: ChatCreateWithoutMessagesInput
  update: ChatUpdateWithoutMessagesDataInput
  upsert: ChatUpsertWithoutMessagesInput
  connect: ChatWhereUniqueInput
}

input ChatUpdateWithoutCreatorDataInput {
  title: String
  members: UserUpdateManyWithoutChatsInput
  messages: MessageUpdateManyWithoutChatInput
  lastSeen: Json
  usersTyping: Json
}

input ChatUpdateWithoutMembersDataInput {
  title: String
  creator: UserUpdateOneRequiredWithoutOwnChatsInput
  messages: MessageUpdateManyWithoutChatInput
  lastSeen: Json
  usersTyping: Json
}

input ChatUpdateWithoutMessagesDataInput {
  title: String
  creator: UserUpdateOneRequiredWithoutOwnChatsInput
  members: UserUpdateManyWithoutChatsInput
  lastSeen: Json
  usersTyping: Json
}

input ChatUpdateWithWhereUniqueWithoutCreatorInput {
  where: ChatWhereUniqueInput!
  data: ChatUpdateWithoutCreatorDataInput!
}

input ChatUpdateWithWhereUniqueWithoutMembersInput {
  where: ChatWhereUniqueInput!
  data: ChatUpdateWithoutMembersDataInput!
}

input ChatUpsertWithoutMessagesInput {
  update: ChatUpdateWithoutMessagesDataInput!
  create: ChatCreateWithoutMessagesInput!
}

input ChatUpsertWithWhereUniqueWithoutCreatorInput {
  where: ChatWhereUniqueInput!
  update: ChatUpdateWithoutCreatorDataInput!
  create: ChatCreateWithoutCreatorInput!
}

input ChatUpsertWithWhereUniqueWithoutMembersInput {
  where: ChatWhereUniqueInput!
  update: ChatUpdateWithoutMembersDataInput!
  create: ChatCreateWithoutMembersInput!
}

input ChatWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  creator: UserWhereInput
  members_every: UserWhereInput
  members_some: UserWhereInput
  members_none: UserWhereInput
  messages_every: MessageWhereInput
  messages_some: MessageWhereInput
  messages_none: MessageWhereInput
  AND: [ChatWhereInput!]
  OR: [ChatWhereInput!]
  NOT: [ChatWhereInput!]
}

input ChatWhereUniqueInput {
  id: ID
}

type Client {
  id: ID!
  identity: String!
  secret: String!
  name: String!
  trusted: Boolean!
}

type ClientConnection {
  pageInfo: PageInfo!
  edges: [ClientEdge]!
  aggregate: AggregateClient!
}

input ClientCreateInput {
  id: ID
  identity: String!
  secret: String!
  name: String!
  trusted: Boolean
}

type ClientEdge {
  node: Client!
  cursor: String!
}

enum ClientOrderByInput {
  id_ASC
  id_DESC
  identity_ASC
  identity_DESC
  secret_ASC
  secret_DESC
  name_ASC
  name_DESC
  trusted_ASC
  trusted_DESC
}

type ClientPreviousValues {
  id: ID!
  identity: String!
  secret: String!
  name: String!
  trusted: Boolean!
}

type ClientSubscriptionPayload {
  mutation: MutationType!
  node: Client
  updatedFields: [String!]
  previousValues: ClientPreviousValues
}

input ClientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientWhereInput
  AND: [ClientSubscriptionWhereInput!]
  OR: [ClientSubscriptionWhereInput!]
  NOT: [ClientSubscriptionWhereInput!]
}

input ClientUpdateInput {
  identity: String
  secret: String
  name: String
  trusted: Boolean
}

input ClientUpdateManyMutationInput {
  identity: String
  secret: String
  name: String
  trusted: Boolean
}

input ClientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  identity: String
  identity_not: String
  identity_in: [String!]
  identity_not_in: [String!]
  identity_lt: String
  identity_lte: String
  identity_gt: String
  identity_gte: String
  identity_contains: String
  identity_not_contains: String
  identity_starts_with: String
  identity_not_starts_with: String
  identity_ends_with: String
  identity_not_ends_with: String
  secret: String
  secret_not: String
  secret_in: [String!]
  secret_not_in: [String!]
  secret_lt: String
  secret_lte: String
  secret_gt: String
  secret_gte: String
  secret_contains: String
  secret_not_contains: String
  secret_starts_with: String
  secret_not_starts_with: String
  secret_ends_with: String
  secret_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  trusted: Boolean
  trusted_not: Boolean
  AND: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
}

input ClientWhereUniqueInput {
  id: ID
  identity: String
}

type Comment {
  id: ID!
  text: String!
  link: String
  date: DateTime!
  author: User!
  likedBy(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  post: Post
  event: Event
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  id: ID
  text: String!
  link: String
  date: DateTime!
  author: UserCreateOneWithoutCommentsInput!
  likedBy: UserCreateManyWithoutLikedCommentsInput
  post: PostCreateOneWithoutCommentsInput
  event: EventCreateOneWithoutCommentsInput
}

input CommentCreateManyWithoutAuthorInput {
  create: [CommentCreateWithoutAuthorInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutEventInput {
  create: [CommentCreateWithoutEventInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutLikedByInput {
  create: [CommentCreateWithoutLikedByInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutAuthorInput {
  id: ID
  text: String!
  link: String
  date: DateTime!
  likedBy: UserCreateManyWithoutLikedCommentsInput
  post: PostCreateOneWithoutCommentsInput
  event: EventCreateOneWithoutCommentsInput
}

input CommentCreateWithoutEventInput {
  id: ID
  text: String!
  link: String
  date: DateTime!
  author: UserCreateOneWithoutCommentsInput!
  likedBy: UserCreateManyWithoutLikedCommentsInput
  post: PostCreateOneWithoutCommentsInput
}

input CommentCreateWithoutLikedByInput {
  id: ID
  text: String!
  link: String
  date: DateTime!
  author: UserCreateOneWithoutCommentsInput!
  post: PostCreateOneWithoutCommentsInput
  event: EventCreateOneWithoutCommentsInput
}

input CommentCreateWithoutPostInput {
  id: ID
  text: String!
  link: String
  date: DateTime!
  author: UserCreateOneWithoutCommentsInput!
  likedBy: UserCreateManyWithoutLikedCommentsInput
  event: EventCreateOneWithoutCommentsInput
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  link_ASC
  link_DESC
  date_ASC
  date_DESC
}

type CommentPreviousValues {
  id: ID!
  text: String!
  link: String
  date: DateTime!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  text: String
  link: String
  date: DateTime
  author: UserUpdateOneRequiredWithoutCommentsInput
  likedBy: UserUpdateManyWithoutLikedCommentsInput
  post: PostUpdateOneWithoutCommentsInput
  event: EventUpdateOneWithoutCommentsInput
}

input CommentUpdateManyDataInput {
  text: String
  link: String
  date: DateTime
}

input CommentUpdateManyMutationInput {
  text: String
  link: String
  date: DateTime
}

input CommentUpdateManyWithoutAuthorInput {
  create: [CommentCreateWithoutAuthorInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutEventInput {
  create: [CommentCreateWithoutEventInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutEventInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutEventInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutLikedByInput {
  create: [CommentCreateWithoutLikedByInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutLikedByInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutLikedByInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutAuthorDataInput {
  text: String
  link: String
  date: DateTime
  likedBy: UserUpdateManyWithoutLikedCommentsInput
  post: PostUpdateOneWithoutCommentsInput
  event: EventUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutEventDataInput {
  text: String
  link: String
  date: DateTime
  author: UserUpdateOneRequiredWithoutCommentsInput
  likedBy: UserUpdateManyWithoutLikedCommentsInput
  post: PostUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutLikedByDataInput {
  text: String
  link: String
  date: DateTime
  author: UserUpdateOneRequiredWithoutCommentsInput
  post: PostUpdateOneWithoutCommentsInput
  event: EventUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutPostDataInput {
  text: String
  link: String
  date: DateTime
  author: UserUpdateOneRequiredWithoutCommentsInput
  likedBy: UserUpdateManyWithoutLikedCommentsInput
  event: EventUpdateOneWithoutCommentsInput
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutAuthorDataInput!
}

input CommentUpdateWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutEventDataInput!
}

input CommentUpdateWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutLikedByDataInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPostDataInput!
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutAuthorDataInput!
  create: CommentCreateWithoutAuthorInput!
}

input CommentUpsertWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutEventDataInput!
  create: CommentCreateWithoutEventInput!
}

input CommentUpsertWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutLikedByDataInput!
  create: CommentCreateWithoutLikedByInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPostDataInput!
  create: CommentCreateWithoutPostInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  author: UserWhereInput
  likedBy_every: UserWhereInput
  likedBy_some: UserWhereInput
  likedBy_none: UserWhereInput
  post: PostWhereInput
  event: EventWhereInput
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type Document {
  id: ID!
  file: File!
  owner: User!
  name: String!
  thumbnail: String
  createdAt: DateTime!
}

type DocumentConnection {
  pageInfo: PageInfo!
  edges: [DocumentEdge]!
  aggregate: AggregateDocument!
}

input DocumentCreateInput {
  id: ID
  file: FileCreateOneInput!
  owner: UserCreateOneInput!
  name: String!
  thumbnail: String
}

type DocumentEdge {
  node: Document!
  cursor: String!
}

enum DocumentOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  thumbnail_ASC
  thumbnail_DESC
  createdAt_ASC
  createdAt_DESC
}

type DocumentPreviousValues {
  id: ID!
  name: String!
  thumbnail: String
  createdAt: DateTime!
}

type DocumentSubscriptionPayload {
  mutation: MutationType!
  node: Document
  updatedFields: [String!]
  previousValues: DocumentPreviousValues
}

input DocumentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DocumentWhereInput
  AND: [DocumentSubscriptionWhereInput!]
  OR: [DocumentSubscriptionWhereInput!]
  NOT: [DocumentSubscriptionWhereInput!]
}

input DocumentUpdateInput {
  file: FileUpdateOneRequiredInput
  owner: UserUpdateOneRequiredInput
  name: String
  thumbnail: String
}

input DocumentUpdateManyMutationInput {
  name: String
  thumbnail: String
}

input DocumentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  file: FileWhereInput
  owner: UserWhereInput
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  thumbnail: String
  thumbnail_not: String
  thumbnail_in: [String!]
  thumbnail_not_in: [String!]
  thumbnail_lt: String
  thumbnail_lte: String
  thumbnail_gt: String
  thumbnail_gte: String
  thumbnail_contains: String
  thumbnail_not_contains: String
  thumbnail_starts_with: String
  thumbnail_not_starts_with: String
  thumbnail_ends_with: String
  thumbnail_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [DocumentWhereInput!]
  OR: [DocumentWhereInput!]
  NOT: [DocumentWhereInput!]
}

input DocumentWhereUniqueInput {
  id: ID
}

type Event {
  id: ID!
  title: String!
  description: String!
  date: DateTime!
  place: String
  image: String
  flyer: String
  committee(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  supporters(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  likedBy(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  owner: User!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  todos(where: TodoWhereInput, orderBy: TodoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Todo!]
  published: Boolean!
}

type EventConnection {
  pageInfo: PageInfo!
  edges: [EventEdge]!
  aggregate: AggregateEvent!
}

input EventCreateInput {
  id: ID
  title: String!
  description: String!
  date: DateTime!
  place: String
  image: String
  flyer: String
  committee: UserCreateManyInput
  supporters: UserCreateManyWithoutSupportedEventsInput
  likedBy: UserCreateManyWithoutLikedEventsInput
  owner: UserCreateOneInput!
  comments: CommentCreateManyWithoutEventInput
  todos: TodoCreateManyWithoutEventInput
  published: Boolean
}

input EventCreateManyWithoutLikedByInput {
  create: [EventCreateWithoutLikedByInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateManyWithoutSupportersInput {
  create: [EventCreateWithoutSupportersInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateOneWithoutCommentsInput {
  create: EventCreateWithoutCommentsInput
  connect: EventWhereUniqueInput
}

input EventCreateOneWithoutTodosInput {
  create: EventCreateWithoutTodosInput
  connect: EventWhereUniqueInput
}

input EventCreateWithoutCommentsInput {
  id: ID
  title: String!
  description: String!
  date: DateTime!
  place: String
  image: String
  flyer: String
  committee: UserCreateManyInput
  supporters: UserCreateManyWithoutSupportedEventsInput
  likedBy: UserCreateManyWithoutLikedEventsInput
  owner: UserCreateOneInput!
  todos: TodoCreateManyWithoutEventInput
  published: Boolean
}

input EventCreateWithoutLikedByInput {
  id: ID
  title: String!
  description: String!
  date: DateTime!
  place: String
  image: String
  flyer: String
  committee: UserCreateManyInput
  supporters: UserCreateManyWithoutSupportedEventsInput
  owner: UserCreateOneInput!
  comments: CommentCreateManyWithoutEventInput
  todos: TodoCreateManyWithoutEventInput
  published: Boolean
}

input EventCreateWithoutSupportersInput {
  id: ID
  title: String!
  description: String!
  date: DateTime!
  place: String
  image: String
  flyer: String
  committee: UserCreateManyInput
  likedBy: UserCreateManyWithoutLikedEventsInput
  owner: UserCreateOneInput!
  comments: CommentCreateManyWithoutEventInput
  todos: TodoCreateManyWithoutEventInput
  published: Boolean
}

input EventCreateWithoutTodosInput {
  id: ID
  title: String!
  description: String!
  date: DateTime!
  place: String
  image: String
  flyer: String
  committee: UserCreateManyInput
  supporters: UserCreateManyWithoutSupportedEventsInput
  likedBy: UserCreateManyWithoutLikedEventsInput
  owner: UserCreateOneInput!
  comments: CommentCreateManyWithoutEventInput
  published: Boolean
}

type EventEdge {
  node: Event!
  cursor: String!
}

enum EventOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  date_ASC
  date_DESC
  place_ASC
  place_DESC
  image_ASC
  image_DESC
  flyer_ASC
  flyer_DESC
  published_ASC
  published_DESC
}

type EventPreviousValues {
  id: ID!
  title: String!
  description: String!
  date: DateTime!
  place: String
  image: String
  flyer: String
  published: Boolean!
}

input EventScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  place: String
  place_not: String
  place_in: [String!]
  place_not_in: [String!]
  place_lt: String
  place_lte: String
  place_gt: String
  place_gte: String
  place_contains: String
  place_not_contains: String
  place_starts_with: String
  place_not_starts_with: String
  place_ends_with: String
  place_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  flyer: String
  flyer_not: String
  flyer_in: [String!]
  flyer_not_in: [String!]
  flyer_lt: String
  flyer_lte: String
  flyer_gt: String
  flyer_gte: String
  flyer_contains: String
  flyer_not_contains: String
  flyer_starts_with: String
  flyer_not_starts_with: String
  flyer_ends_with: String
  flyer_not_ends_with: String
  published: Boolean
  published_not: Boolean
  AND: [EventScalarWhereInput!]
  OR: [EventScalarWhereInput!]
  NOT: [EventScalarWhereInput!]
}

type EventSubscriptionPayload {
  mutation: MutationType!
  node: Event
  updatedFields: [String!]
  previousValues: EventPreviousValues
}

input EventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EventWhereInput
  AND: [EventSubscriptionWhereInput!]
  OR: [EventSubscriptionWhereInput!]
  NOT: [EventSubscriptionWhereInput!]
}

input EventUpdateInput {
  title: String
  description: String
  date: DateTime
  place: String
  image: String
  flyer: String
  committee: UserUpdateManyInput
  supporters: UserUpdateManyWithoutSupportedEventsInput
  likedBy: UserUpdateManyWithoutLikedEventsInput
  owner: UserUpdateOneRequiredInput
  comments: CommentUpdateManyWithoutEventInput
  todos: TodoUpdateManyWithoutEventInput
  published: Boolean
}

input EventUpdateManyDataInput {
  title: String
  description: String
  date: DateTime
  place: String
  image: String
  flyer: String
  published: Boolean
}

input EventUpdateManyMutationInput {
  title: String
  description: String
  date: DateTime
  place: String
  image: String
  flyer: String
  published: Boolean
}

input EventUpdateManyWithoutLikedByInput {
  create: [EventCreateWithoutLikedByInput!]
  delete: [EventWhereUniqueInput!]
  connect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutLikedByInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutLikedByInput!]
  deleteMany: [EventScalarWhereInput!]
  updateMany: [EventUpdateManyWithWhereNestedInput!]
}

input EventUpdateManyWithoutSupportersInput {
  create: [EventCreateWithoutSupportersInput!]
  delete: [EventWhereUniqueInput!]
  connect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutSupportersInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutSupportersInput!]
  deleteMany: [EventScalarWhereInput!]
  updateMany: [EventUpdateManyWithWhereNestedInput!]
}

input EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput!
  data: EventUpdateManyDataInput!
}

input EventUpdateOneRequiredWithoutTodosInput {
  create: EventCreateWithoutTodosInput
  update: EventUpdateWithoutTodosDataInput
  upsert: EventUpsertWithoutTodosInput
  connect: EventWhereUniqueInput
}

input EventUpdateOneWithoutCommentsInput {
  create: EventCreateWithoutCommentsInput
  update: EventUpdateWithoutCommentsDataInput
  upsert: EventUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: EventWhereUniqueInput
}

input EventUpdateWithoutCommentsDataInput {
  title: String
  description: String
  date: DateTime
  place: String
  image: String
  flyer: String
  committee: UserUpdateManyInput
  supporters: UserUpdateManyWithoutSupportedEventsInput
  likedBy: UserUpdateManyWithoutLikedEventsInput
  owner: UserUpdateOneRequiredInput
  todos: TodoUpdateManyWithoutEventInput
  published: Boolean
}

input EventUpdateWithoutLikedByDataInput {
  title: String
  description: String
  date: DateTime
  place: String
  image: String
  flyer: String
  committee: UserUpdateManyInput
  supporters: UserUpdateManyWithoutSupportedEventsInput
  owner: UserUpdateOneRequiredInput
  comments: CommentUpdateManyWithoutEventInput
  todos: TodoUpdateManyWithoutEventInput
  published: Boolean
}

input EventUpdateWithoutSupportersDataInput {
  title: String
  description: String
  date: DateTime
  place: String
  image: String
  flyer: String
  committee: UserUpdateManyInput
  likedBy: UserUpdateManyWithoutLikedEventsInput
  owner: UserUpdateOneRequiredInput
  comments: CommentUpdateManyWithoutEventInput
  todos: TodoUpdateManyWithoutEventInput
  published: Boolean
}

input EventUpdateWithoutTodosDataInput {
  title: String
  description: String
  date: DateTime
  place: String
  image: String
  flyer: String
  committee: UserUpdateManyInput
  supporters: UserUpdateManyWithoutSupportedEventsInput
  likedBy: UserUpdateManyWithoutLikedEventsInput
  owner: UserUpdateOneRequiredInput
  comments: CommentUpdateManyWithoutEventInput
  published: Boolean
}

input EventUpdateWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput!
  data: EventUpdateWithoutLikedByDataInput!
}

input EventUpdateWithWhereUniqueWithoutSupportersInput {
  where: EventWhereUniqueInput!
  data: EventUpdateWithoutSupportersDataInput!
}

input EventUpsertWithoutCommentsInput {
  update: EventUpdateWithoutCommentsDataInput!
  create: EventCreateWithoutCommentsInput!
}

input EventUpsertWithoutTodosInput {
  update: EventUpdateWithoutTodosDataInput!
  create: EventCreateWithoutTodosInput!
}

input EventUpsertWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput!
  update: EventUpdateWithoutLikedByDataInput!
  create: EventCreateWithoutLikedByInput!
}

input EventUpsertWithWhereUniqueWithoutSupportersInput {
  where: EventWhereUniqueInput!
  update: EventUpdateWithoutSupportersDataInput!
  create: EventCreateWithoutSupportersInput!
}

input EventWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  place: String
  place_not: String
  place_in: [String!]
  place_not_in: [String!]
  place_lt: String
  place_lte: String
  place_gt: String
  place_gte: String
  place_contains: String
  place_not_contains: String
  place_starts_with: String
  place_not_starts_with: String
  place_ends_with: String
  place_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  flyer: String
  flyer_not: String
  flyer_in: [String!]
  flyer_not_in: [String!]
  flyer_lt: String
  flyer_lte: String
  flyer_gt: String
  flyer_gte: String
  flyer_contains: String
  flyer_not_contains: String
  flyer_starts_with: String
  flyer_not_starts_with: String
  flyer_ends_with: String
  flyer_not_ends_with: String
  committee_every: UserWhereInput
  committee_some: UserWhereInput
  committee_none: UserWhereInput
  supporters_every: UserWhereInput
  supporters_some: UserWhereInput
  supporters_none: UserWhereInput
  likedBy_every: UserWhereInput
  likedBy_some: UserWhereInput
  likedBy_none: UserWhereInput
  owner: UserWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  todos_every: TodoWhereInput
  todos_some: TodoWhereInput
  todos_none: TodoWhereInput
  published: Boolean
  published_not: Boolean
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
}

input EventWhereUniqueInput {
  id: ID
}

type File {
  id: ID!
  fileId: String!
  hash: String!
  uri: String!
  filename: String!
  path: String!
  mimetype: String!
  extension: String!
  createdAt: DateTime!
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  id: ID
  fileId: String!
  hash: String!
  uri: String!
  filename: String!
  path: String!
  mimetype: String!
  extension: String!
}

input FileCreateOneInput {
  create: FileCreateInput
  connect: FileWhereUniqueInput
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  fileId_ASC
  fileId_DESC
  hash_ASC
  hash_DESC
  uri_ASC
  uri_DESC
  filename_ASC
  filename_DESC
  path_ASC
  path_DESC
  mimetype_ASC
  mimetype_DESC
  extension_ASC
  extension_DESC
  createdAt_ASC
  createdAt_DESC
}

type FilePreviousValues {
  id: ID!
  fileId: String!
  hash: String!
  uri: String!
  filename: String!
  path: String!
  mimetype: String!
  extension: String!
  createdAt: DateTime!
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateDataInput {
  fileId: String
  hash: String
  uri: String
  filename: String
  path: String
  mimetype: String
  extension: String
}

input FileUpdateInput {
  fileId: String
  hash: String
  uri: String
  filename: String
  path: String
  mimetype: String
  extension: String
}

input FileUpdateManyMutationInput {
  fileId: String
  hash: String
  uri: String
  filename: String
  path: String
  mimetype: String
  extension: String
}

input FileUpdateOneRequiredInput {
  create: FileCreateInput
  update: FileUpdateDataInput
  upsert: FileUpsertNestedInput
  connect: FileWhereUniqueInput
}

input FileUpsertNestedInput {
  update: FileUpdateDataInput!
  create: FileCreateInput!
}

input FileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fileId: String
  fileId_not: String
  fileId_in: [String!]
  fileId_not_in: [String!]
  fileId_lt: String
  fileId_lte: String
  fileId_gt: String
  fileId_gte: String
  fileId_contains: String
  fileId_not_contains: String
  fileId_starts_with: String
  fileId_not_starts_with: String
  fileId_ends_with: String
  fileId_not_ends_with: String
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_lt: String
  hash_lte: String
  hash_gt: String
  hash_gte: String
  hash_contains: String
  hash_not_contains: String
  hash_starts_with: String
  hash_not_starts_with: String
  hash_ends_with: String
  hash_not_ends_with: String
  uri: String
  uri_not: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_gt: String
  uri_gte: String
  uri_contains: String
  uri_not_contains: String
  uri_starts_with: String
  uri_not_starts_with: String
  uri_ends_with: String
  uri_not_ends_with: String
  filename: String
  filename_not: String
  filename_in: [String!]
  filename_not_in: [String!]
  filename_lt: String
  filename_lte: String
  filename_gt: String
  filename_gte: String
  filename_contains: String
  filename_not_contains: String
  filename_starts_with: String
  filename_not_starts_with: String
  filename_ends_with: String
  filename_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  mimetype: String
  mimetype_not: String
  mimetype_in: [String!]
  mimetype_not_in: [String!]
  mimetype_lt: String
  mimetype_lte: String
  mimetype_gt: String
  mimetype_gte: String
  mimetype_contains: String
  mimetype_not_contains: String
  mimetype_starts_with: String
  mimetype_not_starts_with: String
  mimetype_ends_with: String
  mimetype_not_ends_with: String
  extension: String
  extension_not: String
  extension_in: [String!]
  extension_not_in: [String!]
  extension_lt: String
  extension_lte: String
  extension_gt: String
  extension_gte: String
  extension_contains: String
  extension_not_contains: String
  extension_starts_with: String
  extension_not_starts_with: String
  extension_ends_with: String
  extension_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: ID
  fileId: String
  hash: String
  uri: String
}

type Item {
  id: ID!
  product: Product!
  user: User!
  price: Float!
  amount: Int!
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  id: ID
  product: ProductCreateOneInput!
  user: UserCreateOneWithoutItemsInput!
  price: Float!
  amount: Int!
}

input ItemCreateManyInput {
  create: [ItemCreateInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateManyWithoutUserInput {
  create: [ItemCreateWithoutUserInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateWithoutUserInput {
  id: ID
  product: ProductCreateOneInput!
  price: Float!
  amount: Int!
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  price_ASC
  price_DESC
  amount_ASC
  amount_DESC
}

type ItemPreviousValues {
  id: ID!
  price: Float!
  amount: Int!
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateDataInput {
  product: ProductUpdateOneRequiredInput
  user: UserUpdateOneRequiredWithoutItemsInput
  price: Float
  amount: Int
}

input ItemUpdateInput {
  product: ProductUpdateOneRequiredInput
  user: UserUpdateOneRequiredWithoutItemsInput
  price: Float
  amount: Int
}

input ItemUpdateManyDataInput {
  price: Float
  amount: Int
}

input ItemUpdateManyInput {
  create: [ItemCreateInput!]
  update: [ItemUpdateWithWhereUniqueNestedInput!]
  upsert: [ItemUpsertWithWhereUniqueNestedInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyMutationInput {
  price: Float
  amount: Int
}

input ItemUpdateManyWithoutUserInput {
  create: [ItemCreateWithoutUserInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateWithoutUserDataInput {
  product: ProductUpdateOneRequiredInput
  price: Float
  amount: Int
}

input ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateDataInput!
}

input ItemUpdateWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutUserDataInput!
}

input ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateDataInput!
  create: ItemCreateInput!
}

input ItemUpsertWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutUserDataInput!
  create: ItemCreateWithoutUserInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  product: ProductWhereInput
  user: UserWhereInput
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Json

scalar Long

type Message {
  id: ID!
  text: String!
  link: String
  from: User!
  chat: Chat!
  date: DateTime!
}

type MessageConnection {
  pageInfo: PageInfo!
  edges: [MessageEdge]!
  aggregate: AggregateMessage!
}

input MessageCreateInput {
  id: ID
  text: String!
  link: String
  from: UserCreateOneInput!
  chat: ChatCreateOneWithoutMessagesInput!
  date: DateTime!
}

input MessageCreateManyWithoutChatInput {
  create: [MessageCreateWithoutChatInput!]
  connect: [MessageWhereUniqueInput!]
}

input MessageCreateWithoutChatInput {
  id: ID
  text: String!
  link: String
  from: UserCreateOneInput!
  date: DateTime!
}

type MessageEdge {
  node: Message!
  cursor: String!
}

enum MessageOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  link_ASC
  link_DESC
  date_ASC
  date_DESC
}

type MessagePreviousValues {
  id: ID!
  text: String!
  link: String
  date: DateTime!
}

input MessageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
}

type MessageSubscriptionPayload {
  mutation: MutationType!
  node: Message
  updatedFields: [String!]
  previousValues: MessagePreviousValues
}

input MessageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: MessageWhereInput
  AND: [MessageSubscriptionWhereInput!]
  OR: [MessageSubscriptionWhereInput!]
  NOT: [MessageSubscriptionWhereInput!]
}

input MessageUpdateInput {
  text: String
  link: String
  from: UserUpdateOneRequiredInput
  chat: ChatUpdateOneRequiredWithoutMessagesInput
  date: DateTime
}

input MessageUpdateManyDataInput {
  text: String
  link: String
  date: DateTime
}

input MessageUpdateManyMutationInput {
  text: String
  link: String
  date: DateTime
}

input MessageUpdateManyWithoutChatInput {
  create: [MessageCreateWithoutChatInput!]
  delete: [MessageWhereUniqueInput!]
  connect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  disconnect: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutChatInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutChatInput!]
  deleteMany: [MessageScalarWhereInput!]
  updateMany: [MessageUpdateManyWithWhereNestedInput!]
}

input MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput!
  data: MessageUpdateManyDataInput!
}

input MessageUpdateWithoutChatDataInput {
  text: String
  link: String
  from: UserUpdateOneRequiredInput
  date: DateTime
}

input MessageUpdateWithWhereUniqueWithoutChatInput {
  where: MessageWhereUniqueInput!
  data: MessageUpdateWithoutChatDataInput!
}

input MessageUpsertWithWhereUniqueWithoutChatInput {
  where: MessageWhereUniqueInput!
  update: MessageUpdateWithoutChatDataInput!
  create: MessageCreateWithoutChatInput!
}

input MessageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  from: UserWhereInput
  chat: ChatWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  NOT: [MessageWhereInput!]
}

input MessageWhereUniqueInput {
  id: ID
}

type Mutation {
  createChat(data: ChatCreateInput!): Chat!
  updateChat(data: ChatUpdateInput!, where: ChatWhereUniqueInput!): Chat
  updateManyChats(data: ChatUpdateManyMutationInput!, where: ChatWhereInput): BatchPayload!
  upsertChat(where: ChatWhereUniqueInput!, create: ChatCreateInput!, update: ChatUpdateInput!): Chat!
  deleteChat(where: ChatWhereUniqueInput!): Chat
  deleteManyChats(where: ChatWhereInput): BatchPayload!
  createClient(data: ClientCreateInput!): Client!
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateManyClients(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  upsertClient(where: ClientWhereUniqueInput!, create: ClientCreateInput!, update: ClientUpdateInput!): Client!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteManyClients(where: ClientWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createDocument(data: DocumentCreateInput!): Document!
  updateDocument(data: DocumentUpdateInput!, where: DocumentWhereUniqueInput!): Document
  updateManyDocuments(data: DocumentUpdateManyMutationInput!, where: DocumentWhereInput): BatchPayload!
  upsertDocument(where: DocumentWhereUniqueInput!, create: DocumentCreateInput!, update: DocumentUpdateInput!): Document!
  deleteDocument(where: DocumentWhereUniqueInput!): Document
  deleteManyDocuments(where: DocumentWhereInput): BatchPayload!
  createEvent(data: EventCreateInput!): Event!
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateManyEvents(data: EventUpdateManyMutationInput!, where: EventWhereInput): BatchPayload!
  upsertEvent(where: EventWhereUniqueInput!, create: EventCreateInput!, update: EventUpdateInput!): Event!
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteManyEvents(where: EventWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createMessage(data: MessageCreateInput!): Message!
  updateMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  updateManyMessages(data: MessageUpdateManyMutationInput!, where: MessageWhereInput): BatchPayload!
  upsertMessage(where: MessageWhereUniqueInput!, create: MessageCreateInput!, update: MessageUpdateInput!): Message!
  deleteMessage(where: MessageWhereUniqueInput!): Message
  deleteManyMessages(where: MessageWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createPurchase(data: PurchaseCreateInput!): Purchase!
  updatePurchase(data: PurchaseUpdateInput!, where: PurchaseWhereUniqueInput!): Purchase
  updateManyPurchases(data: PurchaseUpdateManyMutationInput!, where: PurchaseWhereInput): BatchPayload!
  upsertPurchase(where: PurchaseWhereUniqueInput!, create: PurchaseCreateInput!, update: PurchaseUpdateInput!): Purchase!
  deletePurchase(where: PurchaseWhereUniqueInput!): Purchase
  deleteManyPurchases(where: PurchaseWhereInput): BatchPayload!
  createTodo(data: TodoCreateInput!): Todo!
  updateTodo(data: TodoUpdateInput!, where: TodoWhereUniqueInput!): Todo
  updateManyTodoes(data: TodoUpdateManyMutationInput!, where: TodoWhereInput): BatchPayload!
  upsertTodo(where: TodoWhereUniqueInput!, create: TodoCreateInput!, update: TodoUpdateInput!): Todo!
  deleteTodo(where: TodoWhereUniqueInput!): Todo
  deleteManyTodoes(where: TodoWhereInput): BatchPayload!
  createTransaction(data: TransactionCreateInput!): Transaction!
  updateTransaction(data: TransactionUpdateInput!, where: TransactionWhereUniqueInput!): Transaction
  updateManyTransactions(data: TransactionUpdateManyMutationInput!, where: TransactionWhereInput): BatchPayload!
  upsertTransaction(where: TransactionWhereUniqueInput!, create: TransactionCreateInput!, update: TransactionUpdateInput!): Transaction!
  deleteTransaction(where: TransactionWhereUniqueInput!): Transaction
  deleteManyTransactions(where: TransactionWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  amount: Float!
  user: User!
  date: DateTime!
  verified: Boolean!
  transaction: Transaction!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  id: ID
  amount: Float!
  user: UserCreateOneWithoutPaymentsInput!
  date: DateTime!
  verified: Boolean
  transaction: TransactionCreateOneWithoutPaymentInput!
}

input PaymentCreateManyWithoutUserInput {
  create: [PaymentCreateWithoutUserInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutTransactionInput {
  create: PaymentCreateWithoutTransactionInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutTransactionInput {
  id: ID
  amount: Float!
  user: UserCreateOneWithoutPaymentsInput!
  date: DateTime!
  verified: Boolean
}

input PaymentCreateWithoutUserInput {
  id: ID
  amount: Float!
  date: DateTime!
  verified: Boolean
  transaction: TransactionCreateOneWithoutPaymentInput!
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  date_ASC
  date_DESC
  verified_ASC
  verified_DESC
}

type PaymentPreviousValues {
  id: ID!
  amount: Float!
  date: DateTime!
  verified: Boolean!
}

input PaymentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  verified: Boolean
  verified_not: Boolean
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  amount: Float
  user: UserUpdateOneRequiredWithoutPaymentsInput
  date: DateTime
  verified: Boolean
  transaction: TransactionUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateManyDataInput {
  amount: Float
  date: DateTime
  verified: Boolean
}

input PaymentUpdateManyMutationInput {
  amount: Float
  date: DateTime
  verified: Boolean
}

input PaymentUpdateManyWithoutUserInput {
  create: [PaymentCreateWithoutUserInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateOneWithoutTransactionInput {
  create: PaymentCreateWithoutTransactionInput
  update: PaymentUpdateWithoutTransactionDataInput
  upsert: PaymentUpsertWithoutTransactionInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutTransactionDataInput {
  amount: Float
  user: UserUpdateOneRequiredWithoutPaymentsInput
  date: DateTime
  verified: Boolean
}

input PaymentUpdateWithoutUserDataInput {
  amount: Float
  date: DateTime
  verified: Boolean
  transaction: TransactionUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutUserDataInput!
}

input PaymentUpsertWithoutTransactionInput {
  update: PaymentUpdateWithoutTransactionDataInput!
  create: PaymentCreateWithoutTransactionInput!
}

input PaymentUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutUserDataInput!
  create: PaymentCreateWithoutUserInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  user: UserWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  verified: Boolean
  verified_not: Boolean
  transaction: TransactionWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Post {
  id: ID!
  text: String!
  image: String
  link: String
  author: User!
  likedBy(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  date: DateTime!
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  id: ID
  text: String!
  image: String
  link: String
  author: UserCreateOneWithoutPostsInput!
  likedBy: UserCreateManyWithoutLikedPostsInput
  comments: CommentCreateManyWithoutPostInput
  date: DateTime!
}

input PostCreateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateManyWithoutLikedByInput {
  create: [PostCreateWithoutLikedByInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutAuthorInput {
  id: ID
  text: String!
  image: String
  link: String
  likedBy: UserCreateManyWithoutLikedPostsInput
  comments: CommentCreateManyWithoutPostInput
  date: DateTime!
}

input PostCreateWithoutCommentsInput {
  id: ID
  text: String!
  image: String
  link: String
  author: UserCreateOneWithoutPostsInput!
  likedBy: UserCreateManyWithoutLikedPostsInput
  date: DateTime!
}

input PostCreateWithoutLikedByInput {
  id: ID
  text: String!
  image: String
  link: String
  author: UserCreateOneWithoutPostsInput!
  comments: CommentCreateManyWithoutPostInput
  date: DateTime!
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  image_ASC
  image_DESC
  link_ASC
  link_DESC
  date_ASC
  date_DESC
}

type PostPreviousValues {
  id: ID!
  text: String!
  image: String
  link: String
  date: DateTime!
}

input PostScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateInput {
  text: String
  image: String
  link: String
  author: UserUpdateOneRequiredWithoutPostsInput
  likedBy: UserUpdateManyWithoutLikedPostsInput
  comments: CommentUpdateManyWithoutPostInput
  date: DateTime
}

input PostUpdateManyDataInput {
  text: String
  image: String
  link: String
  date: DateTime
}

input PostUpdateManyMutationInput {
  text: String
  image: String
  link: String
  date: DateTime
}

input PostUpdateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithoutLikedByInput {
  create: [PostCreateWithoutLikedByInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutLikedByInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutLikedByInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyDataInput!
}

input PostUpdateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: PostWhereUniqueInput
}

input PostUpdateWithoutAuthorDataInput {
  text: String
  image: String
  link: String
  likedBy: UserUpdateManyWithoutLikedPostsInput
  comments: CommentUpdateManyWithoutPostInput
  date: DateTime
}

input PostUpdateWithoutCommentsDataInput {
  text: String
  image: String
  link: String
  author: UserUpdateOneRequiredWithoutPostsInput
  likedBy: UserUpdateManyWithoutLikedPostsInput
  date: DateTime
}

input PostUpdateWithoutLikedByDataInput {
  text: String
  image: String
  link: String
  author: UserUpdateOneRequiredWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  date: DateTime
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutAuthorDataInput!
}

input PostUpdateWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutLikedByDataInput!
}

input PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput!
  create: PostCreateWithoutCommentsInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutAuthorDataInput!
  create: PostCreateWithoutAuthorInput!
}

input PostUpsertWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutLikedByDataInput!
  create: PostCreateWithoutLikedByInput!
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  author: UserWhereInput
  likedBy_every: UserWhereInput
  likedBy_some: UserWhereInput
  likedBy_none: UserWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Product {
  id: ID!
  name: String!
  price: Float!
  index: Int!
  thumbnail: String
  deleted: Boolean!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  name: String!
  price: Float!
  index: Int!
  thumbnail: String
  deleted: Boolean
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  index_ASC
  index_DESC
  thumbnail_ASC
  thumbnail_DESC
  deleted_ASC
  deleted_DESC
}

type ProductPreviousValues {
  id: ID!
  name: String!
  price: Float!
  index: Int!
  thumbnail: String
  deleted: Boolean!
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  name: String
  price: Float
  index: Int
  thumbnail: String
  deleted: Boolean
}

input ProductUpdateInput {
  name: String
  price: Float
  index: Int
  thumbnail: String
  deleted: Boolean
}

input ProductUpdateManyMutationInput {
  name: String
  price: Float
  index: Int
  thumbnail: String
  deleted: Boolean
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  thumbnail: String
  thumbnail_not: String
  thumbnail_in: [String!]
  thumbnail_not_in: [String!]
  thumbnail_lt: String
  thumbnail_lte: String
  thumbnail_gt: String
  thumbnail_gte: String
  thumbnail_contains: String
  thumbnail_not_contains: String
  thumbnail_starts_with: String
  thumbnail_not_starts_with: String
  thumbnail_ends_with: String
  thumbnail_not_ends_with: String
  deleted: Boolean
  deleted_not: Boolean
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Purchase {
  id: ID!
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  transaction: Transaction!
  total: Float!
  user: User!
  date: DateTime!
}

type PurchaseConnection {
  pageInfo: PageInfo!
  edges: [PurchaseEdge]!
  aggregate: AggregatePurchase!
}

input PurchaseCreateInput {
  id: ID
  items: ItemCreateManyInput
  transaction: TransactionCreateOneWithoutPurchaseInput!
  total: Float!
  user: UserCreateOneWithoutPurchasesInput!
  date: DateTime!
}

input PurchaseCreateManyWithoutUserInput {
  create: [PurchaseCreateWithoutUserInput!]
  connect: [PurchaseWhereUniqueInput!]
}

input PurchaseCreateOneWithoutTransactionInput {
  create: PurchaseCreateWithoutTransactionInput
  connect: PurchaseWhereUniqueInput
}

input PurchaseCreateWithoutTransactionInput {
  id: ID
  items: ItemCreateManyInput
  total: Float!
  user: UserCreateOneWithoutPurchasesInput!
  date: DateTime!
}

input PurchaseCreateWithoutUserInput {
  id: ID
  items: ItemCreateManyInput
  transaction: TransactionCreateOneWithoutPurchaseInput!
  total: Float!
  date: DateTime!
}

type PurchaseEdge {
  node: Purchase!
  cursor: String!
}

enum PurchaseOrderByInput {
  id_ASC
  id_DESC
  total_ASC
  total_DESC
  date_ASC
  date_DESC
}

type PurchasePreviousValues {
  id: ID!
  total: Float!
  date: DateTime!
}

input PurchaseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  total: Float
  total_not: Float
  total_in: [Float!]
  total_not_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_gt: Float
  total_gte: Float
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [PurchaseScalarWhereInput!]
  OR: [PurchaseScalarWhereInput!]
  NOT: [PurchaseScalarWhereInput!]
}

type PurchaseSubscriptionPayload {
  mutation: MutationType!
  node: Purchase
  updatedFields: [String!]
  previousValues: PurchasePreviousValues
}

input PurchaseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PurchaseWhereInput
  AND: [PurchaseSubscriptionWhereInput!]
  OR: [PurchaseSubscriptionWhereInput!]
  NOT: [PurchaseSubscriptionWhereInput!]
}

input PurchaseUpdateInput {
  items: ItemUpdateManyInput
  transaction: TransactionUpdateOneRequiredWithoutPurchaseInput
  total: Float
  user: UserUpdateOneRequiredWithoutPurchasesInput
  date: DateTime
}

input PurchaseUpdateManyDataInput {
  total: Float
  date: DateTime
}

input PurchaseUpdateManyMutationInput {
  total: Float
  date: DateTime
}

input PurchaseUpdateManyWithoutUserInput {
  create: [PurchaseCreateWithoutUserInput!]
  delete: [PurchaseWhereUniqueInput!]
  connect: [PurchaseWhereUniqueInput!]
  set: [PurchaseWhereUniqueInput!]
  disconnect: [PurchaseWhereUniqueInput!]
  update: [PurchaseUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [PurchaseUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [PurchaseScalarWhereInput!]
  updateMany: [PurchaseUpdateManyWithWhereNestedInput!]
}

input PurchaseUpdateManyWithWhereNestedInput {
  where: PurchaseScalarWhereInput!
  data: PurchaseUpdateManyDataInput!
}

input PurchaseUpdateOneWithoutTransactionInput {
  create: PurchaseCreateWithoutTransactionInput
  update: PurchaseUpdateWithoutTransactionDataInput
  upsert: PurchaseUpsertWithoutTransactionInput
  delete: Boolean
  disconnect: Boolean
  connect: PurchaseWhereUniqueInput
}

input PurchaseUpdateWithoutTransactionDataInput {
  items: ItemUpdateManyInput
  total: Float
  user: UserUpdateOneRequiredWithoutPurchasesInput
  date: DateTime
}

input PurchaseUpdateWithoutUserDataInput {
  items: ItemUpdateManyInput
  transaction: TransactionUpdateOneRequiredWithoutPurchaseInput
  total: Float
  date: DateTime
}

input PurchaseUpdateWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput!
  data: PurchaseUpdateWithoutUserDataInput!
}

input PurchaseUpsertWithoutTransactionInput {
  update: PurchaseUpdateWithoutTransactionDataInput!
  create: PurchaseCreateWithoutTransactionInput!
}

input PurchaseUpsertWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput!
  update: PurchaseUpdateWithoutUserDataInput!
  create: PurchaseCreateWithoutUserInput!
}

input PurchaseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  transaction: TransactionWhereInput
  total: Float
  total_not: Float
  total_in: [Float!]
  total_not_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_gt: Float
  total_gte: Float
  user: UserWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [PurchaseWhereInput!]
  OR: [PurchaseWhereInput!]
  NOT: [PurchaseWhereInput!]
}

input PurchaseWhereUniqueInput {
  id: ID
}

type Query {
  chat(where: ChatWhereUniqueInput!): Chat
  chats(where: ChatWhereInput, orderBy: ChatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Chat]!
  chatsConnection(where: ChatWhereInput, orderBy: ChatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ChatConnection!
  client(where: ClientWhereUniqueInput!): Client
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client]!
  clientsConnection(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  document(where: DocumentWhereUniqueInput!): Document
  documents(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Document]!
  documentsConnection(where: DocumentWhereInput, orderBy: DocumentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DocumentConnection!
  event(where: EventWhereUniqueInput!): Event
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event]!
  eventsConnection(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EventConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  message(where: MessageWhereUniqueInput!): Message
  messages(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Message]!
  messagesConnection(where: MessageWhereInput, orderBy: MessageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): MessageConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  purchase(where: PurchaseWhereUniqueInput!): Purchase
  purchases(where: PurchaseWhereInput, orderBy: PurchaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Purchase]!
  purchasesConnection(where: PurchaseWhereInput, orderBy: PurchaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PurchaseConnection!
  todo(where: TodoWhereUniqueInput!): Todo
  todoes(where: TodoWhereInput, orderBy: TodoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Todo]!
  todoesConnection(where: TodoWhereInput, orderBy: TodoOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TodoConnection!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction]!
  transactionsConnection(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransactionConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  chat(where: ChatSubscriptionWhereInput): ChatSubscriptionPayload
  client(where: ClientSubscriptionWhereInput): ClientSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  document(where: DocumentSubscriptionWhereInput): DocumentSubscriptionPayload
  event(where: EventSubscriptionWhereInput): EventSubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  message(where: MessageSubscriptionWhereInput): MessageSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  purchase(where: PurchaseSubscriptionWhereInput): PurchaseSubscriptionPayload
  todo(where: TodoSubscriptionWhereInput): TodoSubscriptionPayload
  transaction(where: TransactionSubscriptionWhereInput): TransactionSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Todo {
  id: ID!
  due: DateTime!
  text: String!
  done: Boolean
  assigned: User
  link: String
  doneBy: User
  doneAt: DateTime
  event: Event!
}

type TodoConnection {
  pageInfo: PageInfo!
  edges: [TodoEdge]!
  aggregate: AggregateTodo!
}

input TodoCreateInput {
  id: ID
  due: DateTime!
  text: String!
  done: Boolean
  assigned: UserCreateOneInput
  link: String
  doneBy: UserCreateOneInput
  doneAt: DateTime
  event: EventCreateOneWithoutTodosInput!
}

input TodoCreateManyWithoutEventInput {
  create: [TodoCreateWithoutEventInput!]
  connect: [TodoWhereUniqueInput!]
}

input TodoCreateWithoutEventInput {
  id: ID
  due: DateTime!
  text: String!
  done: Boolean
  assigned: UserCreateOneInput
  link: String
  doneBy: UserCreateOneInput
  doneAt: DateTime
}

type TodoEdge {
  node: Todo!
  cursor: String!
}

enum TodoOrderByInput {
  id_ASC
  id_DESC
  due_ASC
  due_DESC
  text_ASC
  text_DESC
  done_ASC
  done_DESC
  link_ASC
  link_DESC
  doneAt_ASC
  doneAt_DESC
}

type TodoPreviousValues {
  id: ID!
  due: DateTime!
  text: String!
  done: Boolean
  link: String
  doneAt: DateTime
}

input TodoScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  due: DateTime
  due_not: DateTime
  due_in: [DateTime!]
  due_not_in: [DateTime!]
  due_lt: DateTime
  due_lte: DateTime
  due_gt: DateTime
  due_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  done: Boolean
  done_not: Boolean
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  doneAt: DateTime
  doneAt_not: DateTime
  doneAt_in: [DateTime!]
  doneAt_not_in: [DateTime!]
  doneAt_lt: DateTime
  doneAt_lte: DateTime
  doneAt_gt: DateTime
  doneAt_gte: DateTime
  AND: [TodoScalarWhereInput!]
  OR: [TodoScalarWhereInput!]
  NOT: [TodoScalarWhereInput!]
}

type TodoSubscriptionPayload {
  mutation: MutationType!
  node: Todo
  updatedFields: [String!]
  previousValues: TodoPreviousValues
}

input TodoSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TodoWhereInput
  AND: [TodoSubscriptionWhereInput!]
  OR: [TodoSubscriptionWhereInput!]
  NOT: [TodoSubscriptionWhereInput!]
}

input TodoUpdateInput {
  due: DateTime
  text: String
  done: Boolean
  assigned: UserUpdateOneInput
  link: String
  doneBy: UserUpdateOneInput
  doneAt: DateTime
  event: EventUpdateOneRequiredWithoutTodosInput
}

input TodoUpdateManyDataInput {
  due: DateTime
  text: String
  done: Boolean
  link: String
  doneAt: DateTime
}

input TodoUpdateManyMutationInput {
  due: DateTime
  text: String
  done: Boolean
  link: String
  doneAt: DateTime
}

input TodoUpdateManyWithoutEventInput {
  create: [TodoCreateWithoutEventInput!]
  delete: [TodoWhereUniqueInput!]
  connect: [TodoWhereUniqueInput!]
  set: [TodoWhereUniqueInput!]
  disconnect: [TodoWhereUniqueInput!]
  update: [TodoUpdateWithWhereUniqueWithoutEventInput!]
  upsert: [TodoUpsertWithWhereUniqueWithoutEventInput!]
  deleteMany: [TodoScalarWhereInput!]
  updateMany: [TodoUpdateManyWithWhereNestedInput!]
}

input TodoUpdateManyWithWhereNestedInput {
  where: TodoScalarWhereInput!
  data: TodoUpdateManyDataInput!
}

input TodoUpdateWithoutEventDataInput {
  due: DateTime
  text: String
  done: Boolean
  assigned: UserUpdateOneInput
  link: String
  doneBy: UserUpdateOneInput
  doneAt: DateTime
}

input TodoUpdateWithWhereUniqueWithoutEventInput {
  where: TodoWhereUniqueInput!
  data: TodoUpdateWithoutEventDataInput!
}

input TodoUpsertWithWhereUniqueWithoutEventInput {
  where: TodoWhereUniqueInput!
  update: TodoUpdateWithoutEventDataInput!
  create: TodoCreateWithoutEventInput!
}

input TodoWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  due: DateTime
  due_not: DateTime
  due_in: [DateTime!]
  due_not_in: [DateTime!]
  due_lt: DateTime
  due_lte: DateTime
  due_gt: DateTime
  due_gte: DateTime
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  done: Boolean
  done_not: Boolean
  assigned: UserWhereInput
  link: String
  link_not: String
  link_in: [String!]
  link_not_in: [String!]
  link_lt: String
  link_lte: String
  link_gt: String
  link_gte: String
  link_contains: String
  link_not_contains: String
  link_starts_with: String
  link_not_starts_with: String
  link_ends_with: String
  link_not_ends_with: String
  doneBy: UserWhereInput
  doneAt: DateTime
  doneAt_not: DateTime
  doneAt_in: [DateTime!]
  doneAt_not_in: [DateTime!]
  doneAt_lt: DateTime
  doneAt_lte: DateTime
  doneAt_gt: DateTime
  doneAt_gte: DateTime
  event: EventWhereInput
  AND: [TodoWhereInput!]
  OR: [TodoWhereInput!]
  NOT: [TodoWhereInput!]
}

input TodoWhereUniqueInput {
  id: ID
}

type Transaction {
  id: ID!
  user: User!
  date: DateTime!
  type: TransactionType!
  balance: Float!
  payment: Payment
  purchase: Purchase
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]!
  aggregate: AggregateTransaction!
}

input TransactionCreateInput {
  id: ID
  user: UserCreateOneWithoutTransactionsInput!
  date: DateTime!
  type: TransactionType!
  balance: Float!
  payment: PaymentCreateOneWithoutTransactionInput
  purchase: PurchaseCreateOneWithoutTransactionInput
}

input TransactionCreateManyWithoutUserInput {
  create: [TransactionCreateWithoutUserInput!]
  connect: [TransactionWhereUniqueInput!]
}

input TransactionCreateOneWithoutPaymentInput {
  create: TransactionCreateWithoutPaymentInput
  connect: TransactionWhereUniqueInput
}

input TransactionCreateOneWithoutPurchaseInput {
  create: TransactionCreateWithoutPurchaseInput
  connect: TransactionWhereUniqueInput
}

input TransactionCreateWithoutPaymentInput {
  id: ID
  user: UserCreateOneWithoutTransactionsInput!
  date: DateTime!
  type: TransactionType!
  balance: Float!
  purchase: PurchaseCreateOneWithoutTransactionInput
}

input TransactionCreateWithoutPurchaseInput {
  id: ID
  user: UserCreateOneWithoutTransactionsInput!
  date: DateTime!
  type: TransactionType!
  balance: Float!
  payment: PaymentCreateOneWithoutTransactionInput
}

input TransactionCreateWithoutUserInput {
  id: ID
  date: DateTime!
  type: TransactionType!
  balance: Float!
  payment: PaymentCreateOneWithoutTransactionInput
  purchase: PurchaseCreateOneWithoutTransactionInput
}

type TransactionEdge {
  node: Transaction!
  cursor: String!
}

enum TransactionOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  type_ASC
  type_DESC
  balance_ASC
  balance_DESC
}

type TransactionPreviousValues {
  id: ID!
  date: DateTime!
  type: TransactionType!
  balance: Float!
}

input TransactionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  type: TransactionType
  type_not: TransactionType
  type_in: [TransactionType!]
  type_not_in: [TransactionType!]
  balance: Float
  balance_not: Float
  balance_in: [Float!]
  balance_not_in: [Float!]
  balance_lt: Float
  balance_lte: Float
  balance_gt: Float
  balance_gte: Float
  AND: [TransactionScalarWhereInput!]
  OR: [TransactionScalarWhereInput!]
  NOT: [TransactionScalarWhereInput!]
}

type TransactionSubscriptionPayload {
  mutation: MutationType!
  node: Transaction
  updatedFields: [String!]
  previousValues: TransactionPreviousValues
}

input TransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TransactionWhereInput
  AND: [TransactionSubscriptionWhereInput!]
  OR: [TransactionSubscriptionWhereInput!]
  NOT: [TransactionSubscriptionWhereInput!]
}

enum TransactionType {
  PAYMENT
  PURCHASE
}

input TransactionUpdateInput {
  user: UserUpdateOneRequiredWithoutTransactionsInput
  date: DateTime
  type: TransactionType
  balance: Float
  payment: PaymentUpdateOneWithoutTransactionInput
  purchase: PurchaseUpdateOneWithoutTransactionInput
}

input TransactionUpdateManyDataInput {
  date: DateTime
  type: TransactionType
  balance: Float
}

input TransactionUpdateManyMutationInput {
  date: DateTime
  type: TransactionType
  balance: Float
}

input TransactionUpdateManyWithoutUserInput {
  create: [TransactionCreateWithoutUserInput!]
  delete: [TransactionWhereUniqueInput!]
  connect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
  disconnect: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TransactionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [TransactionScalarWhereInput!]
  updateMany: [TransactionUpdateManyWithWhereNestedInput!]
}

input TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput!
  data: TransactionUpdateManyDataInput!
}

input TransactionUpdateOneRequiredWithoutPaymentInput {
  create: TransactionCreateWithoutPaymentInput
  update: TransactionUpdateWithoutPaymentDataInput
  upsert: TransactionUpsertWithoutPaymentInput
  connect: TransactionWhereUniqueInput
}

input TransactionUpdateOneRequiredWithoutPurchaseInput {
  create: TransactionCreateWithoutPurchaseInput
  update: TransactionUpdateWithoutPurchaseDataInput
  upsert: TransactionUpsertWithoutPurchaseInput
  connect: TransactionWhereUniqueInput
}

input TransactionUpdateWithoutPaymentDataInput {
  user: UserUpdateOneRequiredWithoutTransactionsInput
  date: DateTime
  type: TransactionType
  balance: Float
  purchase: PurchaseUpdateOneWithoutTransactionInput
}

input TransactionUpdateWithoutPurchaseDataInput {
  user: UserUpdateOneRequiredWithoutTransactionsInput
  date: DateTime
  type: TransactionType
  balance: Float
  payment: PaymentUpdateOneWithoutTransactionInput
}

input TransactionUpdateWithoutUserDataInput {
  date: DateTime
  type: TransactionType
  balance: Float
  payment: PaymentUpdateOneWithoutTransactionInput
  purchase: PurchaseUpdateOneWithoutTransactionInput
}

input TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput!
  data: TransactionUpdateWithoutUserDataInput!
}

input TransactionUpsertWithoutPaymentInput {
  update: TransactionUpdateWithoutPaymentDataInput!
  create: TransactionCreateWithoutPaymentInput!
}

input TransactionUpsertWithoutPurchaseInput {
  update: TransactionUpdateWithoutPurchaseDataInput!
  create: TransactionCreateWithoutPurchaseInput!
}

input TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput!
  update: TransactionUpdateWithoutUserDataInput!
  create: TransactionCreateWithoutUserInput!
}

input TransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  type: TransactionType
  type_not: TransactionType
  type_in: [TransactionType!]
  type_not_in: [TransactionType!]
  balance: Float
  balance_not: Float
  balance_in: [Float!]
  balance_not_in: [Float!]
  balance_lt: Float
  balance_lte: Float
  balance_gt: Float
  balance_gte: Float
  payment: PaymentWhereInput
  purchase: PurchaseWhereInput
  AND: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
}

input TransactionWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole!
  avatar: String
  loginToken: String
  purchases(where: PurchaseWhereInput, orderBy: PurchaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Purchase!]
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction!]
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  language: String!
  balance: Float!
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  likedPosts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  likedEvents(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
  supportedEvents(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  likedComments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  isOnline: Boolean!
  lastOnline: DateTime
  ownChats(where: ChatWhereInput, orderBy: ChatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Chat!]
  chats(where: ChatWhereInput, orderBy: ChatOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Chat!]
  deleted: Boolean!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateManyInput {
  create: [UserCreateInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutChatsInput {
  create: [UserCreateWithoutChatsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutLikedCommentsInput {
  create: [UserCreateWithoutLikedCommentsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutLikedEventsInput {
  create: [UserCreateWithoutLikedEventsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutLikedPostsInput {
  create: [UserCreateWithoutLikedPostsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutSupportedEventsInput {
  create: [UserCreateWithoutSupportedEventsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutItemsInput {
  create: UserCreateWithoutItemsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutOwnChatsInput {
  create: UserCreateWithoutOwnChatsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPaymentsInput {
  create: UserCreateWithoutPaymentsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPurchasesInput {
  create: UserCreateWithoutPurchasesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTransactionsInput {
  create: UserCreateWithoutTransactionsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutChatsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  deleted: Boolean
}

input UserCreateWithoutCommentsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutItemsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutLikedCommentsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutLikedEventsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutLikedPostsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutOwnChatsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutPaymentsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutPostsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutPurchasesInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutSupportedEventsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

input UserCreateWithoutTransactionsInput {
  id: ID
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  supportedEvents: EventCreateManyWithoutSupportersInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatCreateManyWithoutCreatorInput
  chats: ChatCreateManyWithoutMembersInput
  deleted: Boolean
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  birthdate_ASC
  birthdate_DESC
  role_ASC
  role_DESC
  avatar_ASC
  avatar_DESC
  loginToken_ASC
  loginToken_DESC
  language_ASC
  language_DESC
  balance_ASC
  balance_DESC
  isOnline_ASC
  isOnline_DESC
  lastOnline_ASC
  lastOnline_DESC
  deleted_ASC
  deleted_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  phone: String
  birthdate: DateTime
  role: UserRole!
  avatar: String
  loginToken: String
  language: String!
  balance: Float!
  isOnline: Boolean!
  lastOnline: DateTime
  deleted: Boolean!
}

enum UserRole {
  SUPER
  ADMIN
  MEMBER
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  birthdate: DateTime
  birthdate_not: DateTime
  birthdate_in: [DateTime!]
  birthdate_not_in: [DateTime!]
  birthdate_lt: DateTime
  birthdate_lte: DateTime
  birthdate_gt: DateTime
  birthdate_gte: DateTime
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  loginToken: String
  loginToken_not: String
  loginToken_in: [String!]
  loginToken_not_in: [String!]
  loginToken_lt: String
  loginToken_lte: String
  loginToken_gt: String
  loginToken_gte: String
  loginToken_contains: String
  loginToken_not_contains: String
  loginToken_starts_with: String
  loginToken_not_starts_with: String
  loginToken_ends_with: String
  loginToken_not_ends_with: String
  language: String
  language_not: String
  language_in: [String!]
  language_not_in: [String!]
  language_lt: String
  language_lte: String
  language_gt: String
  language_gte: String
  language_contains: String
  language_not_contains: String
  language_starts_with: String
  language_not_starts_with: String
  language_ends_with: String
  language_not_ends_with: String
  balance: Float
  balance_not: Float
  balance_in: [Float!]
  balance_not_in: [Float!]
  balance_lt: Float
  balance_lte: Float
  balance_gt: Float
  balance_gte: Float
  isOnline: Boolean
  isOnline_not: Boolean
  lastOnline: DateTime
  lastOnline_not: DateTime
  lastOnline_in: [DateTime!]
  lastOnline_not_in: [DateTime!]
  lastOnline_lt: DateTime
  lastOnline_lte: DateTime
  lastOnline_gt: DateTime
  lastOnline_gte: DateTime
  deleted: Boolean
  deleted_not: Boolean
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateManyDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  language: String
  balance: Float
  isOnline: Boolean
  lastOnline: DateTime
  deleted: Boolean
}

input UserUpdateManyInput {
  create: [UserCreateInput!]
  update: [UserUpdateWithWhereUniqueNestedInput!]
  upsert: [UserUpsertWithWhereUniqueNestedInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  language: String
  balance: Float
  isOnline: Boolean
  lastOnline: DateTime
  deleted: Boolean
}

input UserUpdateManyWithoutChatsInput {
  create: [UserCreateWithoutChatsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutChatsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutChatsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutLikedCommentsInput {
  create: [UserCreateWithoutLikedCommentsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutLikedCommentsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutLikedCommentsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutLikedEventsInput {
  create: [UserCreateWithoutLikedEventsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutLikedEventsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutLikedEventsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutLikedPostsInput {
  create: [UserCreateWithoutLikedPostsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutLikedPostsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutLikedPostsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutSupportedEventsInput {
  create: [UserCreateWithoutSupportedEventsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutSupportedEventsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutSupportedEventsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutItemsInput {
  create: UserCreateWithoutItemsInput
  update: UserUpdateWithoutItemsDataInput
  upsert: UserUpsertWithoutItemsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutOwnChatsInput {
  create: UserCreateWithoutOwnChatsInput
  update: UserUpdateWithoutOwnChatsDataInput
  upsert: UserUpsertWithoutOwnChatsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPaymentsInput {
  create: UserCreateWithoutPaymentsInput
  update: UserUpdateWithoutPaymentsDataInput
  upsert: UserUpsertWithoutPaymentsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPurchasesInput {
  create: UserCreateWithoutPurchasesInput
  update: UserUpdateWithoutPurchasesDataInput
  upsert: UserUpsertWithoutPurchasesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutTransactionsInput {
  create: UserCreateWithoutTransactionsInput
  update: UserUpdateWithoutTransactionsDataInput
  upsert: UserUpsertWithoutTransactionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutChatsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  deleted: Boolean
}

input UserUpdateWithoutCommentsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutItemsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutLikedCommentsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutLikedEventsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutLikedPostsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutOwnChatsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutPaymentsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutPostsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutPurchasesDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutSupportedEventsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithoutTransactionsDataInput {
  name: String
  email: String
  phone: String
  birthdate: DateTime
  role: UserRole
  avatar: String
  loginToken: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  language: String
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  supportedEvents: EventUpdateManyWithoutSupportersInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  isOnline: Boolean
  lastOnline: DateTime
  ownChats: ChatUpdateManyWithoutCreatorInput
  chats: ChatUpdateManyWithoutMembersInput
  deleted: Boolean
}

input UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  data: UserUpdateDataInput!
}

input UserUpdateWithWhereUniqueWithoutChatsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutChatsDataInput!
}

input UserUpdateWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutLikedCommentsDataInput!
}

input UserUpdateWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutLikedEventsDataInput!
}

input UserUpdateWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutLikedPostsDataInput!
}

input UserUpdateWithWhereUniqueWithoutSupportedEventsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutSupportedEventsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput!
  create: UserCreateWithoutCommentsInput!
}

input UserUpsertWithoutItemsInput {
  update: UserUpdateWithoutItemsDataInput!
  create: UserCreateWithoutItemsInput!
}

input UserUpsertWithoutOwnChatsInput {
  update: UserUpdateWithoutOwnChatsDataInput!
  create: UserCreateWithoutOwnChatsInput!
}

input UserUpsertWithoutPaymentsInput {
  update: UserUpdateWithoutPaymentsDataInput!
  create: UserCreateWithoutPaymentsInput!
}

input UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput!
  create: UserCreateWithoutPostsInput!
}

input UserUpsertWithoutPurchasesInput {
  update: UserUpdateWithoutPurchasesDataInput!
  create: UserCreateWithoutPurchasesInput!
}

input UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput!
  create: UserCreateWithoutTransactionsInput!
}

input UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput!
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithWhereUniqueWithoutChatsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutChatsDataInput!
  create: UserCreateWithoutChatsInput!
}

input UserUpsertWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutLikedCommentsDataInput!
  create: UserCreateWithoutLikedCommentsInput!
}

input UserUpsertWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutLikedEventsDataInput!
  create: UserCreateWithoutLikedEventsInput!
}

input UserUpsertWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutLikedPostsDataInput!
  create: UserCreateWithoutLikedPostsInput!
}

input UserUpsertWithWhereUniqueWithoutSupportedEventsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutSupportedEventsDataInput!
  create: UserCreateWithoutSupportedEventsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  birthdate: DateTime
  birthdate_not: DateTime
  birthdate_in: [DateTime!]
  birthdate_not_in: [DateTime!]
  birthdate_lt: DateTime
  birthdate_lte: DateTime
  birthdate_gt: DateTime
  birthdate_gte: DateTime
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  loginToken: String
  loginToken_not: String
  loginToken_in: [String!]
  loginToken_not_in: [String!]
  loginToken_lt: String
  loginToken_lte: String
  loginToken_gt: String
  loginToken_gte: String
  loginToken_contains: String
  loginToken_not_contains: String
  loginToken_starts_with: String
  loginToken_not_starts_with: String
  loginToken_ends_with: String
  loginToken_not_ends_with: String
  purchases_every: PurchaseWhereInput
  purchases_some: PurchaseWhereInput
  purchases_none: PurchaseWhereInput
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  transactions_every: TransactionWhereInput
  transactions_some: TransactionWhereInput
  transactions_none: TransactionWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  language: String
  language_not: String
  language_in: [String!]
  language_not_in: [String!]
  language_lt: String
  language_lte: String
  language_gt: String
  language_gte: String
  language_contains: String
  language_not_contains: String
  language_starts_with: String
  language_not_starts_with: String
  language_ends_with: String
  language_not_ends_with: String
  balance: Float
  balance_not: Float
  balance_in: [Float!]
  balance_not_in: [Float!]
  balance_lt: Float
  balance_lte: Float
  balance_gt: Float
  balance_gte: Float
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  likedPosts_every: PostWhereInput
  likedPosts_some: PostWhereInput
  likedPosts_none: PostWhereInput
  likedEvents_every: EventWhereInput
  likedEvents_some: EventWhereInput
  likedEvents_none: EventWhereInput
  supportedEvents_every: EventWhereInput
  supportedEvents_some: EventWhereInput
  supportedEvents_none: EventWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  likedComments_every: CommentWhereInput
  likedComments_some: CommentWhereInput
  likedComments_none: CommentWhereInput
  isOnline: Boolean
  isOnline_not: Boolean
  lastOnline: DateTime
  lastOnline_not: DateTime
  lastOnline_in: [DateTime!]
  lastOnline_not_in: [DateTime!]
  lastOnline_lt: DateTime
  lastOnline_lte: DateTime
  lastOnline_gt: DateTime
  lastOnline_gte: DateTime
  ownChats_every: ChatWhereInput
  ownChats_some: ChatWhereInput
  ownChats_none: ChatWhereInput
  chats_every: ChatWhereInput
  chats_some: ChatWhereInput
  chats_none: ChatWhereInput
  deleted: Boolean
  deleted_not: Boolean
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    