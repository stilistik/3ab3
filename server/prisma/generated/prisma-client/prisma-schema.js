module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.27.1). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateClient {
  count: Int!
}

type AggregateComment {
  count: Int!
}

type AggregateEvent {
  count: Int!
}

type AggregateFile {
  count: Int!
}

type AggregateItem {
  count: Int!
}

type AggregatePayment {
  count: Int!
}

type AggregatePost {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProduction {
  count: Int!
}

type AggregatePurchase {
  count: Int!
}

type AggregateTransaction {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Client {
  id: ID!
  identity: String!
  secret: String!
  name: String!
  trusted: Boolean!
}

type ClientConnection {
  pageInfo: PageInfo!
  edges: [ClientEdge]!
  aggregate: AggregateClient!
}

input ClientCreateInput {
  identity: String!
  secret: String!
  name: String!
  trusted: Boolean
}

type ClientEdge {
  node: Client!
  cursor: String!
}

enum ClientOrderByInput {
  id_ASC
  id_DESC
  identity_ASC
  identity_DESC
  secret_ASC
  secret_DESC
  name_ASC
  name_DESC
  trusted_ASC
  trusted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ClientPreviousValues {
  id: ID!
  identity: String!
  secret: String!
  name: String!
  trusted: Boolean!
}

type ClientSubscriptionPayload {
  mutation: MutationType!
  node: Client
  updatedFields: [String!]
  previousValues: ClientPreviousValues
}

input ClientSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ClientWhereInput
  AND: [ClientSubscriptionWhereInput!]
  OR: [ClientSubscriptionWhereInput!]
  NOT: [ClientSubscriptionWhereInput!]
}

input ClientUpdateInput {
  identity: String
  secret: String
  name: String
  trusted: Boolean
}

input ClientUpdateManyMutationInput {
  identity: String
  secret: String
  name: String
  trusted: Boolean
}

input ClientWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  identity: String
  identity_not: String
  identity_in: [String!]
  identity_not_in: [String!]
  identity_lt: String
  identity_lte: String
  identity_gt: String
  identity_gte: String
  identity_contains: String
  identity_not_contains: String
  identity_starts_with: String
  identity_not_starts_with: String
  identity_ends_with: String
  identity_not_ends_with: String
  secret: String
  secret_not: String
  secret_in: [String!]
  secret_not_in: [String!]
  secret_lt: String
  secret_lte: String
  secret_gt: String
  secret_gte: String
  secret_contains: String
  secret_not_contains: String
  secret_starts_with: String
  secret_not_starts_with: String
  secret_ends_with: String
  secret_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  trusted: Boolean
  trusted_not: Boolean
  AND: [ClientWhereInput!]
  OR: [ClientWhereInput!]
  NOT: [ClientWhereInput!]
}

input ClientWhereUniqueInput {
  id: ID
  identity: String
}

type Comment {
  id: ID!
  text: String!
  date: DateTime!
  author: User!
  likedBy(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  post: Post
  event: Event
}

type CommentConnection {
  pageInfo: PageInfo!
  edges: [CommentEdge]!
  aggregate: AggregateComment!
}

input CommentCreateInput {
  text: String!
  date: DateTime!
  author: UserCreateOneWithoutCommentsInput!
  likedBy: UserCreateManyWithoutLikedCommentsInput
  post: PostCreateOneWithoutCommentsInput
  event: EventCreateOneWithoutCommentsInput
}

input CommentCreateManyWithoutAuthorInput {
  create: [CommentCreateWithoutAuthorInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutEventInput {
  create: [CommentCreateWithoutEventInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutLikedByInput {
  create: [CommentCreateWithoutLikedByInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  connect: [CommentWhereUniqueInput!]
}

input CommentCreateWithoutAuthorInput {
  text: String!
  date: DateTime!
  likedBy: UserCreateManyWithoutLikedCommentsInput
  post: PostCreateOneWithoutCommentsInput
  event: EventCreateOneWithoutCommentsInput
}

input CommentCreateWithoutEventInput {
  text: String!
  date: DateTime!
  author: UserCreateOneWithoutCommentsInput!
  likedBy: UserCreateManyWithoutLikedCommentsInput
  post: PostCreateOneWithoutCommentsInput
}

input CommentCreateWithoutLikedByInput {
  text: String!
  date: DateTime!
  author: UserCreateOneWithoutCommentsInput!
  post: PostCreateOneWithoutCommentsInput
  event: EventCreateOneWithoutCommentsInput
}

input CommentCreateWithoutPostInput {
  text: String!
  date: DateTime!
  author: UserCreateOneWithoutCommentsInput!
  likedBy: UserCreateManyWithoutLikedCommentsInput
  event: EventCreateOneWithoutCommentsInput
}

type CommentEdge {
  node: Comment!
  cursor: String!
}

enum CommentOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  date_ASC
  date_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CommentPreviousValues {
  id: ID!
  text: String!
  date: DateTime!
}

input CommentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [CommentScalarWhereInput!]
  OR: [CommentScalarWhereInput!]
  NOT: [CommentScalarWhereInput!]
}

type CommentSubscriptionPayload {
  mutation: MutationType!
  node: Comment
  updatedFields: [String!]
  previousValues: CommentPreviousValues
}

input CommentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CommentWhereInput
  AND: [CommentSubscriptionWhereInput!]
  OR: [CommentSubscriptionWhereInput!]
  NOT: [CommentSubscriptionWhereInput!]
}

input CommentUpdateInput {
  text: String
  date: DateTime
  author: UserUpdateOneRequiredWithoutCommentsInput
  likedBy: UserUpdateManyWithoutLikedCommentsInput
  post: PostUpdateOneWithoutCommentsInput
  event: EventUpdateOneWithoutCommentsInput
}

input CommentUpdateManyDataInput {
  text: String
  date: DateTime
}

input CommentUpdateManyMutationInput {
  text: String
  date: DateTime
}

input CommentUpdateManyWithoutAuthorInput {
  create: [CommentCreateWithoutAuthorInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutEventInput {
  create: [CommentCreateWithoutEventInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutEventInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutEventInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutLikedByInput {
  create: [CommentCreateWithoutLikedByInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutLikedByInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutLikedByInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithoutPostInput {
  create: [CommentCreateWithoutPostInput!]
  delete: [CommentWhereUniqueInput!]
  connect: [CommentWhereUniqueInput!]
  set: [CommentWhereUniqueInput!]
  disconnect: [CommentWhereUniqueInput!]
  update: [CommentUpdateWithWhereUniqueWithoutPostInput!]
  upsert: [CommentUpsertWithWhereUniqueWithoutPostInput!]
  deleteMany: [CommentScalarWhereInput!]
  updateMany: [CommentUpdateManyWithWhereNestedInput!]
}

input CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput!
  data: CommentUpdateManyDataInput!
}

input CommentUpdateWithoutAuthorDataInput {
  text: String
  date: DateTime
  likedBy: UserUpdateManyWithoutLikedCommentsInput
  post: PostUpdateOneWithoutCommentsInput
  event: EventUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutEventDataInput {
  text: String
  date: DateTime
  author: UserUpdateOneRequiredWithoutCommentsInput
  likedBy: UserUpdateManyWithoutLikedCommentsInput
  post: PostUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutLikedByDataInput {
  text: String
  date: DateTime
  author: UserUpdateOneRequiredWithoutCommentsInput
  post: PostUpdateOneWithoutCommentsInput
  event: EventUpdateOneWithoutCommentsInput
}

input CommentUpdateWithoutPostDataInput {
  text: String
  date: DateTime
  author: UserUpdateOneRequiredWithoutCommentsInput
  likedBy: UserUpdateManyWithoutLikedCommentsInput
  event: EventUpdateOneWithoutCommentsInput
}

input CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutAuthorDataInput!
}

input CommentUpdateWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutEventDataInput!
}

input CommentUpdateWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutLikedByDataInput!
}

input CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  data: CommentUpdateWithoutPostDataInput!
}

input CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutAuthorDataInput!
  create: CommentCreateWithoutAuthorInput!
}

input CommentUpsertWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutEventDataInput!
  create: CommentCreateWithoutEventInput!
}

input CommentUpsertWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutLikedByDataInput!
  create: CommentCreateWithoutLikedByInput!
}

input CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput!
  update: CommentUpdateWithoutPostDataInput!
  create: CommentCreateWithoutPostInput!
}

input CommentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  author: UserWhereInput
  likedBy_every: UserWhereInput
  likedBy_some: UserWhereInput
  likedBy_none: UserWhereInput
  post: PostWhereInput
  event: EventWhereInput
  AND: [CommentWhereInput!]
  OR: [CommentWhereInput!]
  NOT: [CommentWhereInput!]
}

input CommentWhereUniqueInput {
  id: ID
}

scalar DateTime

type Event {
  id: ID!
  title: String!
  description: String!
  date: DateTime!
  image: String!
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  likedBy(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  owner: User!
  committee(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
}

type EventConnection {
  pageInfo: PageInfo!
  edges: [EventEdge]!
  aggregate: AggregateEvent!
}

input EventCreateInput {
  title: String!
  description: String!
  date: DateTime!
  image: String!
  comments: CommentCreateManyWithoutEventInput
  likedBy: UserCreateManyWithoutLikedEventsInput
  owner: UserCreateOneInput!
  committee: UserCreateManyWithoutEventsInput
}

input EventCreateManyWithoutCommitteeInput {
  create: [EventCreateWithoutCommitteeInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateManyWithoutLikedByInput {
  create: [EventCreateWithoutLikedByInput!]
  connect: [EventWhereUniqueInput!]
}

input EventCreateOneWithoutCommentsInput {
  create: EventCreateWithoutCommentsInput
  connect: EventWhereUniqueInput
}

input EventCreateWithoutCommentsInput {
  title: String!
  description: String!
  date: DateTime!
  image: String!
  likedBy: UserCreateManyWithoutLikedEventsInput
  owner: UserCreateOneInput!
  committee: UserCreateManyWithoutEventsInput
}

input EventCreateWithoutCommitteeInput {
  title: String!
  description: String!
  date: DateTime!
  image: String!
  comments: CommentCreateManyWithoutEventInput
  likedBy: UserCreateManyWithoutLikedEventsInput
  owner: UserCreateOneInput!
}

input EventCreateWithoutLikedByInput {
  title: String!
  description: String!
  date: DateTime!
  image: String!
  comments: CommentCreateManyWithoutEventInput
  owner: UserCreateOneInput!
  committee: UserCreateManyWithoutEventsInput
}

type EventEdge {
  node: Event!
  cursor: String!
}

enum EventOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  date_ASC
  date_DESC
  image_ASC
  image_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EventPreviousValues {
  id: ID!
  title: String!
  description: String!
  date: DateTime!
  image: String!
}

input EventScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  AND: [EventScalarWhereInput!]
  OR: [EventScalarWhereInput!]
  NOT: [EventScalarWhereInput!]
}

type EventSubscriptionPayload {
  mutation: MutationType!
  node: Event
  updatedFields: [String!]
  previousValues: EventPreviousValues
}

input EventSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EventWhereInput
  AND: [EventSubscriptionWhereInput!]
  OR: [EventSubscriptionWhereInput!]
  NOT: [EventSubscriptionWhereInput!]
}

input EventUpdateInput {
  title: String
  description: String
  date: DateTime
  image: String
  comments: CommentUpdateManyWithoutEventInput
  likedBy: UserUpdateManyWithoutLikedEventsInput
  owner: UserUpdateOneRequiredInput
  committee: UserUpdateManyWithoutEventsInput
}

input EventUpdateManyDataInput {
  title: String
  description: String
  date: DateTime
  image: String
}

input EventUpdateManyMutationInput {
  title: String
  description: String
  date: DateTime
  image: String
}

input EventUpdateManyWithoutCommitteeInput {
  create: [EventCreateWithoutCommitteeInput!]
  delete: [EventWhereUniqueInput!]
  connect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutCommitteeInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutCommitteeInput!]
  deleteMany: [EventScalarWhereInput!]
  updateMany: [EventUpdateManyWithWhereNestedInput!]
}

input EventUpdateManyWithoutLikedByInput {
  create: [EventCreateWithoutLikedByInput!]
  delete: [EventWhereUniqueInput!]
  connect: [EventWhereUniqueInput!]
  set: [EventWhereUniqueInput!]
  disconnect: [EventWhereUniqueInput!]
  update: [EventUpdateWithWhereUniqueWithoutLikedByInput!]
  upsert: [EventUpsertWithWhereUniqueWithoutLikedByInput!]
  deleteMany: [EventScalarWhereInput!]
  updateMany: [EventUpdateManyWithWhereNestedInput!]
}

input EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput!
  data: EventUpdateManyDataInput!
}

input EventUpdateOneWithoutCommentsInput {
  create: EventCreateWithoutCommentsInput
  update: EventUpdateWithoutCommentsDataInput
  upsert: EventUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: EventWhereUniqueInput
}

input EventUpdateWithoutCommentsDataInput {
  title: String
  description: String
  date: DateTime
  image: String
  likedBy: UserUpdateManyWithoutLikedEventsInput
  owner: UserUpdateOneRequiredInput
  committee: UserUpdateManyWithoutEventsInput
}

input EventUpdateWithoutCommitteeDataInput {
  title: String
  description: String
  date: DateTime
  image: String
  comments: CommentUpdateManyWithoutEventInput
  likedBy: UserUpdateManyWithoutLikedEventsInput
  owner: UserUpdateOneRequiredInput
}

input EventUpdateWithoutLikedByDataInput {
  title: String
  description: String
  date: DateTime
  image: String
  comments: CommentUpdateManyWithoutEventInput
  owner: UserUpdateOneRequiredInput
  committee: UserUpdateManyWithoutEventsInput
}

input EventUpdateWithWhereUniqueWithoutCommitteeInput {
  where: EventWhereUniqueInput!
  data: EventUpdateWithoutCommitteeDataInput!
}

input EventUpdateWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput!
  data: EventUpdateWithoutLikedByDataInput!
}

input EventUpsertWithoutCommentsInput {
  update: EventUpdateWithoutCommentsDataInput!
  create: EventCreateWithoutCommentsInput!
}

input EventUpsertWithWhereUniqueWithoutCommitteeInput {
  where: EventWhereUniqueInput!
  update: EventUpdateWithoutCommitteeDataInput!
  create: EventCreateWithoutCommitteeInput!
}

input EventUpsertWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput!
  update: EventUpdateWithoutLikedByDataInput!
  create: EventCreateWithoutLikedByInput!
}

input EventWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  likedBy_every: UserWhereInput
  likedBy_some: UserWhereInput
  likedBy_none: UserWhereInput
  owner: UserWhereInput
  committee_every: UserWhereInput
  committee_some: UserWhereInput
  committee_none: UserWhereInput
  AND: [EventWhereInput!]
  OR: [EventWhereInput!]
  NOT: [EventWhereInput!]
}

input EventWhereUniqueInput {
  id: ID
}

type File {
  id: ID!
  fileId: String!
  hash: String!
  uri: String!
  filename: String!
  path: String!
  mimetype: String!
  extension: String!
  createdAt: DateTime!
}

type FileConnection {
  pageInfo: PageInfo!
  edges: [FileEdge]!
  aggregate: AggregateFile!
}

input FileCreateInput {
  fileId: String!
  hash: String!
  uri: String!
  filename: String!
  path: String!
  mimetype: String!
  extension: String!
}

type FileEdge {
  node: File!
  cursor: String!
}

enum FileOrderByInput {
  id_ASC
  id_DESC
  fileId_ASC
  fileId_DESC
  hash_ASC
  hash_DESC
  uri_ASC
  uri_DESC
  filename_ASC
  filename_DESC
  path_ASC
  path_DESC
  mimetype_ASC
  mimetype_DESC
  extension_ASC
  extension_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type FilePreviousValues {
  id: ID!
  fileId: String!
  hash: String!
  uri: String!
  filename: String!
  path: String!
  mimetype: String!
  extension: String!
  createdAt: DateTime!
}

type FileSubscriptionPayload {
  mutation: MutationType!
  node: File
  updatedFields: [String!]
  previousValues: FilePreviousValues
}

input FileSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: FileWhereInput
  AND: [FileSubscriptionWhereInput!]
  OR: [FileSubscriptionWhereInput!]
  NOT: [FileSubscriptionWhereInput!]
}

input FileUpdateInput {
  fileId: String
  hash: String
  uri: String
  filename: String
  path: String
  mimetype: String
  extension: String
}

input FileUpdateManyMutationInput {
  fileId: String
  hash: String
  uri: String
  filename: String
  path: String
  mimetype: String
  extension: String
}

input FileWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  fileId: String
  fileId_not: String
  fileId_in: [String!]
  fileId_not_in: [String!]
  fileId_lt: String
  fileId_lte: String
  fileId_gt: String
  fileId_gte: String
  fileId_contains: String
  fileId_not_contains: String
  fileId_starts_with: String
  fileId_not_starts_with: String
  fileId_ends_with: String
  fileId_not_ends_with: String
  hash: String
  hash_not: String
  hash_in: [String!]
  hash_not_in: [String!]
  hash_lt: String
  hash_lte: String
  hash_gt: String
  hash_gte: String
  hash_contains: String
  hash_not_contains: String
  hash_starts_with: String
  hash_not_starts_with: String
  hash_ends_with: String
  hash_not_ends_with: String
  uri: String
  uri_not: String
  uri_in: [String!]
  uri_not_in: [String!]
  uri_lt: String
  uri_lte: String
  uri_gt: String
  uri_gte: String
  uri_contains: String
  uri_not_contains: String
  uri_starts_with: String
  uri_not_starts_with: String
  uri_ends_with: String
  uri_not_ends_with: String
  filename: String
  filename_not: String
  filename_in: [String!]
  filename_not_in: [String!]
  filename_lt: String
  filename_lte: String
  filename_gt: String
  filename_gte: String
  filename_contains: String
  filename_not_contains: String
  filename_starts_with: String
  filename_not_starts_with: String
  filename_ends_with: String
  filename_not_ends_with: String
  path: String
  path_not: String
  path_in: [String!]
  path_not_in: [String!]
  path_lt: String
  path_lte: String
  path_gt: String
  path_gte: String
  path_contains: String
  path_not_contains: String
  path_starts_with: String
  path_not_starts_with: String
  path_ends_with: String
  path_not_ends_with: String
  mimetype: String
  mimetype_not: String
  mimetype_in: [String!]
  mimetype_not_in: [String!]
  mimetype_lt: String
  mimetype_lte: String
  mimetype_gt: String
  mimetype_gte: String
  mimetype_contains: String
  mimetype_not_contains: String
  mimetype_starts_with: String
  mimetype_not_starts_with: String
  mimetype_ends_with: String
  mimetype_not_ends_with: String
  extension: String
  extension_not: String
  extension_in: [String!]
  extension_not_in: [String!]
  extension_lt: String
  extension_lte: String
  extension_gt: String
  extension_gte: String
  extension_contains: String
  extension_not_contains: String
  extension_starts_with: String
  extension_not_starts_with: String
  extension_ends_with: String
  extension_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [FileWhereInput!]
  OR: [FileWhereInput!]
  NOT: [FileWhereInput!]
}

input FileWhereUniqueInput {
  id: ID
  fileId: String
  hash: String
  uri: String
}

type Item {
  id: ID!
  product: Product!
  user: User!
  price: Float!
  amount: Int!
}

type ItemConnection {
  pageInfo: PageInfo!
  edges: [ItemEdge]!
  aggregate: AggregateItem!
}

input ItemCreateInput {
  product: ProductCreateOneInput!
  user: UserCreateOneWithoutItemsInput!
  price: Float!
  amount: Int!
}

input ItemCreateManyInput {
  create: [ItemCreateInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateManyWithoutUserInput {
  create: [ItemCreateWithoutUserInput!]
  connect: [ItemWhereUniqueInput!]
}

input ItemCreateWithoutUserInput {
  product: ProductCreateOneInput!
  price: Float!
  amount: Int!
}

type ItemEdge {
  node: Item!
  cursor: String!
}

enum ItemOrderByInput {
  id_ASC
  id_DESC
  price_ASC
  price_DESC
  amount_ASC
  amount_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ItemPreviousValues {
  id: ID!
  price: Float!
  amount: Int!
}

input ItemScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [ItemScalarWhereInput!]
  OR: [ItemScalarWhereInput!]
  NOT: [ItemScalarWhereInput!]
}

type ItemSubscriptionPayload {
  mutation: MutationType!
  node: Item
  updatedFields: [String!]
  previousValues: ItemPreviousValues
}

input ItemSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ItemWhereInput
  AND: [ItemSubscriptionWhereInput!]
  OR: [ItemSubscriptionWhereInput!]
  NOT: [ItemSubscriptionWhereInput!]
}

input ItemUpdateDataInput {
  product: ProductUpdateOneRequiredInput
  user: UserUpdateOneRequiredWithoutItemsInput
  price: Float
  amount: Int
}

input ItemUpdateInput {
  product: ProductUpdateOneRequiredInput
  user: UserUpdateOneRequiredWithoutItemsInput
  price: Float
  amount: Int
}

input ItemUpdateManyDataInput {
  price: Float
  amount: Int
}

input ItemUpdateManyInput {
  create: [ItemCreateInput!]
  update: [ItemUpdateWithWhereUniqueNestedInput!]
  upsert: [ItemUpsertWithWhereUniqueNestedInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyMutationInput {
  price: Float
  amount: Int
}

input ItemUpdateManyWithoutUserInput {
  create: [ItemCreateWithoutUserInput!]
  delete: [ItemWhereUniqueInput!]
  connect: [ItemWhereUniqueInput!]
  set: [ItemWhereUniqueInput!]
  disconnect: [ItemWhereUniqueInput!]
  update: [ItemUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [ItemUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [ItemScalarWhereInput!]
  updateMany: [ItemUpdateManyWithWhereNestedInput!]
}

input ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput!
  data: ItemUpdateManyDataInput!
}

input ItemUpdateWithoutUserDataInput {
  product: ProductUpdateOneRequiredInput
  price: Float
  amount: Int
}

input ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateDataInput!
}

input ItemUpdateWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput!
  data: ItemUpdateWithoutUserDataInput!
}

input ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateDataInput!
  create: ItemCreateInput!
}

input ItemUpsertWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput!
  update: ItemUpdateWithoutUserDataInput!
  create: ItemCreateWithoutUserInput!
}

input ItemWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  product: ProductWhereInput
  user: UserWhereInput
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [ItemWhereInput!]
  OR: [ItemWhereInput!]
  NOT: [ItemWhereInput!]
}

input ItemWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createClient(data: ClientCreateInput!): Client!
  updateClient(data: ClientUpdateInput!, where: ClientWhereUniqueInput!): Client
  updateManyClients(data: ClientUpdateManyMutationInput!, where: ClientWhereInput): BatchPayload!
  upsertClient(where: ClientWhereUniqueInput!, create: ClientCreateInput!, update: ClientUpdateInput!): Client!
  deleteClient(where: ClientWhereUniqueInput!): Client
  deleteManyClients(where: ClientWhereInput): BatchPayload!
  createComment(data: CommentCreateInput!): Comment!
  updateComment(data: CommentUpdateInput!, where: CommentWhereUniqueInput!): Comment
  updateManyComments(data: CommentUpdateManyMutationInput!, where: CommentWhereInput): BatchPayload!
  upsertComment(where: CommentWhereUniqueInput!, create: CommentCreateInput!, update: CommentUpdateInput!): Comment!
  deleteComment(where: CommentWhereUniqueInput!): Comment
  deleteManyComments(where: CommentWhereInput): BatchPayload!
  createEvent(data: EventCreateInput!): Event!
  updateEvent(data: EventUpdateInput!, where: EventWhereUniqueInput!): Event
  updateManyEvents(data: EventUpdateManyMutationInput!, where: EventWhereInput): BatchPayload!
  upsertEvent(where: EventWhereUniqueInput!, create: EventCreateInput!, update: EventUpdateInput!): Event!
  deleteEvent(where: EventWhereUniqueInput!): Event
  deleteManyEvents(where: EventWhereInput): BatchPayload!
  createFile(data: FileCreateInput!): File!
  updateFile(data: FileUpdateInput!, where: FileWhereUniqueInput!): File
  updateManyFiles(data: FileUpdateManyMutationInput!, where: FileWhereInput): BatchPayload!
  upsertFile(where: FileWhereUniqueInput!, create: FileCreateInput!, update: FileUpdateInput!): File!
  deleteFile(where: FileWhereUniqueInput!): File
  deleteManyFiles(where: FileWhereInput): BatchPayload!
  createItem(data: ItemCreateInput!): Item!
  updateItem(data: ItemUpdateInput!, where: ItemWhereUniqueInput!): Item
  updateManyItems(data: ItemUpdateManyMutationInput!, where: ItemWhereInput): BatchPayload!
  upsertItem(where: ItemWhereUniqueInput!, create: ItemCreateInput!, update: ItemUpdateInput!): Item!
  deleteItem(where: ItemWhereUniqueInput!): Item
  deleteManyItems(where: ItemWhereInput): BatchPayload!
  createPayment(data: PaymentCreateInput!): Payment!
  updatePayment(data: PaymentUpdateInput!, where: PaymentWhereUniqueInput!): Payment
  updateManyPayments(data: PaymentUpdateManyMutationInput!, where: PaymentWhereInput): BatchPayload!
  upsertPayment(where: PaymentWhereUniqueInput!, create: PaymentCreateInput!, update: PaymentUpdateInput!): Payment!
  deletePayment(where: PaymentWhereUniqueInput!): Payment
  deleteManyPayments(where: PaymentWhereInput): BatchPayload!
  createPost(data: PostCreateInput!): Post!
  updatePost(data: PostUpdateInput!, where: PostWhereUniqueInput!): Post
  updateManyPosts(data: PostUpdateManyMutationInput!, where: PostWhereInput): BatchPayload!
  upsertPost(where: PostWhereUniqueInput!, create: PostCreateInput!, update: PostUpdateInput!): Post!
  deletePost(where: PostWhereUniqueInput!): Post
  deleteManyPosts(where: PostWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProduction(data: ProductionCreateInput!): Production!
  updateProduction(data: ProductionUpdateInput!, where: ProductionWhereUniqueInput!): Production
  updateManyProductions(data: ProductionUpdateManyMutationInput!, where: ProductionWhereInput): BatchPayload!
  upsertProduction(where: ProductionWhereUniqueInput!, create: ProductionCreateInput!, update: ProductionUpdateInput!): Production!
  deleteProduction(where: ProductionWhereUniqueInput!): Production
  deleteManyProductions(where: ProductionWhereInput): BatchPayload!
  createPurchase(data: PurchaseCreateInput!): Purchase!
  updatePurchase(data: PurchaseUpdateInput!, where: PurchaseWhereUniqueInput!): Purchase
  updateManyPurchases(data: PurchaseUpdateManyMutationInput!, where: PurchaseWhereInput): BatchPayload!
  upsertPurchase(where: PurchaseWhereUniqueInput!, create: PurchaseCreateInput!, update: PurchaseUpdateInput!): Purchase!
  deletePurchase(where: PurchaseWhereUniqueInput!): Purchase
  deleteManyPurchases(where: PurchaseWhereInput): BatchPayload!
  createTransaction(data: TransactionCreateInput!): Transaction!
  updateTransaction(data: TransactionUpdateInput!, where: TransactionWhereUniqueInput!): Transaction
  updateManyTransactions(data: TransactionUpdateManyMutationInput!, where: TransactionWhereInput): BatchPayload!
  upsertTransaction(where: TransactionWhereUniqueInput!, create: TransactionCreateInput!, update: TransactionUpdateInput!): Transaction!
  deleteTransaction(where: TransactionWhereUniqueInput!): Transaction
  deleteManyTransactions(where: TransactionWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Payment {
  id: ID!
  amount: Float!
  user: User!
  date: DateTime!
  verified: Boolean!
  transaction: Transaction!
}

type PaymentConnection {
  pageInfo: PageInfo!
  edges: [PaymentEdge]!
  aggregate: AggregatePayment!
}

input PaymentCreateInput {
  amount: Float!
  user: UserCreateOneWithoutPaymentsInput!
  date: DateTime!
  verified: Boolean
  transaction: TransactionCreateOneWithoutPaymentInput!
}

input PaymentCreateManyWithoutUserInput {
  create: [PaymentCreateWithoutUserInput!]
  connect: [PaymentWhereUniqueInput!]
}

input PaymentCreateOneWithoutTransactionInput {
  create: PaymentCreateWithoutTransactionInput
  connect: PaymentWhereUniqueInput
}

input PaymentCreateWithoutTransactionInput {
  amount: Float!
  user: UserCreateOneWithoutPaymentsInput!
  date: DateTime!
  verified: Boolean
}

input PaymentCreateWithoutUserInput {
  amount: Float!
  date: DateTime!
  verified: Boolean
  transaction: TransactionCreateOneWithoutPaymentInput!
}

type PaymentEdge {
  node: Payment!
  cursor: String!
}

enum PaymentOrderByInput {
  id_ASC
  id_DESC
  amount_ASC
  amount_DESC
  date_ASC
  date_DESC
  verified_ASC
  verified_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PaymentPreviousValues {
  id: ID!
  amount: Float!
  date: DateTime!
  verified: Boolean!
}

input PaymentScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  verified: Boolean
  verified_not: Boolean
  AND: [PaymentScalarWhereInput!]
  OR: [PaymentScalarWhereInput!]
  NOT: [PaymentScalarWhereInput!]
}

type PaymentSubscriptionPayload {
  mutation: MutationType!
  node: Payment
  updatedFields: [String!]
  previousValues: PaymentPreviousValues
}

input PaymentSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PaymentWhereInput
  AND: [PaymentSubscriptionWhereInput!]
  OR: [PaymentSubscriptionWhereInput!]
  NOT: [PaymentSubscriptionWhereInput!]
}

input PaymentUpdateInput {
  amount: Float
  user: UserUpdateOneRequiredWithoutPaymentsInput
  date: DateTime
  verified: Boolean
  transaction: TransactionUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateManyDataInput {
  amount: Float
  date: DateTime
  verified: Boolean
}

input PaymentUpdateManyMutationInput {
  amount: Float
  date: DateTime
  verified: Boolean
}

input PaymentUpdateManyWithoutUserInput {
  create: [PaymentCreateWithoutUserInput!]
  delete: [PaymentWhereUniqueInput!]
  connect: [PaymentWhereUniqueInput!]
  set: [PaymentWhereUniqueInput!]
  disconnect: [PaymentWhereUniqueInput!]
  update: [PaymentUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [PaymentUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [PaymentScalarWhereInput!]
  updateMany: [PaymentUpdateManyWithWhereNestedInput!]
}

input PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput!
  data: PaymentUpdateManyDataInput!
}

input PaymentUpdateOneWithoutTransactionInput {
  create: PaymentCreateWithoutTransactionInput
  update: PaymentUpdateWithoutTransactionDataInput
  upsert: PaymentUpsertWithoutTransactionInput
  delete: Boolean
  disconnect: Boolean
  connect: PaymentWhereUniqueInput
}

input PaymentUpdateWithoutTransactionDataInput {
  amount: Float
  user: UserUpdateOneRequiredWithoutPaymentsInput
  date: DateTime
  verified: Boolean
}

input PaymentUpdateWithoutUserDataInput {
  amount: Float
  date: DateTime
  verified: Boolean
  transaction: TransactionUpdateOneRequiredWithoutPaymentInput
}

input PaymentUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput!
  data: PaymentUpdateWithoutUserDataInput!
}

input PaymentUpsertWithoutTransactionInput {
  update: PaymentUpdateWithoutTransactionDataInput!
  create: PaymentCreateWithoutTransactionInput!
}

input PaymentUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput!
  update: PaymentUpdateWithoutUserDataInput!
  create: PaymentCreateWithoutUserInput!
}

input PaymentWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  amount: Float
  amount_not: Float
  amount_in: [Float!]
  amount_not_in: [Float!]
  amount_lt: Float
  amount_lte: Float
  amount_gt: Float
  amount_gte: Float
  user: UserWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  verified: Boolean
  verified_not: Boolean
  transaction: TransactionWhereInput
  AND: [PaymentWhereInput!]
  OR: [PaymentWhereInput!]
  NOT: [PaymentWhereInput!]
}

input PaymentWhereUniqueInput {
  id: ID
}

type Post {
  id: ID!
  text: String!
  image: String
  author: User!
  likedBy(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  date: DateTime!
}

type PostConnection {
  pageInfo: PageInfo!
  edges: [PostEdge]!
  aggregate: AggregatePost!
}

input PostCreateInput {
  text: String!
  image: String
  author: UserCreateOneWithoutPostsInput!
  likedBy: UserCreateManyWithoutLikedPostsInput
  comments: CommentCreateManyWithoutPostInput
  date: DateTime!
}

input PostCreateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateManyWithoutLikedByInput {
  create: [PostCreateWithoutLikedByInput!]
  connect: [PostWhereUniqueInput!]
}

input PostCreateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  connect: PostWhereUniqueInput
}

input PostCreateWithoutAuthorInput {
  text: String!
  image: String
  likedBy: UserCreateManyWithoutLikedPostsInput
  comments: CommentCreateManyWithoutPostInput
  date: DateTime!
}

input PostCreateWithoutCommentsInput {
  text: String!
  image: String
  author: UserCreateOneWithoutPostsInput!
  likedBy: UserCreateManyWithoutLikedPostsInput
  date: DateTime!
}

input PostCreateWithoutLikedByInput {
  text: String!
  image: String
  author: UserCreateOneWithoutPostsInput!
  comments: CommentCreateManyWithoutPostInput
  date: DateTime!
}

type PostEdge {
  node: Post!
  cursor: String!
}

enum PostOrderByInput {
  id_ASC
  id_DESC
  text_ASC
  text_DESC
  image_ASC
  image_DESC
  date_ASC
  date_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PostPreviousValues {
  id: ID!
  text: String!
  image: String
  date: DateTime!
}

input PostScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [PostScalarWhereInput!]
  OR: [PostScalarWhereInput!]
  NOT: [PostScalarWhereInput!]
}

type PostSubscriptionPayload {
  mutation: MutationType!
  node: Post
  updatedFields: [String!]
  previousValues: PostPreviousValues
}

input PostSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PostWhereInput
  AND: [PostSubscriptionWhereInput!]
  OR: [PostSubscriptionWhereInput!]
  NOT: [PostSubscriptionWhereInput!]
}

input PostUpdateInput {
  text: String
  image: String
  author: UserUpdateOneRequiredWithoutPostsInput
  likedBy: UserUpdateManyWithoutLikedPostsInput
  comments: CommentUpdateManyWithoutPostInput
  date: DateTime
}

input PostUpdateManyDataInput {
  text: String
  image: String
  date: DateTime
}

input PostUpdateManyMutationInput {
  text: String
  image: String
  date: DateTime
}

input PostUpdateManyWithoutAuthorInput {
  create: [PostCreateWithoutAuthorInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutAuthorInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutAuthorInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithoutLikedByInput {
  create: [PostCreateWithoutLikedByInput!]
  delete: [PostWhereUniqueInput!]
  connect: [PostWhereUniqueInput!]
  set: [PostWhereUniqueInput!]
  disconnect: [PostWhereUniqueInput!]
  update: [PostUpdateWithWhereUniqueWithoutLikedByInput!]
  upsert: [PostUpsertWithWhereUniqueWithoutLikedByInput!]
  deleteMany: [PostScalarWhereInput!]
  updateMany: [PostUpdateManyWithWhereNestedInput!]
}

input PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput!
  data: PostUpdateManyDataInput!
}

input PostUpdateOneWithoutCommentsInput {
  create: PostCreateWithoutCommentsInput
  update: PostUpdateWithoutCommentsDataInput
  upsert: PostUpsertWithoutCommentsInput
  delete: Boolean
  disconnect: Boolean
  connect: PostWhereUniqueInput
}

input PostUpdateWithoutAuthorDataInput {
  text: String
  image: String
  likedBy: UserUpdateManyWithoutLikedPostsInput
  comments: CommentUpdateManyWithoutPostInput
  date: DateTime
}

input PostUpdateWithoutCommentsDataInput {
  text: String
  image: String
  author: UserUpdateOneRequiredWithoutPostsInput
  likedBy: UserUpdateManyWithoutLikedPostsInput
  date: DateTime
}

input PostUpdateWithoutLikedByDataInput {
  text: String
  image: String
  author: UserUpdateOneRequiredWithoutPostsInput
  comments: CommentUpdateManyWithoutPostInput
  date: DateTime
}

input PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutAuthorDataInput!
}

input PostUpdateWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput!
  data: PostUpdateWithoutLikedByDataInput!
}

input PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput!
  create: PostCreateWithoutCommentsInput!
}

input PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutAuthorDataInput!
  create: PostCreateWithoutAuthorInput!
}

input PostUpsertWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput!
  update: PostUpdateWithoutLikedByDataInput!
  create: PostCreateWithoutLikedByInput!
}

input PostWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  text: String
  text_not: String
  text_in: [String!]
  text_not_in: [String!]
  text_lt: String
  text_lte: String
  text_gt: String
  text_gte: String
  text_contains: String
  text_not_contains: String
  text_starts_with: String
  text_not_starts_with: String
  text_ends_with: String
  text_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  author: UserWhereInput
  likedBy_every: UserWhereInput
  likedBy_some: UserWhereInput
  likedBy_none: UserWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [PostWhereInput!]
  OR: [PostWhereInput!]
  NOT: [PostWhereInput!]
}

input PostWhereUniqueInput {
  id: ID
}

type Product {
  id: ID!
  name: String!
  price: Float!
  index: Int!
  thumbnail: String
  deleted: Boolean!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  name: String!
  price: Float!
  index: Int!
  thumbnail: String
  deleted: Boolean
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

type Production {
  id: ID!
  title: String!
  description: String!
  image: String!
  index: Int!
  show: Boolean!
}

type ProductionConnection {
  pageInfo: PageInfo!
  edges: [ProductionEdge]!
  aggregate: AggregateProduction!
}

input ProductionCreateInput {
  title: String!
  description: String!
  image: String!
  index: Int!
  show: Boolean
}

type ProductionEdge {
  node: Production!
  cursor: String!
}

enum ProductionOrderByInput {
  id_ASC
  id_DESC
  title_ASC
  title_DESC
  description_ASC
  description_DESC
  image_ASC
  image_DESC
  index_ASC
  index_DESC
  show_ASC
  show_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductionPreviousValues {
  id: ID!
  title: String!
  description: String!
  image: String!
  index: Int!
  show: Boolean!
}

type ProductionSubscriptionPayload {
  mutation: MutationType!
  node: Production
  updatedFields: [String!]
  previousValues: ProductionPreviousValues
}

input ProductionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductionWhereInput
  AND: [ProductionSubscriptionWhereInput!]
  OR: [ProductionSubscriptionWhereInput!]
  NOT: [ProductionSubscriptionWhereInput!]
}

input ProductionUpdateInput {
  title: String
  description: String
  image: String
  index: Int
  show: Boolean
}

input ProductionUpdateManyMutationInput {
  title: String
  description: String
  image: String
  index: Int
  show: Boolean
}

input ProductionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  title: String
  title_not: String
  title_in: [String!]
  title_not_in: [String!]
  title_lt: String
  title_lte: String
  title_gt: String
  title_gte: String
  title_contains: String
  title_not_contains: String
  title_starts_with: String
  title_not_starts_with: String
  title_ends_with: String
  title_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  show: Boolean
  show_not: Boolean
  AND: [ProductionWhereInput!]
  OR: [ProductionWhereInput!]
  NOT: [ProductionWhereInput!]
}

input ProductionWhereUniqueInput {
  id: ID
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  price_ASC
  price_DESC
  index_ASC
  index_DESC
  thumbnail_ASC
  thumbnail_DESC
  deleted_ASC
  deleted_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  name: String!
  price: Float!
  index: Int!
  thumbnail: String
  deleted: Boolean!
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  name: String
  price: Float
  index: Int
  thumbnail: String
  deleted: Boolean
}

input ProductUpdateInput {
  name: String
  price: Float
  index: Int
  thumbnail: String
  deleted: Boolean
}

input ProductUpdateManyMutationInput {
  name: String
  price: Float
  index: Int
  thumbnail: String
  deleted: Boolean
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  price: Float
  price_not: Float
  price_in: [Float!]
  price_not_in: [Float!]
  price_lt: Float
  price_lte: Float
  price_gt: Float
  price_gte: Float
  index: Int
  index_not: Int
  index_in: [Int!]
  index_not_in: [Int!]
  index_lt: Int
  index_lte: Int
  index_gt: Int
  index_gte: Int
  thumbnail: String
  thumbnail_not: String
  thumbnail_in: [String!]
  thumbnail_not_in: [String!]
  thumbnail_lt: String
  thumbnail_lte: String
  thumbnail_gt: String
  thumbnail_gte: String
  thumbnail_contains: String
  thumbnail_not_contains: String
  thumbnail_starts_with: String
  thumbnail_not_starts_with: String
  thumbnail_ends_with: String
  thumbnail_not_ends_with: String
  deleted: Boolean
  deleted_not: Boolean
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Purchase {
  id: ID!
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  transaction: Transaction!
  total: Float!
  user: User!
  date: DateTime!
}

type PurchaseConnection {
  pageInfo: PageInfo!
  edges: [PurchaseEdge]!
  aggregate: AggregatePurchase!
}

input PurchaseCreateInput {
  items: ItemCreateManyInput
  transaction: TransactionCreateOneWithoutPurchaseInput!
  total: Float!
  user: UserCreateOneWithoutPurchasesInput!
  date: DateTime!
}

input PurchaseCreateManyWithoutUserInput {
  create: [PurchaseCreateWithoutUserInput!]
  connect: [PurchaseWhereUniqueInput!]
}

input PurchaseCreateOneWithoutTransactionInput {
  create: PurchaseCreateWithoutTransactionInput
  connect: PurchaseWhereUniqueInput
}

input PurchaseCreateWithoutTransactionInput {
  items: ItemCreateManyInput
  total: Float!
  user: UserCreateOneWithoutPurchasesInput!
  date: DateTime!
}

input PurchaseCreateWithoutUserInput {
  items: ItemCreateManyInput
  transaction: TransactionCreateOneWithoutPurchaseInput!
  total: Float!
  date: DateTime!
}

type PurchaseEdge {
  node: Purchase!
  cursor: String!
}

enum PurchaseOrderByInput {
  id_ASC
  id_DESC
  total_ASC
  total_DESC
  date_ASC
  date_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PurchasePreviousValues {
  id: ID!
  total: Float!
  date: DateTime!
}

input PurchaseScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  total: Float
  total_not: Float
  total_in: [Float!]
  total_not_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_gt: Float
  total_gte: Float
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [PurchaseScalarWhereInput!]
  OR: [PurchaseScalarWhereInput!]
  NOT: [PurchaseScalarWhereInput!]
}

type PurchaseSubscriptionPayload {
  mutation: MutationType!
  node: Purchase
  updatedFields: [String!]
  previousValues: PurchasePreviousValues
}

input PurchaseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PurchaseWhereInput
  AND: [PurchaseSubscriptionWhereInput!]
  OR: [PurchaseSubscriptionWhereInput!]
  NOT: [PurchaseSubscriptionWhereInput!]
}

input PurchaseUpdateInput {
  items: ItemUpdateManyInput
  transaction: TransactionUpdateOneRequiredWithoutPurchaseInput
  total: Float
  user: UserUpdateOneRequiredWithoutPurchasesInput
  date: DateTime
}

input PurchaseUpdateManyDataInput {
  total: Float
  date: DateTime
}

input PurchaseUpdateManyMutationInput {
  total: Float
  date: DateTime
}

input PurchaseUpdateManyWithoutUserInput {
  create: [PurchaseCreateWithoutUserInput!]
  delete: [PurchaseWhereUniqueInput!]
  connect: [PurchaseWhereUniqueInput!]
  set: [PurchaseWhereUniqueInput!]
  disconnect: [PurchaseWhereUniqueInput!]
  update: [PurchaseUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [PurchaseUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [PurchaseScalarWhereInput!]
  updateMany: [PurchaseUpdateManyWithWhereNestedInput!]
}

input PurchaseUpdateManyWithWhereNestedInput {
  where: PurchaseScalarWhereInput!
  data: PurchaseUpdateManyDataInput!
}

input PurchaseUpdateOneWithoutTransactionInput {
  create: PurchaseCreateWithoutTransactionInput
  update: PurchaseUpdateWithoutTransactionDataInput
  upsert: PurchaseUpsertWithoutTransactionInput
  delete: Boolean
  disconnect: Boolean
  connect: PurchaseWhereUniqueInput
}

input PurchaseUpdateWithoutTransactionDataInput {
  items: ItemUpdateManyInput
  total: Float
  user: UserUpdateOneRequiredWithoutPurchasesInput
  date: DateTime
}

input PurchaseUpdateWithoutUserDataInput {
  items: ItemUpdateManyInput
  transaction: TransactionUpdateOneRequiredWithoutPurchaseInput
  total: Float
  date: DateTime
}

input PurchaseUpdateWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput!
  data: PurchaseUpdateWithoutUserDataInput!
}

input PurchaseUpsertWithoutTransactionInput {
  update: PurchaseUpdateWithoutTransactionDataInput!
  create: PurchaseCreateWithoutTransactionInput!
}

input PurchaseUpsertWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput!
  update: PurchaseUpdateWithoutUserDataInput!
  create: PurchaseCreateWithoutUserInput!
}

input PurchaseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  transaction: TransactionWhereInput
  total: Float
  total_not: Float
  total_in: [Float!]
  total_not_in: [Float!]
  total_lt: Float
  total_lte: Float
  total_gt: Float
  total_gte: Float
  user: UserWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  AND: [PurchaseWhereInput!]
  OR: [PurchaseWhereInput!]
  NOT: [PurchaseWhereInput!]
}

input PurchaseWhereUniqueInput {
  id: ID
}

type Query {
  client(where: ClientWhereUniqueInput!): Client
  clients(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Client]!
  clientsConnection(where: ClientWhereInput, orderBy: ClientOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ClientConnection!
  comment(where: CommentWhereUniqueInput!): Comment
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment]!
  commentsConnection(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CommentConnection!
  event(where: EventWhereUniqueInput!): Event
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event]!
  eventsConnection(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EventConnection!
  file(where: FileWhereUniqueInput!): File
  files(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [File]!
  filesConnection(where: FileWhereInput, orderBy: FileOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): FileConnection!
  item(where: ItemWhereUniqueInput!): Item
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item]!
  itemsConnection(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ItemConnection!
  payment(where: PaymentWhereUniqueInput!): Payment
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment]!
  paymentsConnection(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PaymentConnection!
  post(where: PostWhereUniqueInput!): Post
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post]!
  postsConnection(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PostConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  production(where: ProductionWhereUniqueInput!): Production
  productions(where: ProductionWhereInput, orderBy: ProductionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Production]!
  productionsConnection(where: ProductionWhereInput, orderBy: ProductionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductionConnection!
  purchase(where: PurchaseWhereUniqueInput!): Purchase
  purchases(where: PurchaseWhereInput, orderBy: PurchaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Purchase]!
  purchasesConnection(where: PurchaseWhereInput, orderBy: PurchaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PurchaseConnection!
  transaction(where: TransactionWhereUniqueInput!): Transaction
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction]!
  transactionsConnection(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TransactionConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  client(where: ClientSubscriptionWhereInput): ClientSubscriptionPayload
  comment(where: CommentSubscriptionWhereInput): CommentSubscriptionPayload
  event(where: EventSubscriptionWhereInput): EventSubscriptionPayload
  file(where: FileSubscriptionWhereInput): FileSubscriptionPayload
  item(where: ItemSubscriptionWhereInput): ItemSubscriptionPayload
  payment(where: PaymentSubscriptionWhereInput): PaymentSubscriptionPayload
  post(where: PostSubscriptionWhereInput): PostSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  production(where: ProductionSubscriptionWhereInput): ProductionSubscriptionPayload
  purchase(where: PurchaseSubscriptionWhereInput): PurchaseSubscriptionPayload
  transaction(where: TransactionSubscriptionWhereInput): TransactionSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Transaction {
  id: ID!
  user: User!
  date: DateTime!
  type: TransactionType!
  balance: Float!
  payment: Payment
  purchase: Purchase
}

type TransactionConnection {
  pageInfo: PageInfo!
  edges: [TransactionEdge]!
  aggregate: AggregateTransaction!
}

input TransactionCreateInput {
  user: UserCreateOneWithoutTransactionsInput!
  date: DateTime!
  type: TransactionType!
  balance: Float!
  payment: PaymentCreateOneWithoutTransactionInput
  purchase: PurchaseCreateOneWithoutTransactionInput
}

input TransactionCreateManyWithoutUserInput {
  create: [TransactionCreateWithoutUserInput!]
  connect: [TransactionWhereUniqueInput!]
}

input TransactionCreateOneWithoutPaymentInput {
  create: TransactionCreateWithoutPaymentInput
  connect: TransactionWhereUniqueInput
}

input TransactionCreateOneWithoutPurchaseInput {
  create: TransactionCreateWithoutPurchaseInput
  connect: TransactionWhereUniqueInput
}

input TransactionCreateWithoutPaymentInput {
  user: UserCreateOneWithoutTransactionsInput!
  date: DateTime!
  type: TransactionType!
  balance: Float!
  purchase: PurchaseCreateOneWithoutTransactionInput
}

input TransactionCreateWithoutPurchaseInput {
  user: UserCreateOneWithoutTransactionsInput!
  date: DateTime!
  type: TransactionType!
  balance: Float!
  payment: PaymentCreateOneWithoutTransactionInput
}

input TransactionCreateWithoutUserInput {
  date: DateTime!
  type: TransactionType!
  balance: Float!
  payment: PaymentCreateOneWithoutTransactionInput
  purchase: PurchaseCreateOneWithoutTransactionInput
}

type TransactionEdge {
  node: Transaction!
  cursor: String!
}

enum TransactionOrderByInput {
  id_ASC
  id_DESC
  date_ASC
  date_DESC
  type_ASC
  type_DESC
  balance_ASC
  balance_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TransactionPreviousValues {
  id: ID!
  date: DateTime!
  type: TransactionType!
  balance: Float!
}

input TransactionScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  type: TransactionType
  type_not: TransactionType
  type_in: [TransactionType!]
  type_not_in: [TransactionType!]
  balance: Float
  balance_not: Float
  balance_in: [Float!]
  balance_not_in: [Float!]
  balance_lt: Float
  balance_lte: Float
  balance_gt: Float
  balance_gte: Float
  AND: [TransactionScalarWhereInput!]
  OR: [TransactionScalarWhereInput!]
  NOT: [TransactionScalarWhereInput!]
}

type TransactionSubscriptionPayload {
  mutation: MutationType!
  node: Transaction
  updatedFields: [String!]
  previousValues: TransactionPreviousValues
}

input TransactionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TransactionWhereInput
  AND: [TransactionSubscriptionWhereInput!]
  OR: [TransactionSubscriptionWhereInput!]
  NOT: [TransactionSubscriptionWhereInput!]
}

enum TransactionType {
  PAYMENT
  PURCHASE
}

input TransactionUpdateInput {
  user: UserUpdateOneRequiredWithoutTransactionsInput
  date: DateTime
  type: TransactionType
  balance: Float
  payment: PaymentUpdateOneWithoutTransactionInput
  purchase: PurchaseUpdateOneWithoutTransactionInput
}

input TransactionUpdateManyDataInput {
  date: DateTime
  type: TransactionType
  balance: Float
}

input TransactionUpdateManyMutationInput {
  date: DateTime
  type: TransactionType
  balance: Float
}

input TransactionUpdateManyWithoutUserInput {
  create: [TransactionCreateWithoutUserInput!]
  delete: [TransactionWhereUniqueInput!]
  connect: [TransactionWhereUniqueInput!]
  set: [TransactionWhereUniqueInput!]
  disconnect: [TransactionWhereUniqueInput!]
  update: [TransactionUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [TransactionUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [TransactionScalarWhereInput!]
  updateMany: [TransactionUpdateManyWithWhereNestedInput!]
}

input TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput!
  data: TransactionUpdateManyDataInput!
}

input TransactionUpdateOneRequiredWithoutPaymentInput {
  create: TransactionCreateWithoutPaymentInput
  update: TransactionUpdateWithoutPaymentDataInput
  upsert: TransactionUpsertWithoutPaymentInput
  connect: TransactionWhereUniqueInput
}

input TransactionUpdateOneRequiredWithoutPurchaseInput {
  create: TransactionCreateWithoutPurchaseInput
  update: TransactionUpdateWithoutPurchaseDataInput
  upsert: TransactionUpsertWithoutPurchaseInput
  connect: TransactionWhereUniqueInput
}

input TransactionUpdateWithoutPaymentDataInput {
  user: UserUpdateOneRequiredWithoutTransactionsInput
  date: DateTime
  type: TransactionType
  balance: Float
  purchase: PurchaseUpdateOneWithoutTransactionInput
}

input TransactionUpdateWithoutPurchaseDataInput {
  user: UserUpdateOneRequiredWithoutTransactionsInput
  date: DateTime
  type: TransactionType
  balance: Float
  payment: PaymentUpdateOneWithoutTransactionInput
}

input TransactionUpdateWithoutUserDataInput {
  date: DateTime
  type: TransactionType
  balance: Float
  payment: PaymentUpdateOneWithoutTransactionInput
  purchase: PurchaseUpdateOneWithoutTransactionInput
}

input TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput!
  data: TransactionUpdateWithoutUserDataInput!
}

input TransactionUpsertWithoutPaymentInput {
  update: TransactionUpdateWithoutPaymentDataInput!
  create: TransactionCreateWithoutPaymentInput!
}

input TransactionUpsertWithoutPurchaseInput {
  update: TransactionUpdateWithoutPurchaseDataInput!
  create: TransactionCreateWithoutPurchaseInput!
}

input TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput!
  update: TransactionUpdateWithoutUserDataInput!
  create: TransactionCreateWithoutUserInput!
}

input TransactionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  date: DateTime
  date_not: DateTime
  date_in: [DateTime!]
  date_not_in: [DateTime!]
  date_lt: DateTime
  date_lte: DateTime
  date_gt: DateTime
  date_gte: DateTime
  type: TransactionType
  type_not: TransactionType
  type_in: [TransactionType!]
  type_not_in: [TransactionType!]
  balance: Float
  balance_not: Float
  balance_in: [Float!]
  balance_not_in: [Float!]
  balance_lt: Float
  balance_lte: Float
  balance_gt: Float
  balance_gte: Float
  payment: PaymentWhereInput
  purchase: PurchaseWhereInput
  AND: [TransactionWhereInput!]
  OR: [TransactionWhereInput!]
  NOT: [TransactionWhereInput!]
}

input TransactionWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases(where: PurchaseWhereInput, orderBy: PurchaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Purchase!]
  payments(where: PaymentWhereInput, orderBy: PaymentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Payment!]
  transactions(where: TransactionWhereInput, orderBy: TransactionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Transaction!]
  items(where: ItemWhereInput, orderBy: ItemOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Item!]
  role: UserRole!
  balance: Float!
  posts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  likedPosts(where: PostWhereInput, orderBy: PostOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Post!]
  likedEvents(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
  comments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  likedComments(where: CommentWhereInput, orderBy: CommentOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Comment!]
  events(where: EventWhereInput, orderBy: EventOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Event!]
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  events: EventCreateManyWithoutCommitteeInput
}

input UserCreateManyWithoutEventsInput {
  create: [UserCreateWithoutEventsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutLikedCommentsInput {
  create: [UserCreateWithoutLikedCommentsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutLikedEventsInput {
  create: [UserCreateWithoutLikedEventsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateManyWithoutLikedPostsInput {
  create: [UserCreateWithoutLikedPostsInput!]
  connect: [UserWhereUniqueInput!]
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutItemsInput {
  create: UserCreateWithoutItemsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPaymentsInput {
  create: UserCreateWithoutPaymentsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutPurchasesInput {
  create: UserCreateWithoutPurchasesInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutTransactionsInput {
  create: UserCreateWithoutTransactionsInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutCommentsInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  likedComments: CommentCreateManyWithoutLikedByInput
  events: EventCreateManyWithoutCommitteeInput
}

input UserCreateWithoutEventsInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
}

input UserCreateWithoutItemsInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  events: EventCreateManyWithoutCommitteeInput
}

input UserCreateWithoutLikedCommentsInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  events: EventCreateManyWithoutCommitteeInput
}

input UserCreateWithoutLikedEventsInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  events: EventCreateManyWithoutCommitteeInput
}

input UserCreateWithoutLikedPostsInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  events: EventCreateManyWithoutCommitteeInput
}

input UserCreateWithoutPaymentsInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  events: EventCreateManyWithoutCommitteeInput
}

input UserCreateWithoutPostsInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  events: EventCreateManyWithoutCommitteeInput
}

input UserCreateWithoutPurchasesInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  payments: PaymentCreateManyWithoutUserInput
  transactions: TransactionCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  events: EventCreateManyWithoutCommitteeInput
}

input UserCreateWithoutTransactionsInput {
  name: String!
  email: String!
  password: String!
  avatar: String
  purchases: PurchaseCreateManyWithoutUserInput
  payments: PaymentCreateManyWithoutUserInput
  items: ItemCreateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostCreateManyWithoutAuthorInput
  likedPosts: PostCreateManyWithoutLikedByInput
  likedEvents: EventCreateManyWithoutLikedByInput
  comments: CommentCreateManyWithoutAuthorInput
  likedComments: CommentCreateManyWithoutLikedByInput
  events: EventCreateManyWithoutCommitteeInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  avatar_ASC
  avatar_DESC
  role_ASC
  role_DESC
  balance_ASC
  balance_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  name: String!
  email: String!
  password: String!
  avatar: String
  role: UserRole!
  balance: Float!
}

enum UserRole {
  SUPER
  ADMIN
  MEMBER
}

input UserScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  balance: Float
  balance_not: Float
  balance_in: [Float!]
  balance_not_in: [Float!]
  balance_lt: Float
  balance_lte: Float
  balance_gt: Float
  balance_gte: Float
  AND: [UserScalarWhereInput!]
  OR: [UserScalarWhereInput!]
  NOT: [UserScalarWhereInput!]
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateManyDataInput {
  name: String
  email: String
  password: String
  avatar: String
  role: UserRole
  balance: Float
}

input UserUpdateManyMutationInput {
  name: String
  email: String
  password: String
  avatar: String
  role: UserRole
  balance: Float
}

input UserUpdateManyWithoutEventsInput {
  create: [UserCreateWithoutEventsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutEventsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutEventsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutLikedCommentsInput {
  create: [UserCreateWithoutLikedCommentsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutLikedCommentsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutLikedCommentsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutLikedEventsInput {
  create: [UserCreateWithoutLikedEventsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutLikedEventsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutLikedEventsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithoutLikedPostsInput {
  create: [UserCreateWithoutLikedPostsInput!]
  delete: [UserWhereUniqueInput!]
  connect: [UserWhereUniqueInput!]
  set: [UserWhereUniqueInput!]
  disconnect: [UserWhereUniqueInput!]
  update: [UserUpdateWithWhereUniqueWithoutLikedPostsInput!]
  upsert: [UserUpsertWithWhereUniqueWithoutLikedPostsInput!]
  deleteMany: [UserScalarWhereInput!]
  updateMany: [UserUpdateManyWithWhereNestedInput!]
}

input UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput!
  data: UserUpdateManyDataInput!
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutCommentsInput {
  create: UserCreateWithoutCommentsInput
  update: UserUpdateWithoutCommentsDataInput
  upsert: UserUpsertWithoutCommentsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutItemsInput {
  create: UserCreateWithoutItemsInput
  update: UserUpdateWithoutItemsDataInput
  upsert: UserUpsertWithoutItemsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPaymentsInput {
  create: UserCreateWithoutPaymentsInput
  update: UserUpdateWithoutPaymentsDataInput
  upsert: UserUpsertWithoutPaymentsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPostsInput {
  create: UserCreateWithoutPostsInput
  update: UserUpdateWithoutPostsDataInput
  upsert: UserUpsertWithoutPostsInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutPurchasesInput {
  create: UserCreateWithoutPurchasesInput
  update: UserUpdateWithoutPurchasesDataInput
  upsert: UserUpsertWithoutPurchasesInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutTransactionsInput {
  create: UserCreateWithoutTransactionsInput
  update: UserUpdateWithoutTransactionsDataInput
  upsert: UserUpsertWithoutTransactionsInput
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutCommentsDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateWithoutEventsDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
}

input UserUpdateWithoutItemsDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateWithoutLikedCommentsDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateWithoutLikedEventsDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateWithoutLikedPostsDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateWithoutPaymentsDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateWithoutPostsDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateWithoutPurchasesDataInput {
  name: String
  email: String
  password: String
  avatar: String
  payments: PaymentUpdateManyWithoutUserInput
  transactions: TransactionUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateWithoutTransactionsDataInput {
  name: String
  email: String
  password: String
  avatar: String
  purchases: PurchaseUpdateManyWithoutUserInput
  payments: PaymentUpdateManyWithoutUserInput
  items: ItemUpdateManyWithoutUserInput
  role: UserRole
  balance: Float
  posts: PostUpdateManyWithoutAuthorInput
  likedPosts: PostUpdateManyWithoutLikedByInput
  likedEvents: EventUpdateManyWithoutLikedByInput
  comments: CommentUpdateManyWithoutAuthorInput
  likedComments: CommentUpdateManyWithoutLikedByInput
  events: EventUpdateManyWithoutCommitteeInput
}

input UserUpdateWithWhereUniqueWithoutEventsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutEventsDataInput!
}

input UserUpdateWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutLikedCommentsDataInput!
}

input UserUpdateWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutLikedEventsDataInput!
}

input UserUpdateWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput!
  data: UserUpdateWithoutLikedPostsDataInput!
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput!
  create: UserCreateWithoutCommentsInput!
}

input UserUpsertWithoutItemsInput {
  update: UserUpdateWithoutItemsDataInput!
  create: UserCreateWithoutItemsInput!
}

input UserUpsertWithoutPaymentsInput {
  update: UserUpdateWithoutPaymentsDataInput!
  create: UserCreateWithoutPaymentsInput!
}

input UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput!
  create: UserCreateWithoutPostsInput!
}

input UserUpsertWithoutPurchasesInput {
  update: UserUpdateWithoutPurchasesDataInput!
  create: UserCreateWithoutPurchasesInput!
}

input UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput!
  create: UserCreateWithoutTransactionsInput!
}

input UserUpsertWithWhereUniqueWithoutEventsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutEventsDataInput!
  create: UserCreateWithoutEventsInput!
}

input UserUpsertWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutLikedCommentsDataInput!
  create: UserCreateWithoutLikedCommentsInput!
}

input UserUpsertWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutLikedEventsDataInput!
  create: UserCreateWithoutLikedEventsInput!
}

input UserUpsertWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput!
  update: UserUpdateWithoutLikedPostsDataInput!
  create: UserCreateWithoutLikedPostsInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  avatar: String
  avatar_not: String
  avatar_in: [String!]
  avatar_not_in: [String!]
  avatar_lt: String
  avatar_lte: String
  avatar_gt: String
  avatar_gte: String
  avatar_contains: String
  avatar_not_contains: String
  avatar_starts_with: String
  avatar_not_starts_with: String
  avatar_ends_with: String
  avatar_not_ends_with: String
  purchases_every: PurchaseWhereInput
  purchases_some: PurchaseWhereInput
  purchases_none: PurchaseWhereInput
  payments_every: PaymentWhereInput
  payments_some: PaymentWhereInput
  payments_none: PaymentWhereInput
  transactions_every: TransactionWhereInput
  transactions_some: TransactionWhereInput
  transactions_none: TransactionWhereInput
  items_every: ItemWhereInput
  items_some: ItemWhereInput
  items_none: ItemWhereInput
  role: UserRole
  role_not: UserRole
  role_in: [UserRole!]
  role_not_in: [UserRole!]
  balance: Float
  balance_not: Float
  balance_in: [Float!]
  balance_not_in: [Float!]
  balance_lt: Float
  balance_lte: Float
  balance_gt: Float
  balance_gte: Float
  posts_every: PostWhereInput
  posts_some: PostWhereInput
  posts_none: PostWhereInput
  likedPosts_every: PostWhereInput
  likedPosts_some: PostWhereInput
  likedPosts_none: PostWhereInput
  likedEvents_every: EventWhereInput
  likedEvents_some: EventWhereInput
  likedEvents_none: EventWhereInput
  comments_every: CommentWhereInput
  comments_some: CommentWhereInput
  comments_none: CommentWhereInput
  likedComments_every: CommentWhereInput
  likedComments_some: CommentWhereInput
  likedComments_none: CommentWhereInput
  events_every: EventWhereInput
  events_some: EventWhereInput
  events_none: EventWhereInput
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    