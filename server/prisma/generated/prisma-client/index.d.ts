// Code generated by Prisma (prisma@1.27.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  client: (where?: ClientWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  committee: (where?: CommitteeWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  invitation: (where?: InvitationWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  production: (where?: ProductionWhereInput) => Promise<boolean>;
  purchase: (where?: PurchaseWhereInput) => Promise<boolean>;
  question: (where?: QuestionWhereInput) => Promise<boolean>;
  todo: (where?: TodoWhereInput) => Promise<boolean>;
  todoTemplate: (where?: TodoTemplateWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  client: (where: ClientWhereUniqueInput) => ClientPromise;
  clients: (
    args?: {
      where?: ClientWhereInput;
      orderBy?: ClientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Client>;
  clientsConnection: (
    args?: {
      where?: ClientWhereInput;
      orderBy?: ClientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ClientConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentPromise;
  comments: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Comment>;
  commentsConnection: (
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommentConnectionPromise;
  committee: (where: CommitteeWhereUniqueInput) => CommitteePromise;
  committees: (
    args?: {
      where?: CommitteeWhereInput;
      orderBy?: CommitteeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Committee>;
  committeesConnection: (
    args?: {
      where?: CommitteeWhereInput;
      orderBy?: CommitteeOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => CommitteeConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventPromise;
  events: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Event>;
  eventsConnection: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EventConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<File>;
  filesConnection: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FileConnectionPromise;
  invitation: (where: InvitationWhereUniqueInput) => InvitationPromise;
  invitations: (
    args?: {
      where?: InvitationWhereInput;
      orderBy?: InvitationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Invitation>;
  invitationsConnection: (
    args?: {
      where?: InvitationWhereInput;
      orderBy?: InvitationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => InvitationConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemPromise;
  items: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Item>;
  itemsConnection: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ItemConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  payments: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Payment>;
  paymentsConnection: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaymentConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostPromise;
  posts: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Post>;
  postsConnection: (
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PostConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  production: (where: ProductionWhereUniqueInput) => ProductionPromise;
  productions: (
    args?: {
      where?: ProductionWhereInput;
      orderBy?: ProductionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Production>;
  productionsConnection: (
    args?: {
      where?: ProductionWhereInput;
      orderBy?: ProductionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductionConnectionPromise;
  purchase: (where: PurchaseWhereUniqueInput) => PurchasePromise;
  purchases: (
    args?: {
      where?: PurchaseWhereInput;
      orderBy?: PurchaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Purchase>;
  purchasesConnection: (
    args?: {
      where?: PurchaseWhereInput;
      orderBy?: PurchaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PurchaseConnectionPromise;
  question: (where: QuestionWhereUniqueInput) => QuestionPromise;
  questions: (
    args?: {
      where?: QuestionWhereInput;
      orderBy?: QuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Question>;
  questionsConnection: (
    args?: {
      where?: QuestionWhereInput;
      orderBy?: QuestionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => QuestionConnectionPromise;
  todo: (where: TodoWhereUniqueInput) => TodoPromise;
  todoes: (
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Todo>;
  todoesConnection: (
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TodoConnectionPromise;
  todoTemplate: (where: TodoTemplateWhereUniqueInput) => TodoTemplatePromise;
  todoTemplates: (
    args?: {
      where?: TodoTemplateWhereInput;
      orderBy?: TodoTemplateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<TodoTemplate>;
  todoTemplatesConnection: (
    args?: {
      where?: TodoTemplateWhereInput;
      orderBy?: TodoTemplateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TodoTemplateConnectionPromise;
  transaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  transactions: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Transaction>;
  transactionsConnection: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createClient: (data: ClientCreateInput) => ClientPromise;
  updateClient: (
    args: { data: ClientUpdateInput; where: ClientWhereUniqueInput }
  ) => ClientPromise;
  updateManyClients: (
    args: { data: ClientUpdateManyMutationInput; where?: ClientWhereInput }
  ) => BatchPayloadPromise;
  upsertClient: (
    args: {
      where: ClientWhereUniqueInput;
      create: ClientCreateInput;
      update: ClientUpdateInput;
    }
  ) => ClientPromise;
  deleteClient: (where: ClientWhereUniqueInput) => ClientPromise;
  deleteManyClients: (where?: ClientWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (
    args: { data: CommentUpdateInput; where: CommentWhereUniqueInput }
  ) => CommentPromise;
  updateManyComments: (
    args: { data: CommentUpdateManyMutationInput; where?: CommentWhereInput }
  ) => BatchPayloadPromise;
  upsertComment: (
    args: {
      where: CommentWhereUniqueInput;
      create: CommentCreateInput;
      update: CommentUpdateInput;
    }
  ) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createCommittee: (data: CommitteeCreateInput) => CommitteePromise;
  updateCommittee: (
    args: { data: CommitteeUpdateInput; where: CommitteeWhereUniqueInput }
  ) => CommitteePromise;
  upsertCommittee: (
    args: {
      where: CommitteeWhereUniqueInput;
      create: CommitteeCreateInput;
      update: CommitteeUpdateInput;
    }
  ) => CommitteePromise;
  deleteCommittee: (where: CommitteeWhereUniqueInput) => CommitteePromise;
  deleteManyCommittees: (where?: CommitteeWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (
    args: { data: EventUpdateInput; where: EventWhereUniqueInput }
  ) => EventPromise;
  updateManyEvents: (
    args: { data: EventUpdateManyMutationInput; where?: EventWhereInput }
  ) => BatchPayloadPromise;
  upsertEvent: (
    args: {
      where: EventWhereUniqueInput;
      create: EventCreateInput;
      update: EventUpdateInput;
    }
  ) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (
    args: { data: FileUpdateInput; where: FileWhereUniqueInput }
  ) => FilePromise;
  updateManyFiles: (
    args: { data: FileUpdateManyMutationInput; where?: FileWhereInput }
  ) => BatchPayloadPromise;
  upsertFile: (
    args: {
      where: FileWhereUniqueInput;
      create: FileCreateInput;
      update: FileUpdateInput;
    }
  ) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createInvitation: (data: InvitationCreateInput) => InvitationPromise;
  updateInvitation: (
    args: { data: InvitationUpdateInput; where: InvitationWhereUniqueInput }
  ) => InvitationPromise;
  updateManyInvitations: (
    args: {
      data: InvitationUpdateManyMutationInput;
      where?: InvitationWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertInvitation: (
    args: {
      where: InvitationWhereUniqueInput;
      create: InvitationCreateInput;
      update: InvitationUpdateInput;
    }
  ) => InvitationPromise;
  deleteInvitation: (where: InvitationWhereUniqueInput) => InvitationPromise;
  deleteManyInvitations: (where?: InvitationWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (
    args: { data: ItemUpdateInput; where: ItemWhereUniqueInput }
  ) => ItemPromise;
  updateManyItems: (
    args: { data: ItemUpdateManyMutationInput; where?: ItemWhereInput }
  ) => BatchPayloadPromise;
  upsertItem: (
    args: {
      where: ItemWhereUniqueInput;
      create: ItemCreateInput;
      update: ItemUpdateInput;
    }
  ) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (
    args: { data: PaymentUpdateInput; where: PaymentWhereUniqueInput }
  ) => PaymentPromise;
  updateManyPayments: (
    args: { data: PaymentUpdateManyMutationInput; where?: PaymentWhereInput }
  ) => BatchPayloadPromise;
  upsertPayment: (
    args: {
      where: PaymentWhereUniqueInput;
      create: PaymentCreateInput;
      update: PaymentUpdateInput;
    }
  ) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (
    args: { data: PostUpdateInput; where: PostWhereUniqueInput }
  ) => PostPromise;
  updateManyPosts: (
    args: { data: PostUpdateManyMutationInput; where?: PostWhereInput }
  ) => BatchPayloadPromise;
  upsertPost: (
    args: {
      where: PostWhereUniqueInput;
      create: PostCreateInput;
      update: PostUpdateInput;
    }
  ) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProduction: (data: ProductionCreateInput) => ProductionPromise;
  updateProduction: (
    args: { data: ProductionUpdateInput; where: ProductionWhereUniqueInput }
  ) => ProductionPromise;
  updateManyProductions: (
    args: {
      data: ProductionUpdateManyMutationInput;
      where?: ProductionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertProduction: (
    args: {
      where: ProductionWhereUniqueInput;
      create: ProductionCreateInput;
      update: ProductionUpdateInput;
    }
  ) => ProductionPromise;
  deleteProduction: (where: ProductionWhereUniqueInput) => ProductionPromise;
  deleteManyProductions: (where?: ProductionWhereInput) => BatchPayloadPromise;
  createPurchase: (data: PurchaseCreateInput) => PurchasePromise;
  updatePurchase: (
    args: { data: PurchaseUpdateInput; where: PurchaseWhereUniqueInput }
  ) => PurchasePromise;
  updateManyPurchases: (
    args: { data: PurchaseUpdateManyMutationInput; where?: PurchaseWhereInput }
  ) => BatchPayloadPromise;
  upsertPurchase: (
    args: {
      where: PurchaseWhereUniqueInput;
      create: PurchaseCreateInput;
      update: PurchaseUpdateInput;
    }
  ) => PurchasePromise;
  deletePurchase: (where: PurchaseWhereUniqueInput) => PurchasePromise;
  deleteManyPurchases: (where?: PurchaseWhereInput) => BatchPayloadPromise;
  createQuestion: (data: QuestionCreateInput) => QuestionPromise;
  updateQuestion: (
    args: { data: QuestionUpdateInput; where: QuestionWhereUniqueInput }
  ) => QuestionPromise;
  updateManyQuestions: (
    args: { data: QuestionUpdateManyMutationInput; where?: QuestionWhereInput }
  ) => BatchPayloadPromise;
  upsertQuestion: (
    args: {
      where: QuestionWhereUniqueInput;
      create: QuestionCreateInput;
      update: QuestionUpdateInput;
    }
  ) => QuestionPromise;
  deleteQuestion: (where: QuestionWhereUniqueInput) => QuestionPromise;
  deleteManyQuestions: (where?: QuestionWhereInput) => BatchPayloadPromise;
  createTodo: (data: TodoCreateInput) => TodoPromise;
  updateTodo: (
    args: { data: TodoUpdateInput; where: TodoWhereUniqueInput }
  ) => TodoPromise;
  updateManyTodoes: (
    args: { data: TodoUpdateManyMutationInput; where?: TodoWhereInput }
  ) => BatchPayloadPromise;
  upsertTodo: (
    args: {
      where: TodoWhereUniqueInput;
      create: TodoCreateInput;
      update: TodoUpdateInput;
    }
  ) => TodoPromise;
  deleteTodo: (where: TodoWhereUniqueInput) => TodoPromise;
  deleteManyTodoes: (where?: TodoWhereInput) => BatchPayloadPromise;
  createTodoTemplate: (data: TodoTemplateCreateInput) => TodoTemplatePromise;
  updateTodoTemplate: (
    args: { data: TodoTemplateUpdateInput; where: TodoTemplateWhereUniqueInput }
  ) => TodoTemplatePromise;
  updateManyTodoTemplates: (
    args: {
      data: TodoTemplateUpdateManyMutationInput;
      where?: TodoTemplateWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTodoTemplate: (
    args: {
      where: TodoTemplateWhereUniqueInput;
      create: TodoTemplateCreateInput;
      update: TodoTemplateUpdateInput;
    }
  ) => TodoTemplatePromise;
  deleteTodoTemplate: (
    where: TodoTemplateWhereUniqueInput
  ) => TodoTemplatePromise;
  deleteManyTodoTemplates: (
    where?: TodoTemplateWhereInput
  ) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (
    args: { data: TransactionUpdateInput; where: TransactionWhereUniqueInput }
  ) => TransactionPromise;
  updateManyTransactions: (
    args: {
      data: TransactionUpdateManyMutationInput;
      where?: TransactionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTransaction: (
    args: {
      where: TransactionWhereUniqueInput;
      create: TransactionCreateInput;
      update: TransactionUpdateInput;
    }
  ) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  client: (
    where?: ClientSubscriptionWhereInput
  ) => ClientSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  committee: (
    where?: CommitteeSubscriptionWhereInput
  ) => CommitteeSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  invitation: (
    where?: InvitationSubscriptionWhereInput
  ) => InvitationSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  production: (
    where?: ProductionSubscriptionWhereInput
  ) => ProductionSubscriptionPayloadSubscription;
  purchase: (
    where?: PurchaseSubscriptionWhereInput
  ) => PurchaseSubscriptionPayloadSubscription;
  question: (
    where?: QuestionSubscriptionWhereInput
  ) => QuestionSubscriptionPayloadSubscription;
  todo: (
    where?: TodoSubscriptionWhereInput
  ) => TodoSubscriptionPayloadSubscription;
  todoTemplate: (
    where?: TodoTemplateSubscriptionWhereInput
  ) => TodoTemplateSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ClientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "identity_ASC"
  | "identity_DESC"
  | "secret_ASC"
  | "secret_DESC"
  | "name_ASC"
  | "name_DESC"
  | "trusted_ASC"
  | "trusted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransactionType = "PAYMENT" | "PURCHASE";

export type UserRole = "SUPER" | "ADMIN" | "MEMBER";

export type InvitationStatus = "PENDING" | "ACCEPTED" | "DECLINED";

export type PurchaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_ASC"
  | "total_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "date_ASC"
  | "date_DESC"
  | "verified_ASC"
  | "verified_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "type_ASC"
  | "type_DESC"
  | "balance_ASC"
  | "balance_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "image_ASC"
  | "image_DESC"
  | "link_ASC"
  | "link_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "role_ASC"
  | "role_DESC"
  | "balance_ASC"
  | "balance_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "date_ASC"
  | "date_DESC"
  | "image_ASC"
  | "image_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type InvitationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TodoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "due_ASC"
  | "due_DESC"
  | "text_ASC"
  | "text_DESC"
  | "done_ASC"
  | "done_DESC"
  | "link_ASC"
  | "link_DESC"
  | "doneAt_ASC"
  | "doneAt_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type CommitteeOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fileId_ASC"
  | "fileId_DESC"
  | "hash_ASC"
  | "hash_DESC"
  | "uri_ASC"
  | "uri_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "path_ASC"
  | "path_DESC"
  | "mimetype_ASC"
  | "mimetype_DESC"
  | "extension_ASC"
  | "extension_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "index_ASC"
  | "index_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC"
  | "deleted_ASC"
  | "deleted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "index_ASC"
  | "index_DESC"
  | "show_ASC"
  | "show_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TodoTemplateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "offsetDays_ASC"
  | "offsetDays_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type QuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "description_ASC"
  | "description_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ClientWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  identity?: String;
}>;

export interface ClientWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  identity?: String;
  identity_not?: String;
  identity_in?: String[] | String;
  identity_not_in?: String[] | String;
  identity_lt?: String;
  identity_lte?: String;
  identity_gt?: String;
  identity_gte?: String;
  identity_contains?: String;
  identity_not_contains?: String;
  identity_starts_with?: String;
  identity_not_starts_with?: String;
  identity_ends_with?: String;
  identity_not_ends_with?: String;
  secret?: String;
  secret_not?: String;
  secret_in?: String[] | String;
  secret_not_in?: String[] | String;
  secret_lt?: String;
  secret_lte?: String;
  secret_gt?: String;
  secret_gte?: String;
  secret_contains?: String;
  secret_not_contains?: String;
  secret_starts_with?: String;
  secret_not_starts_with?: String;
  secret_ends_with?: String;
  secret_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  trusted?: Boolean;
  trusted_not?: Boolean;
  AND?: ClientWhereInput[] | ClientWhereInput;
  OR?: ClientWhereInput[] | ClientWhereInput;
  NOT?: ClientWhereInput[] | ClientWhereInput;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PurchaseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  transaction?: TransactionWhereInput;
  total?: Float;
  total_not?: Float;
  total_in?: Float[] | Float;
  total_not_in?: Float[] | Float;
  total_lt?: Float;
  total_lte?: Float;
  total_gt?: Float;
  total_gte?: Float;
  user?: UserWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: PurchaseWhereInput[] | PurchaseWhereInput;
  OR?: PurchaseWhereInput[] | PurchaseWhereInput;
  NOT?: PurchaseWhereInput[] | PurchaseWhereInput;
}

export interface ItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  product?: ProductWhereInput;
  user?: UserWhereInput;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  AND?: ItemWhereInput[] | ItemWhereInput;
  OR?: ItemWhereInput[] | ItemWhereInput;
  NOT?: ItemWhereInput[] | ItemWhereInput;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  index?: Int;
  index_not?: Int;
  index_in?: Int[] | Int;
  index_not_in?: Int[] | Int;
  index_lt?: Int;
  index_lte?: Int;
  index_gt?: Int;
  index_gte?: Int;
  thumbnail?: String;
  thumbnail_not?: String;
  thumbnail_in?: String[] | String;
  thumbnail_not_in?: String[] | String;
  thumbnail_lt?: String;
  thumbnail_lte?: String;
  thumbnail_gt?: String;
  thumbnail_gte?: String;
  thumbnail_contains?: String;
  thumbnail_not_contains?: String;
  thumbnail_starts_with?: String;
  thumbnail_not_starts_with?: String;
  thumbnail_ends_with?: String;
  thumbnail_not_ends_with?: String;
  deleted?: Boolean;
  deleted_not?: Boolean;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  purchases_every?: PurchaseWhereInput;
  purchases_some?: PurchaseWhereInput;
  purchases_none?: PurchaseWhereInput;
  payments_every?: PaymentWhereInput;
  payments_some?: PaymentWhereInput;
  payments_none?: PaymentWhereInput;
  transactions_every?: TransactionWhereInput;
  transactions_some?: TransactionWhereInput;
  transactions_none?: TransactionWhereInput;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  balance?: Float;
  balance_not?: Float;
  balance_in?: Float[] | Float;
  balance_not_in?: Float[] | Float;
  balance_lt?: Float;
  balance_lte?: Float;
  balance_gt?: Float;
  balance_gte?: Float;
  posts_every?: PostWhereInput;
  posts_some?: PostWhereInput;
  posts_none?: PostWhereInput;
  likedPosts_every?: PostWhereInput;
  likedPosts_some?: PostWhereInput;
  likedPosts_none?: PostWhereInput;
  likedEvents_every?: EventWhereInput;
  likedEvents_some?: EventWhereInput;
  likedEvents_none?: EventWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  likedComments_every?: CommentWhereInput;
  likedComments_some?: CommentWhereInput;
  likedComments_none?: CommentWhereInput;
  invitations_every?: InvitationWhereInput;
  invitations_some?: InvitationWhereInput;
  invitations_none?: InvitationWhereInput;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface PaymentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  user?: UserWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  verified?: Boolean;
  verified_not?: Boolean;
  transaction?: TransactionWhereInput;
  AND?: PaymentWhereInput[] | PaymentWhereInput;
  OR?: PaymentWhereInput[] | PaymentWhereInput;
  NOT?: PaymentWhereInput[] | PaymentWhereInput;
}

export interface TransactionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  balance?: Float;
  balance_not?: Float;
  balance_in?: Float[] | Float;
  balance_not_in?: Float[] | Float;
  balance_lt?: Float;
  balance_lte?: Float;
  balance_gt?: Float;
  balance_gte?: Float;
  payment?: PaymentWhereInput;
  purchase?: PurchaseWhereInput;
  AND?: TransactionWhereInput[] | TransactionWhereInput;
  OR?: TransactionWhereInput[] | TransactionWhereInput;
  NOT?: TransactionWhereInput[] | TransactionWhereInput;
}

export interface PostWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  author?: UserWhereInput;
  likedBy_every?: UserWhereInput;
  likedBy_some?: UserWhereInput;
  likedBy_none?: UserWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: PostWhereInput[] | PostWhereInput;
  OR?: PostWhereInput[] | PostWhereInput;
  NOT?: PostWhereInput[] | PostWhereInput;
}

export interface CommentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  author?: UserWhereInput;
  likedBy_every?: UserWhereInput;
  likedBy_some?: UserWhereInput;
  likedBy_none?: UserWhereInput;
  post?: PostWhereInput;
  event?: EventWhereInput;
  AND?: CommentWhereInput[] | CommentWhereInput;
  OR?: CommentWhereInput[] | CommentWhereInput;
  NOT?: CommentWhereInput[] | CommentWhereInput;
}

export interface EventWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  supporters_every?: UserWhereInput;
  supporters_some?: UserWhereInput;
  supporters_none?: UserWhereInput;
  likedBy_every?: UserWhereInput;
  likedBy_some?: UserWhereInput;
  likedBy_none?: UserWhereInput;
  owner?: UserWhereInput;
  comments_every?: CommentWhereInput;
  comments_some?: CommentWhereInput;
  comments_none?: CommentWhereInput;
  committee?: CommitteeWhereInput;
  todos_every?: TodoWhereInput;
  todos_some?: TodoWhereInput;
  todos_none?: TodoWhereInput;
  AND?: EventWhereInput[] | EventWhereInput;
  OR?: EventWhereInput[] | EventWhereInput;
  NOT?: EventWhereInput[] | EventWhereInput;
}

export interface CommitteeWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  creator?: UserWhereInput;
  members_every?: UserWhereInput;
  members_some?: UserWhereInput;
  members_none?: UserWhereInput;
  event?: EventWhereInput;
  invitations_every?: InvitationWhereInput;
  invitations_some?: InvitationWhereInput;
  invitations_none?: InvitationWhereInput;
  AND?: CommitteeWhereInput[] | CommitteeWhereInput;
  OR?: CommitteeWhereInput[] | CommitteeWhereInput;
  NOT?: CommitteeWhereInput[] | CommitteeWhereInput;
}

export interface InvitationWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  committee?: CommitteeWhereInput;
  status?: InvitationStatus;
  status_not?: InvitationStatus;
  status_in?: InvitationStatus[] | InvitationStatus;
  status_not_in?: InvitationStatus[] | InvitationStatus;
  AND?: InvitationWhereInput[] | InvitationWhereInput;
  OR?: InvitationWhereInput[] | InvitationWhereInput;
  NOT?: InvitationWhereInput[] | InvitationWhereInput;
}

export interface TodoWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  due?: DateTimeInput;
  due_not?: DateTimeInput;
  due_in?: DateTimeInput[] | DateTimeInput;
  due_not_in?: DateTimeInput[] | DateTimeInput;
  due_lt?: DateTimeInput;
  due_lte?: DateTimeInput;
  due_gt?: DateTimeInput;
  due_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  done?: Boolean;
  done_not?: Boolean;
  assigned?: UserWhereInput;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  doneBy?: UserWhereInput;
  doneAt?: DateTimeInput;
  doneAt_not?: DateTimeInput;
  doneAt_in?: DateTimeInput[] | DateTimeInput;
  doneAt_not_in?: DateTimeInput[] | DateTimeInput;
  doneAt_lt?: DateTimeInput;
  doneAt_lte?: DateTimeInput;
  doneAt_gt?: DateTimeInput;
  doneAt_gte?: DateTimeInput;
  event?: EventWhereInput;
  AND?: TodoWhereInput[] | TodoWhereInput;
  OR?: TodoWhereInput[] | TodoWhereInput;
  NOT?: TodoWhereInput[] | TodoWhereInput;
}

export type CommitteeWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type EventWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  fileId?: String;
  hash?: String;
  uri?: String;
}>;

export interface FileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  fileId?: String;
  fileId_not?: String;
  fileId_in?: String[] | String;
  fileId_not_in?: String[] | String;
  fileId_lt?: String;
  fileId_lte?: String;
  fileId_gt?: String;
  fileId_gte?: String;
  fileId_contains?: String;
  fileId_not_contains?: String;
  fileId_starts_with?: String;
  fileId_not_starts_with?: String;
  fileId_ends_with?: String;
  fileId_not_ends_with?: String;
  hash?: String;
  hash_not?: String;
  hash_in?: String[] | String;
  hash_not_in?: String[] | String;
  hash_lt?: String;
  hash_lte?: String;
  hash_gt?: String;
  hash_gte?: String;
  hash_contains?: String;
  hash_not_contains?: String;
  hash_starts_with?: String;
  hash_not_starts_with?: String;
  hash_ends_with?: String;
  hash_not_ends_with?: String;
  uri?: String;
  uri_not?: String;
  uri_in?: String[] | String;
  uri_not_in?: String[] | String;
  uri_lt?: String;
  uri_lte?: String;
  uri_gt?: String;
  uri_gte?: String;
  uri_contains?: String;
  uri_not_contains?: String;
  uri_starts_with?: String;
  uri_not_starts_with?: String;
  uri_ends_with?: String;
  uri_not_ends_with?: String;
  filename?: String;
  filename_not?: String;
  filename_in?: String[] | String;
  filename_not_in?: String[] | String;
  filename_lt?: String;
  filename_lte?: String;
  filename_gt?: String;
  filename_gte?: String;
  filename_contains?: String;
  filename_not_contains?: String;
  filename_starts_with?: String;
  filename_not_starts_with?: String;
  filename_ends_with?: String;
  filename_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  mimetype?: String;
  mimetype_not?: String;
  mimetype_in?: String[] | String;
  mimetype_not_in?: String[] | String;
  mimetype_lt?: String;
  mimetype_lte?: String;
  mimetype_gt?: String;
  mimetype_gte?: String;
  mimetype_contains?: String;
  mimetype_not_contains?: String;
  mimetype_starts_with?: String;
  mimetype_not_starts_with?: String;
  mimetype_ends_with?: String;
  mimetype_not_ends_with?: String;
  extension?: String;
  extension_not?: String;
  extension_in?: String[] | String;
  extension_not_in?: String[] | String;
  extension_lt?: String;
  extension_lte?: String;
  extension_gt?: String;
  extension_gte?: String;
  extension_contains?: String;
  extension_not_contains?: String;
  extension_starts_with?: String;
  extension_not_starts_with?: String;
  extension_ends_with?: String;
  extension_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: FileWhereInput[] | FileWhereInput;
  OR?: FileWhereInput[] | FileWhereInput;
  NOT?: FileWhereInput[] | FileWhereInput;
}

export type InvitationWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type PostWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type ProductionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ProductionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  index?: Int;
  index_not?: Int;
  index_in?: Int[] | Int;
  index_not_in?: Int[] | Int;
  index_lt?: Int;
  index_lte?: Int;
  index_gt?: Int;
  index_gte?: Int;
  show?: Boolean;
  show_not?: Boolean;
  AND?: ProductionWhereInput[] | ProductionWhereInput;
  OR?: ProductionWhereInput[] | ProductionWhereInput;
  NOT?: ProductionWhereInput[] | ProductionWhereInput;
}

export type PurchaseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type QuestionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TodoTemplateWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  offsetDays?: Int;
  offsetDays_not?: Int;
  offsetDays_in?: Int[] | Int;
  offsetDays_not_in?: Int[] | Int;
  offsetDays_lt?: Int;
  offsetDays_lte?: Int;
  offsetDays_gt?: Int;
  offsetDays_gte?: Int;
  AND?: TodoTemplateWhereInput[] | TodoTemplateWhereInput;
  OR?: TodoTemplateWhereInput[] | TodoTemplateWhereInput;
  NOT?: TodoTemplateWhereInput[] | TodoTemplateWhereInput;
}

export interface QuestionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  templates_every?: TodoTemplateWhereInput;
  templates_some?: TodoTemplateWhereInput;
  templates_none?: TodoTemplateWhereInput;
  AND?: QuestionWhereInput[] | QuestionWhereInput;
  OR?: QuestionWhereInput[] | QuestionWhereInput;
  NOT?: QuestionWhereInput[] | QuestionWhereInput;
}

export type TodoWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TodoTemplateWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface ClientCreateInput {
  identity: String;
  secret: String;
  name: String;
  trusted?: Boolean;
}

export interface ClientUpdateInput {
  identity?: String;
  secret?: String;
  name?: String;
  trusted?: Boolean;
}

export interface ClientUpdateManyMutationInput {
  identity?: String;
  secret?: String;
  name?: String;
  trusted?: Boolean;
}

export interface CommentCreateInput {
  text: String;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  likedBy?: UserCreateManyWithoutLikedCommentsInput;
  post?: PostCreateOneWithoutCommentsInput;
  event?: EventCreateOneWithoutCommentsInput;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutCommentsInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface PurchaseCreateManyWithoutUserInput {
  create?: PurchaseCreateWithoutUserInput[] | PurchaseCreateWithoutUserInput;
  connect?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
}

export interface PurchaseCreateWithoutUserInput {
  items?: ItemCreateManyInput;
  transaction: TransactionCreateOneWithoutPurchaseInput;
  total: Float;
  date: DateTimeInput;
}

export interface ItemCreateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface ItemCreateInput {
  product: ProductCreateOneInput;
  user: UserCreateOneWithoutItemsInput;
  price: Float;
  amount: Int;
}

export interface ProductCreateOneInput {
  create?: ProductCreateInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductCreateInput {
  name: String;
  price: Float;
  index: Int;
  thumbnail?: String;
  deleted?: Boolean;
}

export interface UserCreateOneWithoutItemsInput {
  create?: UserCreateWithoutItemsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutItemsInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface PaymentCreateManyWithoutUserInput {
  create?: PaymentCreateWithoutUserInput[] | PaymentCreateWithoutUserInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
}

export interface PaymentCreateWithoutUserInput {
  amount: Float;
  date: DateTimeInput;
  verified?: Boolean;
  transaction: TransactionCreateOneWithoutPaymentInput;
}

export interface TransactionCreateOneWithoutPaymentInput {
  create?: TransactionCreateWithoutPaymentInput;
  connect?: TransactionWhereUniqueInput;
}

export interface TransactionCreateWithoutPaymentInput {
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  purchase?: PurchaseCreateOneWithoutTransactionInput;
}

export interface UserCreateOneWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutTransactionsInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface ItemCreateManyWithoutUserInput {
  create?: ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface ItemCreateWithoutUserInput {
  product: ProductCreateOneInput;
  price: Float;
  amount: Int;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface PostCreateWithoutAuthorInput {
  text: String;
  image?: String;
  link?: String;
  likedBy?: UserCreateManyWithoutLikedPostsInput;
  comments?: CommentCreateManyWithoutPostInput;
  date: DateTimeInput;
}

export interface UserCreateManyWithoutLikedPostsInput {
  create?:
    | UserCreateWithoutLikedPostsInput[]
    | UserCreateWithoutLikedPostsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutLikedPostsInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface TransactionCreateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
}

export interface TransactionCreateWithoutUserInput {
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  payment?: PaymentCreateOneWithoutTransactionInput;
  purchase?: PurchaseCreateOneWithoutTransactionInput;
}

export interface PaymentCreateOneWithoutTransactionInput {
  create?: PaymentCreateWithoutTransactionInput;
  connect?: PaymentWhereUniqueInput;
}

export interface PaymentCreateWithoutTransactionInput {
  amount: Float;
  user: UserCreateOneWithoutPaymentsInput;
  date: DateTimeInput;
  verified?: Boolean;
}

export interface UserCreateOneWithoutPaymentsInput {
  create?: UserCreateWithoutPaymentsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutPaymentsInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface PostCreateManyWithoutLikedByInput {
  create?: PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
}

export interface PostCreateWithoutLikedByInput {
  text: String;
  image?: String;
  link?: String;
  author: UserCreateOneWithoutPostsInput;
  comments?: CommentCreateManyWithoutPostInput;
  date: DateTimeInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutPostsInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface EventCreateManyWithoutLikedByInput {
  create?: EventCreateWithoutLikedByInput[] | EventCreateWithoutLikedByInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
}

export interface EventCreateWithoutLikedByInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: UserCreateManyInput;
  owner: UserCreateOneInput;
  comments?: CommentCreateManyWithoutEventInput;
  committee: CommitteeCreateOneWithoutEventInput;
  todos?: TodoCreateManyWithoutEventInput;
}

export interface UserCreateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface CommentCreateManyWithoutAuthorInput {
  create?: CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentCreateWithoutAuthorInput {
  text: String;
  date: DateTimeInput;
  likedBy?: UserCreateManyWithoutLikedCommentsInput;
  post?: PostCreateOneWithoutCommentsInput;
  event?: EventCreateOneWithoutCommentsInput;
}

export interface UserCreateManyWithoutLikedCommentsInput {
  create?:
    | UserCreateWithoutLikedCommentsInput[]
    | UserCreateWithoutLikedCommentsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutLikedCommentsInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface InvitationCreateManyWithoutUserInput {
  create?:
    | InvitationCreateWithoutUserInput[]
    | InvitationCreateWithoutUserInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
}

export interface InvitationCreateWithoutUserInput {
  committee: CommitteeCreateOneWithoutInvitationsInput;
  status?: InvitationStatus;
}

export interface CommitteeCreateOneWithoutInvitationsInput {
  create?: CommitteeCreateWithoutInvitationsInput;
  connect?: CommitteeWhereUniqueInput;
}

export interface CommitteeCreateWithoutInvitationsInput {
  creator: UserCreateOneInput;
  members?: UserCreateManyInput;
  event: EventCreateOneWithoutCommitteeInput;
}

export interface UserCreateOneInput {
  create?: UserCreateInput;
  connect?: UserWhereUniqueInput;
}

export interface EventCreateOneWithoutCommitteeInput {
  create?: EventCreateWithoutCommitteeInput;
  connect?: EventWhereUniqueInput;
}

export interface EventCreateWithoutCommitteeInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: UserCreateManyInput;
  likedBy?: UserCreateManyWithoutLikedEventsInput;
  owner: UserCreateOneInput;
  comments?: CommentCreateManyWithoutEventInput;
  todos?: TodoCreateManyWithoutEventInput;
}

export interface UserCreateManyWithoutLikedEventsInput {
  create?:
    | UserCreateWithoutLikedEventsInput[]
    | UserCreateWithoutLikedEventsInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
}

export interface UserCreateWithoutLikedEventsInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface CommentCreateManyWithoutLikedByInput {
  create?:
    | CommentCreateWithoutLikedByInput[]
    | CommentCreateWithoutLikedByInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentCreateWithoutLikedByInput {
  text: String;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  post?: PostCreateOneWithoutCommentsInput;
  event?: EventCreateOneWithoutCommentsInput;
}

export interface PostCreateOneWithoutCommentsInput {
  create?: PostCreateWithoutCommentsInput;
  connect?: PostWhereUniqueInput;
}

export interface PostCreateWithoutCommentsInput {
  text: String;
  image?: String;
  link?: String;
  author: UserCreateOneWithoutPostsInput;
  likedBy?: UserCreateManyWithoutLikedPostsInput;
  date: DateTimeInput;
}

export interface EventCreateOneWithoutCommentsInput {
  create?: EventCreateWithoutCommentsInput;
  connect?: EventWhereUniqueInput;
}

export interface EventCreateWithoutCommentsInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: UserCreateManyInput;
  likedBy?: UserCreateManyWithoutLikedEventsInput;
  owner: UserCreateOneInput;
  committee: CommitteeCreateOneWithoutEventInput;
  todos?: TodoCreateManyWithoutEventInput;
}

export interface CommitteeCreateOneWithoutEventInput {
  create?: CommitteeCreateWithoutEventInput;
  connect?: CommitteeWhereUniqueInput;
}

export interface CommitteeCreateWithoutEventInput {
  creator: UserCreateOneInput;
  members?: UserCreateManyInput;
  invitations?: InvitationCreateManyWithoutCommitteeInput;
}

export interface InvitationCreateManyWithoutCommitteeInput {
  create?:
    | InvitationCreateWithoutCommitteeInput[]
    | InvitationCreateWithoutCommitteeInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
}

export interface InvitationCreateWithoutCommitteeInput {
  user: UserCreateOneWithoutInvitationsInput;
  status?: InvitationStatus;
}

export interface UserCreateOneWithoutInvitationsInput {
  create?: UserCreateWithoutInvitationsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutInvitationsInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
}

export interface TodoCreateManyWithoutEventInput {
  create?: TodoCreateWithoutEventInput[] | TodoCreateWithoutEventInput;
  connect?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
}

export interface TodoCreateWithoutEventInput {
  due: DateTimeInput;
  text: String;
  done?: Boolean;
  assigned?: UserCreateOneInput;
  link?: String;
  doneBy?: UserCreateOneInput;
  doneAt?: DateTimeInput;
}

export interface CommentCreateManyWithoutEventInput {
  create?: CommentCreateWithoutEventInput[] | CommentCreateWithoutEventInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentCreateWithoutEventInput {
  text: String;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  likedBy?: UserCreateManyWithoutLikedCommentsInput;
  post?: PostCreateOneWithoutCommentsInput;
}

export interface CommentCreateManyWithoutPostInput {
  create?: CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
}

export interface CommentCreateWithoutPostInput {
  text: String;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  likedBy?: UserCreateManyWithoutLikedCommentsInput;
  event?: EventCreateOneWithoutCommentsInput;
}

export interface PurchaseCreateOneWithoutTransactionInput {
  create?: PurchaseCreateWithoutTransactionInput;
  connect?: PurchaseWhereUniqueInput;
}

export interface PurchaseCreateWithoutTransactionInput {
  items?: ItemCreateManyInput;
  total: Float;
  user: UserCreateOneWithoutPurchasesInput;
  date: DateTimeInput;
}

export interface UserCreateOneWithoutPurchasesInput {
  create?: UserCreateWithoutPurchasesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateWithoutPurchasesInput {
  name: String;
  email: String;
  password: String;
  avatar?: String;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostCreateManyWithoutAuthorInput;
  likedPosts?: PostCreateManyWithoutLikedByInput;
  likedEvents?: EventCreateManyWithoutLikedByInput;
  comments?: CommentCreateManyWithoutAuthorInput;
  likedComments?: CommentCreateManyWithoutLikedByInput;
  invitations?: InvitationCreateManyWithoutUserInput;
}

export interface TransactionCreateOneWithoutPurchaseInput {
  create?: TransactionCreateWithoutPurchaseInput;
  connect?: TransactionWhereUniqueInput;
}

export interface TransactionCreateWithoutPurchaseInput {
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  payment?: PaymentCreateOneWithoutTransactionInput;
}

export interface CommentUpdateInput {
  text?: String;
  date?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
  likedBy?: UserUpdateManyWithoutLikedCommentsInput;
  post?: PostUpdateOneWithoutCommentsInput;
  event?: EventUpdateOneWithoutCommentsInput;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: UserCreateWithoutCommentsInput;
  update?: UserUpdateWithoutCommentsDataInput;
  upsert?: UserUpsertWithoutCommentsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutCommentsDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface PurchaseUpdateManyWithoutUserInput {
  create?: PurchaseCreateWithoutUserInput[] | PurchaseCreateWithoutUserInput;
  delete?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
  connect?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
  set?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
  disconnect?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
  update?:
    | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    | PurchaseUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    | PurchaseUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: PurchaseScalarWhereInput[] | PurchaseScalarWhereInput;
  updateMany?:
    | PurchaseUpdateManyWithWhereNestedInput[]
    | PurchaseUpdateManyWithWhereNestedInput;
}

export interface PurchaseUpdateWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput;
  data: PurchaseUpdateWithoutUserDataInput;
}

export interface PurchaseUpdateWithoutUserDataInput {
  items?: ItemUpdateManyInput;
  transaction?: TransactionUpdateOneRequiredWithoutPurchaseInput;
  total?: Float;
  date?: DateTimeInput;
}

export interface ItemUpdateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  update?:
    | ItemUpdateWithWhereUniqueNestedInput[]
    | ItemUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ItemUpsertWithWhereUniqueNestedInput[]
    | ItemUpsertWithWhereUniqueNestedInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  set?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  deleteMany?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  updateMany?:
    | ItemUpdateManyWithWhereNestedInput[]
    | ItemUpdateManyWithWhereNestedInput;
}

export interface ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateDataInput;
}

export interface ItemUpdateDataInput {
  product?: ProductUpdateOneRequiredInput;
  user?: UserUpdateOneRequiredWithoutItemsInput;
  price?: Float;
  amount?: Int;
}

export interface ProductUpdateOneRequiredInput {
  create?: ProductCreateInput;
  update?: ProductUpdateDataInput;
  upsert?: ProductUpsertNestedInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductUpdateDataInput {
  name?: String;
  price?: Float;
  index?: Int;
  thumbnail?: String;
  deleted?: Boolean;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface UserUpdateOneRequiredWithoutItemsInput {
  create?: UserCreateWithoutItemsInput;
  update?: UserUpdateWithoutItemsDataInput;
  upsert?: UserUpsertWithoutItemsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutItemsDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface PaymentUpdateManyWithoutUserInput {
  create?: PaymentCreateWithoutUserInput[] | PaymentCreateWithoutUserInput;
  delete?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  set?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  disconnect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  update?:
    | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    | PaymentUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    | PaymentUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  updateMany?:
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput;
}

export interface PaymentUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutUserDataInput;
}

export interface PaymentUpdateWithoutUserDataInput {
  amount?: Float;
  date?: DateTimeInput;
  verified?: Boolean;
  transaction?: TransactionUpdateOneRequiredWithoutPaymentInput;
}

export interface TransactionUpdateOneRequiredWithoutPaymentInput {
  create?: TransactionCreateWithoutPaymentInput;
  update?: TransactionUpdateWithoutPaymentDataInput;
  upsert?: TransactionUpsertWithoutPaymentInput;
  connect?: TransactionWhereUniqueInput;
}

export interface TransactionUpdateWithoutPaymentDataInput {
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
  date?: DateTimeInput;
  type?: TransactionType;
  balance?: Float;
  purchase?: PurchaseUpdateOneWithoutTransactionInput;
}

export interface UserUpdateOneRequiredWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  update?: UserUpdateWithoutTransactionsDataInput;
  upsert?: UserUpsertWithoutTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutTransactionsDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface ItemUpdateManyWithoutUserInput {
  create?: ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  set?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  update?:
    | ItemUpdateWithWhereUniqueWithoutUserInput[]
    | ItemUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ItemUpsertWithWhereUniqueWithoutUserInput[]
    | ItemUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  updateMany?:
    | ItemUpdateManyWithWhereNestedInput[]
    | ItemUpdateManyWithWhereNestedInput;
}

export interface ItemUpdateWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutUserDataInput;
}

export interface ItemUpdateWithoutUserDataInput {
  product?: ProductUpdateOneRequiredInput;
  price?: Float;
  amount?: Int;
}

export interface ItemUpsertWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutUserDataInput;
  create: ItemCreateWithoutUserInput;
}

export interface ItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  AND?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  OR?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  NOT?: ItemScalarWhereInput[] | ItemScalarWhereInput;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface ItemUpdateManyDataInput {
  price?: Float;
  amount?: Int;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  set?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface PostUpdateWithoutAuthorDataInput {
  text?: String;
  image?: String;
  link?: String;
  likedBy?: UserUpdateManyWithoutLikedPostsInput;
  comments?: CommentUpdateManyWithoutPostInput;
  date?: DateTimeInput;
}

export interface UserUpdateManyWithoutLikedPostsInput {
  create?:
    | UserCreateWithoutLikedPostsInput[]
    | UserCreateWithoutLikedPostsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutLikedPostsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedPostsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutLikedPostsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedPostsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedPostsDataInput;
}

export interface UserUpdateWithoutLikedPostsDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface TransactionUpdateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  delete?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  set?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  disconnect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  update?:
    | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    | TransactionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    | TransactionUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  updateMany?:
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput;
}

export interface TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutUserDataInput;
}

export interface TransactionUpdateWithoutUserDataInput {
  date?: DateTimeInput;
  type?: TransactionType;
  balance?: Float;
  payment?: PaymentUpdateOneWithoutTransactionInput;
  purchase?: PurchaseUpdateOneWithoutTransactionInput;
}

export interface PaymentUpdateOneWithoutTransactionInput {
  create?: PaymentCreateWithoutTransactionInput;
  update?: PaymentUpdateWithoutTransactionDataInput;
  upsert?: PaymentUpsertWithoutTransactionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentWhereUniqueInput;
}

export interface PaymentUpdateWithoutTransactionDataInput {
  amount?: Float;
  user?: UserUpdateOneRequiredWithoutPaymentsInput;
  date?: DateTimeInput;
  verified?: Boolean;
}

export interface UserUpdateOneRequiredWithoutPaymentsInput {
  create?: UserCreateWithoutPaymentsInput;
  update?: UserUpdateWithoutPaymentsDataInput;
  upsert?: UserUpsertWithoutPaymentsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutPaymentsDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface PostUpdateManyWithoutLikedByInput {
  create?: PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput;
  delete?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  connect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  set?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  disconnect?: PostWhereUniqueInput[] | PostWhereUniqueInput;
  update?:
    | PostUpdateWithWhereUniqueWithoutLikedByInput[]
    | PostUpdateWithWhereUniqueWithoutLikedByInput;
  upsert?:
    | PostUpsertWithWhereUniqueWithoutLikedByInput[]
    | PostUpsertWithWhereUniqueWithoutLikedByInput;
  deleteMany?: PostScalarWhereInput[] | PostScalarWhereInput;
  updateMany?:
    | PostUpdateManyWithWhereNestedInput[]
    | PostUpdateManyWithWhereNestedInput;
}

export interface PostUpdateWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutLikedByDataInput;
}

export interface PostUpdateWithoutLikedByDataInput {
  text?: String;
  image?: String;
  link?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  comments?: CommentUpdateManyWithoutPostInput;
  date?: DateTimeInput;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: UserCreateWithoutPostsInput;
  update?: UserUpdateWithoutPostsDataInput;
  upsert?: UserUpsertWithoutPostsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutPostsDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface EventUpdateManyWithoutLikedByInput {
  create?: EventCreateWithoutLikedByInput[] | EventCreateWithoutLikedByInput;
  delete?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  connect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  set?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  disconnect?: EventWhereUniqueInput[] | EventWhereUniqueInput;
  update?:
    | EventUpdateWithWhereUniqueWithoutLikedByInput[]
    | EventUpdateWithWhereUniqueWithoutLikedByInput;
  upsert?:
    | EventUpsertWithWhereUniqueWithoutLikedByInput[]
    | EventUpsertWithWhereUniqueWithoutLikedByInput;
  deleteMany?: EventScalarWhereInput[] | EventScalarWhereInput;
  updateMany?:
    | EventUpdateManyWithWhereNestedInput[]
    | EventUpdateManyWithWhereNestedInput;
}

export interface EventUpdateWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutLikedByDataInput;
}

export interface EventUpdateWithoutLikedByDataInput {
  title?: String;
  description?: String;
  date?: DateTimeInput;
  image?: String;
  supporters?: UserUpdateManyInput;
  owner?: UserUpdateOneRequiredInput;
  comments?: CommentUpdateManyWithoutEventInput;
  committee?: CommitteeUpdateOneRequiredWithoutEventInput;
  todos?: TodoUpdateManyWithoutEventInput;
}

export interface UserUpdateManyInput {
  create?: UserCreateInput[] | UserCreateInput;
  update?:
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput;
  upsert?:
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpdateDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface CommentUpdateManyWithoutAuthorInput {
  create?: CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    | CommentUpdateWithWhereUniqueWithoutAuthorInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    | CommentUpsertWithWhereUniqueWithoutAuthorInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutAuthorDataInput;
}

export interface CommentUpdateWithoutAuthorDataInput {
  text?: String;
  date?: DateTimeInput;
  likedBy?: UserUpdateManyWithoutLikedCommentsInput;
  post?: PostUpdateOneWithoutCommentsInput;
  event?: EventUpdateOneWithoutCommentsInput;
}

export interface UserUpdateManyWithoutLikedCommentsInput {
  create?:
    | UserCreateWithoutLikedCommentsInput[]
    | UserCreateWithoutLikedCommentsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutLikedCommentsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedCommentsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutLikedCommentsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedCommentsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedCommentsDataInput;
}

export interface UserUpdateWithoutLikedCommentsDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface InvitationUpdateManyWithoutUserInput {
  create?:
    | InvitationCreateWithoutUserInput[]
    | InvitationCreateWithoutUserInput;
  delete?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  set?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  disconnect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  update?:
    | InvitationUpdateWithWhereUniqueWithoutUserInput[]
    | InvitationUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | InvitationUpsertWithWhereUniqueWithoutUserInput[]
    | InvitationUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  updateMany?:
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput;
}

export interface InvitationUpdateWithWhereUniqueWithoutUserInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutUserDataInput;
}

export interface InvitationUpdateWithoutUserDataInput {
  committee?: CommitteeUpdateOneRequiredWithoutInvitationsInput;
  status?: InvitationStatus;
}

export interface CommitteeUpdateOneRequiredWithoutInvitationsInput {
  create?: CommitteeCreateWithoutInvitationsInput;
  update?: CommitteeUpdateWithoutInvitationsDataInput;
  upsert?: CommitteeUpsertWithoutInvitationsInput;
  connect?: CommitteeWhereUniqueInput;
}

export interface CommitteeUpdateWithoutInvitationsDataInput {
  creator?: UserUpdateOneRequiredInput;
  members?: UserUpdateManyInput;
  event?: EventUpdateOneRequiredWithoutCommitteeInput;
}

export interface UserUpdateOneRequiredInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface EventUpdateOneRequiredWithoutCommitteeInput {
  create?: EventCreateWithoutCommitteeInput;
  update?: EventUpdateWithoutCommitteeDataInput;
  upsert?: EventUpsertWithoutCommitteeInput;
  connect?: EventWhereUniqueInput;
}

export interface EventUpdateWithoutCommitteeDataInput {
  title?: String;
  description?: String;
  date?: DateTimeInput;
  image?: String;
  supporters?: UserUpdateManyInput;
  likedBy?: UserUpdateManyWithoutLikedEventsInput;
  owner?: UserUpdateOneRequiredInput;
  comments?: CommentUpdateManyWithoutEventInput;
  todos?: TodoUpdateManyWithoutEventInput;
}

export interface UserUpdateManyWithoutLikedEventsInput {
  create?:
    | UserCreateWithoutLikedEventsInput[]
    | UserCreateWithoutLikedEventsInput;
  delete?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  connect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  set?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  disconnect?: UserWhereUniqueInput[] | UserWhereUniqueInput;
  update?:
    | UserUpdateWithWhereUniqueWithoutLikedEventsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedEventsInput;
  upsert?:
    | UserUpsertWithWhereUniqueWithoutLikedEventsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedEventsInput;
  deleteMany?: UserScalarWhereInput[] | UserScalarWhereInput;
  updateMany?:
    | UserUpdateManyWithWhereNestedInput[]
    | UserUpdateManyWithWhereNestedInput;
}

export interface UserUpdateWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedEventsDataInput;
}

export interface UserUpdateWithoutLikedEventsDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface CommentUpdateManyWithoutLikedByInput {
  create?:
    | CommentCreateWithoutLikedByInput[]
    | CommentCreateWithoutLikedByInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutLikedByInput[]
    | CommentUpdateWithWhereUniqueWithoutLikedByInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutLikedByInput[]
    | CommentUpsertWithWhereUniqueWithoutLikedByInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutLikedByDataInput;
}

export interface CommentUpdateWithoutLikedByDataInput {
  text?: String;
  date?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
  post?: PostUpdateOneWithoutCommentsInput;
  event?: EventUpdateOneWithoutCommentsInput;
}

export interface PostUpdateOneWithoutCommentsInput {
  create?: PostCreateWithoutCommentsInput;
  update?: PostUpdateWithoutCommentsDataInput;
  upsert?: PostUpsertWithoutCommentsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PostWhereUniqueInput;
}

export interface PostUpdateWithoutCommentsDataInput {
  text?: String;
  image?: String;
  link?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  likedBy?: UserUpdateManyWithoutLikedPostsInput;
  date?: DateTimeInput;
}

export interface PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput;
  create: PostCreateWithoutCommentsInput;
}

export interface EventUpdateOneWithoutCommentsInput {
  create?: EventCreateWithoutCommentsInput;
  update?: EventUpdateWithoutCommentsDataInput;
  upsert?: EventUpsertWithoutCommentsInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: EventWhereUniqueInput;
}

export interface EventUpdateWithoutCommentsDataInput {
  title?: String;
  description?: String;
  date?: DateTimeInput;
  image?: String;
  supporters?: UserUpdateManyInput;
  likedBy?: UserUpdateManyWithoutLikedEventsInput;
  owner?: UserUpdateOneRequiredInput;
  committee?: CommitteeUpdateOneRequiredWithoutEventInput;
  todos?: TodoUpdateManyWithoutEventInput;
}

export interface CommitteeUpdateOneRequiredWithoutEventInput {
  create?: CommitteeCreateWithoutEventInput;
  update?: CommitteeUpdateWithoutEventDataInput;
  upsert?: CommitteeUpsertWithoutEventInput;
  connect?: CommitteeWhereUniqueInput;
}

export interface CommitteeUpdateWithoutEventDataInput {
  creator?: UserUpdateOneRequiredInput;
  members?: UserUpdateManyInput;
  invitations?: InvitationUpdateManyWithoutCommitteeInput;
}

export interface InvitationUpdateManyWithoutCommitteeInput {
  create?:
    | InvitationCreateWithoutCommitteeInput[]
    | InvitationCreateWithoutCommitteeInput;
  delete?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  connect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  set?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  disconnect?: InvitationWhereUniqueInput[] | InvitationWhereUniqueInput;
  update?:
    | InvitationUpdateWithWhereUniqueWithoutCommitteeInput[]
    | InvitationUpdateWithWhereUniqueWithoutCommitteeInput;
  upsert?:
    | InvitationUpsertWithWhereUniqueWithoutCommitteeInput[]
    | InvitationUpsertWithWhereUniqueWithoutCommitteeInput;
  deleteMany?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  updateMany?:
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput;
}

export interface InvitationUpdateWithWhereUniqueWithoutCommitteeInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutCommitteeDataInput;
}

export interface InvitationUpdateWithoutCommitteeDataInput {
  user?: UserUpdateOneRequiredWithoutInvitationsInput;
  status?: InvitationStatus;
}

export interface UserUpdateOneRequiredWithoutInvitationsInput {
  create?: UserCreateWithoutInvitationsInput;
  update?: UserUpdateWithoutInvitationsDataInput;
  upsert?: UserUpsertWithoutInvitationsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutInvitationsDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
}

export interface UserUpsertWithoutInvitationsInput {
  update: UserUpdateWithoutInvitationsDataInput;
  create: UserCreateWithoutInvitationsInput;
}

export interface InvitationUpsertWithWhereUniqueWithoutCommitteeInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutCommitteeDataInput;
  create: InvitationCreateWithoutCommitteeInput;
}

export interface InvitationScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  status?: InvitationStatus;
  status_not?: InvitationStatus;
  status_in?: InvitationStatus[] | InvitationStatus;
  status_not_in?: InvitationStatus[] | InvitationStatus;
  AND?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  OR?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
  NOT?: InvitationScalarWhereInput[] | InvitationScalarWhereInput;
}

export interface InvitationUpdateManyWithWhereNestedInput {
  where: InvitationScalarWhereInput;
  data: InvitationUpdateManyDataInput;
}

export interface InvitationUpdateManyDataInput {
  status?: InvitationStatus;
}

export interface CommitteeUpsertWithoutEventInput {
  update: CommitteeUpdateWithoutEventDataInput;
  create: CommitteeCreateWithoutEventInput;
}

export interface TodoUpdateManyWithoutEventInput {
  create?: TodoCreateWithoutEventInput[] | TodoCreateWithoutEventInput;
  delete?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  connect?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  set?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  disconnect?: TodoWhereUniqueInput[] | TodoWhereUniqueInput;
  update?:
    | TodoUpdateWithWhereUniqueWithoutEventInput[]
    | TodoUpdateWithWhereUniqueWithoutEventInput;
  upsert?:
    | TodoUpsertWithWhereUniqueWithoutEventInput[]
    | TodoUpsertWithWhereUniqueWithoutEventInput;
  deleteMany?: TodoScalarWhereInput[] | TodoScalarWhereInput;
  updateMany?:
    | TodoUpdateManyWithWhereNestedInput[]
    | TodoUpdateManyWithWhereNestedInput;
}

export interface TodoUpdateWithWhereUniqueWithoutEventInput {
  where: TodoWhereUniqueInput;
  data: TodoUpdateWithoutEventDataInput;
}

export interface TodoUpdateWithoutEventDataInput {
  due?: DateTimeInput;
  text?: String;
  done?: Boolean;
  assigned?: UserUpdateOneInput;
  link?: String;
  doneBy?: UserUpdateOneInput;
  doneAt?: DateTimeInput;
}

export interface UserUpdateOneInput {
  create?: UserCreateInput;
  update?: UserUpdateDataInput;
  upsert?: UserUpsertNestedInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: UserWhereUniqueInput;
}

export interface TodoUpsertWithWhereUniqueWithoutEventInput {
  where: TodoWhereUniqueInput;
  update: TodoUpdateWithoutEventDataInput;
  create: TodoCreateWithoutEventInput;
}

export interface TodoScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  due?: DateTimeInput;
  due_not?: DateTimeInput;
  due_in?: DateTimeInput[] | DateTimeInput;
  due_not_in?: DateTimeInput[] | DateTimeInput;
  due_lt?: DateTimeInput;
  due_lte?: DateTimeInput;
  due_gt?: DateTimeInput;
  due_gte?: DateTimeInput;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  done?: Boolean;
  done_not?: Boolean;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  doneAt?: DateTimeInput;
  doneAt_not?: DateTimeInput;
  doneAt_in?: DateTimeInput[] | DateTimeInput;
  doneAt_not_in?: DateTimeInput[] | DateTimeInput;
  doneAt_lt?: DateTimeInput;
  doneAt_lte?: DateTimeInput;
  doneAt_gt?: DateTimeInput;
  doneAt_gte?: DateTimeInput;
  AND?: TodoScalarWhereInput[] | TodoScalarWhereInput;
  OR?: TodoScalarWhereInput[] | TodoScalarWhereInput;
  NOT?: TodoScalarWhereInput[] | TodoScalarWhereInput;
}

export interface TodoUpdateManyWithWhereNestedInput {
  where: TodoScalarWhereInput;
  data: TodoUpdateManyDataInput;
}

export interface TodoUpdateManyDataInput {
  due?: DateTimeInput;
  text?: String;
  done?: Boolean;
  link?: String;
  doneAt?: DateTimeInput;
}

export interface EventUpsertWithoutCommentsInput {
  update: EventUpdateWithoutCommentsDataInput;
  create: EventCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutLikedByDataInput;
  create: CommentCreateWithoutLikedByInput;
}

export interface CommentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  OR?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  NOT?: CommentScalarWhereInput[] | CommentScalarWhereInput;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  text?: String;
  date?: DateTimeInput;
}

export interface UserUpsertWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedEventsDataInput;
  create: UserCreateWithoutLikedEventsInput;
}

export interface UserScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  avatar?: String;
  avatar_not?: String;
  avatar_in?: String[] | String;
  avatar_not_in?: String[] | String;
  avatar_lt?: String;
  avatar_lte?: String;
  avatar_gt?: String;
  avatar_gte?: String;
  avatar_contains?: String;
  avatar_not_contains?: String;
  avatar_starts_with?: String;
  avatar_not_starts_with?: String;
  avatar_ends_with?: String;
  avatar_not_ends_with?: String;
  role?: UserRole;
  role_not?: UserRole;
  role_in?: UserRole[] | UserRole;
  role_not_in?: UserRole[] | UserRole;
  balance?: Float;
  balance_not?: Float;
  balance_in?: Float[] | Float;
  balance_not_in?: Float[] | Float;
  balance_lt?: Float;
  balance_lte?: Float;
  balance_gt?: Float;
  balance_gte?: Float;
  AND?: UserScalarWhereInput[] | UserScalarWhereInput;
  OR?: UserScalarWhereInput[] | UserScalarWhereInput;
  NOT?: UserScalarWhereInput[] | UserScalarWhereInput;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  role?: UserRole;
  balance?: Float;
}

export interface CommentUpdateManyWithoutEventInput {
  create?: CommentCreateWithoutEventInput[] | CommentCreateWithoutEventInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutEventInput[]
    | CommentUpdateWithWhereUniqueWithoutEventInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutEventInput[]
    | CommentUpsertWithWhereUniqueWithoutEventInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutEventDataInput;
}

export interface CommentUpdateWithoutEventDataInput {
  text?: String;
  date?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
  likedBy?: UserUpdateManyWithoutLikedCommentsInput;
  post?: PostUpdateOneWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutEventDataInput;
  create: CommentCreateWithoutEventInput;
}

export interface EventUpsertWithoutCommitteeInput {
  update: EventUpdateWithoutCommitteeDataInput;
  create: EventCreateWithoutCommitteeInput;
}

export interface CommitteeUpsertWithoutInvitationsInput {
  update: CommitteeUpdateWithoutInvitationsDataInput;
  create: CommitteeCreateWithoutInvitationsInput;
}

export interface InvitationUpsertWithWhereUniqueWithoutUserInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutUserDataInput;
  create: InvitationCreateWithoutUserInput;
}

export interface UserUpsertWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedCommentsDataInput;
  create: UserCreateWithoutLikedCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutAuthorDataInput;
  create: CommentCreateWithoutAuthorInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface EventUpsertWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutLikedByDataInput;
  create: EventCreateWithoutLikedByInput;
}

export interface EventScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  AND?: EventScalarWhereInput[] | EventScalarWhereInput;
  OR?: EventScalarWhereInput[] | EventScalarWhereInput;
  NOT?: EventScalarWhereInput[] | EventScalarWhereInput;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface EventUpdateManyDataInput {
  title?: String;
  description?: String;
  date?: DateTimeInput;
  image?: String;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface CommentUpdateManyWithoutPostInput {
  create?: CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput;
  delete?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  connect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  set?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  disconnect?: CommentWhereUniqueInput[] | CommentWhereUniqueInput;
  update?:
    | CommentUpdateWithWhereUniqueWithoutPostInput[]
    | CommentUpdateWithWhereUniqueWithoutPostInput;
  upsert?:
    | CommentUpsertWithWhereUniqueWithoutPostInput[]
    | CommentUpsertWithWhereUniqueWithoutPostInput;
  deleteMany?: CommentScalarWhereInput[] | CommentScalarWhereInput;
  updateMany?:
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput;
}

export interface CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutPostDataInput;
}

export interface CommentUpdateWithoutPostDataInput {
  text?: String;
  date?: DateTimeInput;
  author?: UserUpdateOneRequiredWithoutCommentsInput;
  likedBy?: UserUpdateManyWithoutLikedCommentsInput;
  event?: EventUpdateOneWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutPostDataInput;
  create: CommentCreateWithoutPostInput;
}

export interface PostUpsertWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutLikedByDataInput;
  create: PostCreateWithoutLikedByInput;
}

export interface PostScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  image?: String;
  image_not?: String;
  image_in?: String[] | String;
  image_not_in?: String[] | String;
  image_lt?: String;
  image_lte?: String;
  image_gt?: String;
  image_gte?: String;
  image_contains?: String;
  image_not_contains?: String;
  image_starts_with?: String;
  image_not_starts_with?: String;
  image_ends_with?: String;
  image_not_ends_with?: String;
  link?: String;
  link_not?: String;
  link_in?: String[] | String;
  link_not_in?: String[] | String;
  link_lt?: String;
  link_lte?: String;
  link_gt?: String;
  link_gte?: String;
  link_contains?: String;
  link_not_contains?: String;
  link_starts_with?: String;
  link_not_starts_with?: String;
  link_ends_with?: String;
  link_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: PostScalarWhereInput[] | PostScalarWhereInput;
  OR?: PostScalarWhereInput[] | PostScalarWhereInput;
  NOT?: PostScalarWhereInput[] | PostScalarWhereInput;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface PostUpdateManyDataInput {
  text?: String;
  image?: String;
  link?: String;
  date?: DateTimeInput;
}

export interface UserUpsertWithoutPaymentsInput {
  update: UserUpdateWithoutPaymentsDataInput;
  create: UserCreateWithoutPaymentsInput;
}

export interface PaymentUpsertWithoutTransactionInput {
  update: PaymentUpdateWithoutTransactionDataInput;
  create: PaymentCreateWithoutTransactionInput;
}

export interface PurchaseUpdateOneWithoutTransactionInput {
  create?: PurchaseCreateWithoutTransactionInput;
  update?: PurchaseUpdateWithoutTransactionDataInput;
  upsert?: PurchaseUpsertWithoutTransactionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PurchaseWhereUniqueInput;
}

export interface PurchaseUpdateWithoutTransactionDataInput {
  items?: ItemUpdateManyInput;
  total?: Float;
  user?: UserUpdateOneRequiredWithoutPurchasesInput;
  date?: DateTimeInput;
}

export interface UserUpdateOneRequiredWithoutPurchasesInput {
  create?: UserCreateWithoutPurchasesInput;
  update?: UserUpdateWithoutPurchasesDataInput;
  upsert?: UserUpsertWithoutPurchasesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserUpdateWithoutPurchasesDataInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface UserUpsertWithoutPurchasesInput {
  update: UserUpdateWithoutPurchasesDataInput;
  create: UserCreateWithoutPurchasesInput;
}

export interface PurchaseUpsertWithoutTransactionInput {
  update: PurchaseUpdateWithoutTransactionDataInput;
  create: PurchaseCreateWithoutTransactionInput;
}

export interface TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutUserDataInput;
  create: TransactionCreateWithoutUserInput;
}

export interface TransactionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  balance?: Float;
  balance_not?: Float;
  balance_in?: Float[] | Float;
  balance_not_in?: Float[] | Float;
  balance_lt?: Float;
  balance_lte?: Float;
  balance_gt?: Float;
  balance_gte?: Float;
  AND?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  OR?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  NOT?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface TransactionUpdateManyDataInput {
  date?: DateTimeInput;
  type?: TransactionType;
  balance?: Float;
}

export interface UserUpsertWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedPostsDataInput;
  create: UserCreateWithoutLikedPostsInput;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput;
  create: UserCreateWithoutTransactionsInput;
}

export interface TransactionUpsertWithoutPaymentInput {
  update: TransactionUpdateWithoutPaymentDataInput;
  create: TransactionCreateWithoutPaymentInput;
}

export interface PaymentUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutUserDataInput;
  create: PaymentCreateWithoutUserInput;
}

export interface PaymentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  verified?: Boolean;
  verified_not?: Boolean;
  AND?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  OR?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  NOT?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface PaymentUpdateManyDataInput {
  amount?: Float;
  date?: DateTimeInput;
  verified?: Boolean;
}

export interface UserUpsertWithoutItemsInput {
  update: UserUpdateWithoutItemsDataInput;
  create: UserCreateWithoutItemsInput;
}

export interface ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface TransactionUpdateOneRequiredWithoutPurchaseInput {
  create?: TransactionCreateWithoutPurchaseInput;
  update?: TransactionUpdateWithoutPurchaseDataInput;
  upsert?: TransactionUpsertWithoutPurchaseInput;
  connect?: TransactionWhereUniqueInput;
}

export interface TransactionUpdateWithoutPurchaseDataInput {
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
  date?: DateTimeInput;
  type?: TransactionType;
  balance?: Float;
  payment?: PaymentUpdateOneWithoutTransactionInput;
}

export interface TransactionUpsertWithoutPurchaseInput {
  update: TransactionUpdateWithoutPurchaseDataInput;
  create: TransactionCreateWithoutPurchaseInput;
}

export interface PurchaseUpsertWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput;
  update: PurchaseUpdateWithoutUserDataInput;
  create: PurchaseCreateWithoutUserInput;
}

export interface PurchaseScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  total?: Float;
  total_not?: Float;
  total_in?: Float[] | Float;
  total_not_in?: Float[] | Float;
  total_lt?: Float;
  total_lte?: Float;
  total_gt?: Float;
  total_gte?: Float;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: PurchaseScalarWhereInput[] | PurchaseScalarWhereInput;
  OR?: PurchaseScalarWhereInput[] | PurchaseScalarWhereInput;
  NOT?: PurchaseScalarWhereInput[] | PurchaseScalarWhereInput;
}

export interface PurchaseUpdateManyWithWhereNestedInput {
  where: PurchaseScalarWhereInput;
  data: PurchaseUpdateManyDataInput;
}

export interface PurchaseUpdateManyDataInput {
  total?: Float;
  date?: DateTimeInput;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface CommentUpdateManyMutationInput {
  text?: String;
  date?: DateTimeInput;
}

export interface CommitteeCreateInput {
  creator: UserCreateOneInput;
  members?: UserCreateManyInput;
  event: EventCreateOneWithoutCommitteeInput;
  invitations?: InvitationCreateManyWithoutCommitteeInput;
}

export interface CommitteeUpdateInput {
  creator?: UserUpdateOneRequiredInput;
  members?: UserUpdateManyInput;
  event?: EventUpdateOneRequiredWithoutCommitteeInput;
  invitations?: InvitationUpdateManyWithoutCommitteeInput;
}

export interface EventCreateInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: UserCreateManyInput;
  likedBy?: UserCreateManyWithoutLikedEventsInput;
  owner: UserCreateOneInput;
  comments?: CommentCreateManyWithoutEventInput;
  committee: CommitteeCreateOneWithoutEventInput;
  todos?: TodoCreateManyWithoutEventInput;
}

export interface EventUpdateInput {
  title?: String;
  description?: String;
  date?: DateTimeInput;
  image?: String;
  supporters?: UserUpdateManyInput;
  likedBy?: UserUpdateManyWithoutLikedEventsInput;
  owner?: UserUpdateOneRequiredInput;
  comments?: CommentUpdateManyWithoutEventInput;
  committee?: CommitteeUpdateOneRequiredWithoutEventInput;
  todos?: TodoUpdateManyWithoutEventInput;
}

export interface EventUpdateManyMutationInput {
  title?: String;
  description?: String;
  date?: DateTimeInput;
  image?: String;
}

export interface FileCreateInput {
  fileId: String;
  hash: String;
  uri: String;
  filename: String;
  path: String;
  mimetype: String;
  extension: String;
}

export interface FileUpdateInput {
  fileId?: String;
  hash?: String;
  uri?: String;
  filename?: String;
  path?: String;
  mimetype?: String;
  extension?: String;
}

export interface FileUpdateManyMutationInput {
  fileId?: String;
  hash?: String;
  uri?: String;
  filename?: String;
  path?: String;
  mimetype?: String;
  extension?: String;
}

export interface InvitationCreateInput {
  user: UserCreateOneWithoutInvitationsInput;
  committee: CommitteeCreateOneWithoutInvitationsInput;
  status?: InvitationStatus;
}

export interface InvitationUpdateInput {
  user?: UserUpdateOneRequiredWithoutInvitationsInput;
  committee?: CommitteeUpdateOneRequiredWithoutInvitationsInput;
  status?: InvitationStatus;
}

export interface InvitationUpdateManyMutationInput {
  status?: InvitationStatus;
}

export interface ItemUpdateInput {
  product?: ProductUpdateOneRequiredInput;
  user?: UserUpdateOneRequiredWithoutItemsInput;
  price?: Float;
  amount?: Int;
}

export interface ItemUpdateManyMutationInput {
  price?: Float;
  amount?: Int;
}

export interface PaymentCreateInput {
  amount: Float;
  user: UserCreateOneWithoutPaymentsInput;
  date: DateTimeInput;
  verified?: Boolean;
  transaction: TransactionCreateOneWithoutPaymentInput;
}

export interface PaymentUpdateInput {
  amount?: Float;
  user?: UserUpdateOneRequiredWithoutPaymentsInput;
  date?: DateTimeInput;
  verified?: Boolean;
  transaction?: TransactionUpdateOneRequiredWithoutPaymentInput;
}

export interface PaymentUpdateManyMutationInput {
  amount?: Float;
  date?: DateTimeInput;
  verified?: Boolean;
}

export interface PostCreateInput {
  text: String;
  image?: String;
  link?: String;
  author: UserCreateOneWithoutPostsInput;
  likedBy?: UserCreateManyWithoutLikedPostsInput;
  comments?: CommentCreateManyWithoutPostInput;
  date: DateTimeInput;
}

export interface PostUpdateInput {
  text?: String;
  image?: String;
  link?: String;
  author?: UserUpdateOneRequiredWithoutPostsInput;
  likedBy?: UserUpdateManyWithoutLikedPostsInput;
  comments?: CommentUpdateManyWithoutPostInput;
  date?: DateTimeInput;
}

export interface PostUpdateManyMutationInput {
  text?: String;
  image?: String;
  link?: String;
  date?: DateTimeInput;
}

export interface ProductUpdateInput {
  name?: String;
  price?: Float;
  index?: Int;
  thumbnail?: String;
  deleted?: Boolean;
}

export interface ProductUpdateManyMutationInput {
  name?: String;
  price?: Float;
  index?: Int;
  thumbnail?: String;
  deleted?: Boolean;
}

export interface ProductionCreateInput {
  title: String;
  description: String;
  image: String;
  index: Int;
  show?: Boolean;
}

export interface ProductionUpdateInput {
  title?: String;
  description?: String;
  image?: String;
  index?: Int;
  show?: Boolean;
}

export interface ProductionUpdateManyMutationInput {
  title?: String;
  description?: String;
  image?: String;
  index?: Int;
  show?: Boolean;
}

export interface PurchaseCreateInput {
  items?: ItemCreateManyInput;
  transaction: TransactionCreateOneWithoutPurchaseInput;
  total: Float;
  user: UserCreateOneWithoutPurchasesInput;
  date: DateTimeInput;
}

export interface PurchaseUpdateInput {
  items?: ItemUpdateManyInput;
  transaction?: TransactionUpdateOneRequiredWithoutPurchaseInput;
  total?: Float;
  user?: UserUpdateOneRequiredWithoutPurchasesInput;
  date?: DateTimeInput;
}

export interface PurchaseUpdateManyMutationInput {
  total?: Float;
  date?: DateTimeInput;
}

export interface QuestionCreateInput {
  text: String;
  description: String;
  templates?: TodoTemplateCreateManyInput;
}

export interface TodoTemplateCreateManyInput {
  create?: TodoTemplateCreateInput[] | TodoTemplateCreateInput;
  connect?: TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput;
}

export interface TodoTemplateCreateInput {
  text: String;
  offsetDays: Int;
}

export interface QuestionUpdateInput {
  text?: String;
  description?: String;
  templates?: TodoTemplateUpdateManyInput;
}

export interface TodoTemplateUpdateManyInput {
  create?: TodoTemplateCreateInput[] | TodoTemplateCreateInput;
  update?:
    | TodoTemplateUpdateWithWhereUniqueNestedInput[]
    | TodoTemplateUpdateWithWhereUniqueNestedInput;
  upsert?:
    | TodoTemplateUpsertWithWhereUniqueNestedInput[]
    | TodoTemplateUpsertWithWhereUniqueNestedInput;
  delete?: TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput;
  connect?: TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput;
  set?: TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput;
  disconnect?: TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput;
  deleteMany?: TodoTemplateScalarWhereInput[] | TodoTemplateScalarWhereInput;
  updateMany?:
    | TodoTemplateUpdateManyWithWhereNestedInput[]
    | TodoTemplateUpdateManyWithWhereNestedInput;
}

export interface TodoTemplateUpdateWithWhereUniqueNestedInput {
  where: TodoTemplateWhereUniqueInput;
  data: TodoTemplateUpdateDataInput;
}

export interface TodoTemplateUpdateDataInput {
  text?: String;
  offsetDays?: Int;
}

export interface TodoTemplateUpsertWithWhereUniqueNestedInput {
  where: TodoTemplateWhereUniqueInput;
  update: TodoTemplateUpdateDataInput;
  create: TodoTemplateCreateInput;
}

export interface TodoTemplateScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  text?: String;
  text_not?: String;
  text_in?: String[] | String;
  text_not_in?: String[] | String;
  text_lt?: String;
  text_lte?: String;
  text_gt?: String;
  text_gte?: String;
  text_contains?: String;
  text_not_contains?: String;
  text_starts_with?: String;
  text_not_starts_with?: String;
  text_ends_with?: String;
  text_not_ends_with?: String;
  offsetDays?: Int;
  offsetDays_not?: Int;
  offsetDays_in?: Int[] | Int;
  offsetDays_not_in?: Int[] | Int;
  offsetDays_lt?: Int;
  offsetDays_lte?: Int;
  offsetDays_gt?: Int;
  offsetDays_gte?: Int;
  AND?: TodoTemplateScalarWhereInput[] | TodoTemplateScalarWhereInput;
  OR?: TodoTemplateScalarWhereInput[] | TodoTemplateScalarWhereInput;
  NOT?: TodoTemplateScalarWhereInput[] | TodoTemplateScalarWhereInput;
}

export interface TodoTemplateUpdateManyWithWhereNestedInput {
  where: TodoTemplateScalarWhereInput;
  data: TodoTemplateUpdateManyDataInput;
}

export interface TodoTemplateUpdateManyDataInput {
  text?: String;
  offsetDays?: Int;
}

export interface QuestionUpdateManyMutationInput {
  text?: String;
  description?: String;
}

export interface TodoCreateInput {
  due: DateTimeInput;
  text: String;
  done?: Boolean;
  assigned?: UserCreateOneInput;
  link?: String;
  doneBy?: UserCreateOneInput;
  doneAt?: DateTimeInput;
  event: EventCreateOneWithoutTodosInput;
}

export interface EventCreateOneWithoutTodosInput {
  create?: EventCreateWithoutTodosInput;
  connect?: EventWhereUniqueInput;
}

export interface EventCreateWithoutTodosInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: UserCreateManyInput;
  likedBy?: UserCreateManyWithoutLikedEventsInput;
  owner: UserCreateOneInput;
  comments?: CommentCreateManyWithoutEventInput;
  committee: CommitteeCreateOneWithoutEventInput;
}

export interface TodoUpdateInput {
  due?: DateTimeInput;
  text?: String;
  done?: Boolean;
  assigned?: UserUpdateOneInput;
  link?: String;
  doneBy?: UserUpdateOneInput;
  doneAt?: DateTimeInput;
  event?: EventUpdateOneRequiredWithoutTodosInput;
}

export interface EventUpdateOneRequiredWithoutTodosInput {
  create?: EventCreateWithoutTodosInput;
  update?: EventUpdateWithoutTodosDataInput;
  upsert?: EventUpsertWithoutTodosInput;
  connect?: EventWhereUniqueInput;
}

export interface EventUpdateWithoutTodosDataInput {
  title?: String;
  description?: String;
  date?: DateTimeInput;
  image?: String;
  supporters?: UserUpdateManyInput;
  likedBy?: UserUpdateManyWithoutLikedEventsInput;
  owner?: UserUpdateOneRequiredInput;
  comments?: CommentUpdateManyWithoutEventInput;
  committee?: CommitteeUpdateOneRequiredWithoutEventInput;
}

export interface EventUpsertWithoutTodosInput {
  update: EventUpdateWithoutTodosDataInput;
  create: EventCreateWithoutTodosInput;
}

export interface TodoUpdateManyMutationInput {
  due?: DateTimeInput;
  text?: String;
  done?: Boolean;
  link?: String;
  doneAt?: DateTimeInput;
}

export interface TodoTemplateUpdateInput {
  text?: String;
  offsetDays?: Int;
}

export interface TodoTemplateUpdateManyMutationInput {
  text?: String;
  offsetDays?: Int;
}

export interface TransactionCreateInput {
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  payment?: PaymentCreateOneWithoutTransactionInput;
  purchase?: PurchaseCreateOneWithoutTransactionInput;
}

export interface TransactionUpdateInput {
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
  date?: DateTimeInput;
  type?: TransactionType;
  balance?: Float;
  payment?: PaymentUpdateOneWithoutTransactionInput;
  purchase?: PurchaseUpdateOneWithoutTransactionInput;
}

export interface TransactionUpdateManyMutationInput {
  date?: DateTimeInput;
  type?: TransactionType;
  balance?: Float;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  role?: UserRole;
  balance?: Float;
  posts?: PostUpdateManyWithoutAuthorInput;
  likedPosts?: PostUpdateManyWithoutLikedByInput;
  likedEvents?: EventUpdateManyWithoutLikedByInput;
  comments?: CommentUpdateManyWithoutAuthorInput;
  likedComments?: CommentUpdateManyWithoutLikedByInput;
  invitations?: InvitationUpdateManyWithoutUserInput;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
  avatar?: String;
  role?: UserRole;
  balance?: Float;
}

export interface ClientSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClientWhereInput;
  AND?: ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput;
  OR?: ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput;
  NOT?: ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommentWhereInput;
  AND?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  OR?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
  NOT?: CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput;
}

export interface CommitteeSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: CommitteeWhereInput;
  AND?: CommitteeSubscriptionWhereInput[] | CommitteeSubscriptionWhereInput;
  OR?: CommitteeSubscriptionWhereInput[] | CommitteeSubscriptionWhereInput;
  NOT?: CommitteeSubscriptionWhereInput[] | CommitteeSubscriptionWhereInput;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventWhereInput;
  AND?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  OR?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  NOT?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  OR?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  NOT?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface InvitationSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: InvitationWhereInput;
  AND?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
  OR?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
  NOT?: InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ItemWhereInput;
  AND?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  OR?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  NOT?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentWhereInput;
  AND?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  OR?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  NOT?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PostWhereInput;
  AND?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  OR?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
  NOT?: PostSubscriptionWhereInput[] | PostSubscriptionWhereInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface ProductionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductionWhereInput;
  AND?: ProductionSubscriptionWhereInput[] | ProductionSubscriptionWhereInput;
  OR?: ProductionSubscriptionWhereInput[] | ProductionSubscriptionWhereInput;
  NOT?: ProductionSubscriptionWhereInput[] | ProductionSubscriptionWhereInput;
}

export interface PurchaseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PurchaseWhereInput;
  AND?: PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput;
  OR?: PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput;
  NOT?: PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput;
}

export interface QuestionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: QuestionWhereInput;
  AND?: QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput;
  OR?: QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput;
  NOT?: QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput;
}

export interface TodoSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TodoWhereInput;
  AND?: TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput;
  OR?: TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput;
  NOT?: TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput;
}

export interface TodoTemplateSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TodoTemplateWhereInput;
  AND?:
    | TodoTemplateSubscriptionWhereInput[]
    | TodoTemplateSubscriptionWhereInput;
  OR?:
    | TodoTemplateSubscriptionWhereInput[]
    | TodoTemplateSubscriptionWhereInput;
  NOT?:
    | TodoTemplateSubscriptionWhereInput[]
    | TodoTemplateSubscriptionWhereInput;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransactionWhereInput;
  AND?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  OR?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  NOT?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Client {
  id: ID_Output;
  identity: String;
  secret: String;
  name: String;
  trusted: Boolean;
}

export interface ClientPromise extends Promise<Client>, Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientSubscription
  extends Promise<AsyncIterator<Client>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identity: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trusted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ClientConnection {
  pageInfo: PageInfo;
  edges: ClientEdge[];
}

export interface ClientConnectionPromise
  extends Promise<ClientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClientEdge>>() => T;
  aggregate: <T = AggregateClientPromise>() => T;
}

export interface ClientConnectionSubscription
  extends Promise<AsyncIterator<ClientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClientSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ClientEdge {
  node: Client;
  cursor: String;
}

export interface ClientEdgePromise extends Promise<ClientEdge>, Fragmentable {
  node: <T = ClientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClientEdgeSubscription
  extends Promise<AsyncIterator<ClientEdge>>,
    Fragmentable {
  node: <T = ClientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClient {
  count: Int;
}

export interface AggregateClientPromise
  extends Promise<AggregateClient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClientSubscription
  extends Promise<AsyncIterator<AggregateClient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Comment {
  id: ID_Output;
  text: String;
  date: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  post: <T = PostPromise>() => T;
  event: <T = EventPromise>() => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  post: <T = PostSubscription>() => T;
  event: <T = EventSubscription>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  avatar?: String;
  role: UserRole;
  balance: Float;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  avatar: () => Promise<String>;
  purchases: <T = FragmentableArray<Purchase>>(
    args?: {
      where?: PurchaseWhereInput;
      orderBy?: PurchaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  payments: <T = FragmentableArray<Payment>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transactions: <T = FragmentableArray<Transaction>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  items: <T = FragmentableArray<Item>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  role: () => Promise<UserRole>;
  balance: () => Promise<Float>;
  posts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedPosts: <T = FragmentableArray<Post>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedEvents: <T = FragmentableArray<Event>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedComments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invitations: <T = FragmentableArray<Invitation>>(
    args?: {
      where?: InvitationWhereInput;
      orderBy?: InvitationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  purchases: <T = Promise<AsyncIterator<PurchaseSubscription>>>(
    args?: {
      where?: PurchaseWhereInput;
      orderBy?: PurchaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  role: () => Promise<AsyncIterator<UserRole>>;
  balance: () => Promise<AsyncIterator<Float>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedPosts: <T = Promise<AsyncIterator<PostSubscription>>>(
    args?: {
      where?: PostWhereInput;
      orderBy?: PostOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedEvents: <T = Promise<AsyncIterator<EventSubscription>>>(
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedComments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(
    args?: {
      where?: InvitationWhereInput;
      orderBy?: InvitationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Purchase {
  id: ID_Output;
  total: Float;
  date: DateTimeOutput;
}

export interface PurchasePromise extends Promise<Purchase>, Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<Item>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transaction: <T = TransactionPromise>() => T;
  total: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface PurchaseSubscription
  extends Promise<AsyncIterator<Purchase>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transaction: <T = TransactionSubscription>() => T;
  total: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Item {
  id: ID_Output;
  price: Float;
  amount: Int;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  user: <T = UserPromise>() => T;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  user: <T = UserSubscription>() => T;
  price: () => Promise<AsyncIterator<Float>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface Product {
  id: ID_Output;
  name: String;
  price: Float;
  index: Int;
  thumbnail?: String;
  deleted: Boolean;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  deleted: () => Promise<Boolean>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  index: () => Promise<AsyncIterator<Int>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface Transaction {
  id: ID_Output;
  date: DateTimeOutput;
  type: TransactionType;
  balance: Float;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
  balance: () => Promise<Float>;
  payment: <T = PaymentPromise>() => T;
  purchase: <T = PurchasePromise>() => T;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  balance: () => Promise<AsyncIterator<Float>>;
  payment: <T = PaymentSubscription>() => T;
  purchase: <T = PurchaseSubscription>() => T;
}

export interface Payment {
  id: ID_Output;
  amount: Float;
  date: DateTimeOutput;
  verified: Boolean;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  verified: () => Promise<Boolean>;
  transaction: <T = TransactionPromise>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  transaction: <T = TransactionSubscription>() => T;
}

export interface Post {
  id: ID_Output;
  text: String;
  image?: String;
  link?: String;
  date: DateTimeOutput;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  date: () => Promise<DateTimeOutput>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Event {
  id: ID_Output;
  title: String;
  description: String;
  date: DateTimeOutput;
  image: String;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  image: () => Promise<String>;
  supporters: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedBy: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  committee: <T = CommitteePromise>() => T;
  todos: <T = FragmentableArray<Todo>>(
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  image: () => Promise<AsyncIterator<String>>;
  supporters: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  owner: <T = UserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(
    args?: {
      where?: CommentWhereInput;
      orderBy?: CommentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  committee: <T = CommitteeSubscription>() => T;
  todos: <T = Promise<AsyncIterator<TodoSubscription>>>(
    args?: {
      where?: TodoWhereInput;
      orderBy?: TodoOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Committee {
  id: ID_Output;
}

export interface CommitteePromise extends Promise<Committee>, Fragmentable {
  id: () => Promise<ID_Output>;
  creator: <T = UserPromise>() => T;
  members: <T = FragmentableArray<User>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  event: <T = EventPromise>() => T;
  invitations: <T = FragmentableArray<Invitation>>(
    args?: {
      where?: InvitationWhereInput;
      orderBy?: InvitationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface CommitteeSubscription
  extends Promise<AsyncIterator<Committee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  creator: <T = UserSubscription>() => T;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  event: <T = EventSubscription>() => T;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(
    args?: {
      where?: InvitationWhereInput;
      orderBy?: InvitationOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface Invitation {
  id: ID_Output;
  status: InvitationStatus;
}

export interface InvitationPromise extends Promise<Invitation>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  committee: <T = CommitteePromise>() => T;
  status: () => Promise<InvitationStatus>;
}

export interface InvitationSubscription
  extends Promise<AsyncIterator<Invitation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  committee: <T = CommitteeSubscription>() => T;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
}

export interface Todo {
  id: ID_Output;
  due: DateTimeOutput;
  text: String;
  done?: Boolean;
  link?: String;
  doneAt?: DateTimeOutput;
}

export interface TodoPromise extends Promise<Todo>, Fragmentable {
  id: () => Promise<ID_Output>;
  due: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  done: () => Promise<Boolean>;
  assigned: <T = UserPromise>() => T;
  link: () => Promise<String>;
  doneBy: <T = UserPromise>() => T;
  doneAt: () => Promise<DateTimeOutput>;
  event: <T = EventPromise>() => T;
}

export interface TodoSubscription
  extends Promise<AsyncIterator<Todo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  due: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  done: () => Promise<AsyncIterator<Boolean>>;
  assigned: <T = UserSubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
  doneBy: <T = UserSubscription>() => T;
  doneAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  event: <T = EventSubscription>() => T;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommitteeConnection {
  pageInfo: PageInfo;
  edges: CommitteeEdge[];
}

export interface CommitteeConnectionPromise
  extends Promise<CommitteeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommitteeEdge>>() => T;
  aggregate: <T = AggregateCommitteePromise>() => T;
}

export interface CommitteeConnectionSubscription
  extends Promise<AsyncIterator<CommitteeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommitteeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommitteeSubscription>() => T;
}

export interface CommitteeEdge {
  node: Committee;
  cursor: String;
}

export interface CommitteeEdgePromise
  extends Promise<CommitteeEdge>,
    Fragmentable {
  node: <T = CommitteePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommitteeEdgeSubscription
  extends Promise<AsyncIterator<CommitteeEdge>>,
    Fragmentable {
  node: <T = CommitteeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCommittee {
  count: Int;
}

export interface AggregateCommitteePromise
  extends Promise<AggregateCommittee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommitteeSubscription
  extends Promise<AsyncIterator<AggregateCommittee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface File {
  id: ID_Output;
  fileId: String;
  hash: String;
  uri: String;
  filename: String;
  path: String;
  mimetype: String;
  extension: String;
  createdAt: DateTimeOutput;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileId: () => Promise<String>;
  hash: () => Promise<String>;
  uri: () => Promise<String>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileId: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  extension: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InvitationConnection {
  pageInfo: PageInfo;
  edges: InvitationEdge[];
}

export interface InvitationConnectionPromise
  extends Promise<InvitationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvitationEdge>>() => T;
  aggregate: <T = AggregateInvitationPromise>() => T;
}

export interface InvitationConnectionSubscription
  extends Promise<AsyncIterator<InvitationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvitationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvitationSubscription>() => T;
}

export interface InvitationEdge {
  node: Invitation;
  cursor: String;
}

export interface InvitationEdgePromise
  extends Promise<InvitationEdge>,
    Fragmentable {
  node: <T = InvitationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvitationEdgeSubscription
  extends Promise<AsyncIterator<InvitationEdge>>,
    Fragmentable {
  node: <T = InvitationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInvitation {
  count: Int;
}

export interface AggregateInvitationPromise
  extends Promise<AggregateInvitation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvitationSubscription
  extends Promise<AsyncIterator<AggregateInvitation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Production {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
  index: Int;
  show: Boolean;
}

export interface ProductionPromise extends Promise<Production>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  index: () => Promise<Int>;
  show: () => Promise<Boolean>;
}

export interface ProductionSubscription
  extends Promise<AsyncIterator<Production>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  index: () => Promise<AsyncIterator<Int>>;
  show: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductionConnection {
  pageInfo: PageInfo;
  edges: ProductionEdge[];
}

export interface ProductionConnectionPromise
  extends Promise<ProductionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductionEdge>>() => T;
  aggregate: <T = AggregateProductionPromise>() => T;
}

export interface ProductionConnectionSubscription
  extends Promise<AsyncIterator<ProductionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductionSubscription>() => T;
}

export interface ProductionEdge {
  node: Production;
  cursor: String;
}

export interface ProductionEdgePromise
  extends Promise<ProductionEdge>,
    Fragmentable {
  node: <T = ProductionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductionEdgeSubscription
  extends Promise<AsyncIterator<ProductionEdge>>,
    Fragmentable {
  node: <T = ProductionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduction {
  count: Int;
}

export interface AggregateProductionPromise
  extends Promise<AggregateProduction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductionSubscription
  extends Promise<AsyncIterator<AggregateProduction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PurchaseConnection {
  pageInfo: PageInfo;
  edges: PurchaseEdge[];
}

export interface PurchaseConnectionPromise
  extends Promise<PurchaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PurchaseEdge>>() => T;
  aggregate: <T = AggregatePurchasePromise>() => T;
}

export interface PurchaseConnectionSubscription
  extends Promise<AsyncIterator<PurchaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PurchaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePurchaseSubscription>() => T;
}

export interface PurchaseEdge {
  node: Purchase;
  cursor: String;
}

export interface PurchaseEdgePromise
  extends Promise<PurchaseEdge>,
    Fragmentable {
  node: <T = PurchasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PurchaseEdgeSubscription
  extends Promise<AsyncIterator<PurchaseEdge>>,
    Fragmentable {
  node: <T = PurchaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePurchase {
  count: Int;
}

export interface AggregatePurchasePromise
  extends Promise<AggregatePurchase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePurchaseSubscription
  extends Promise<AsyncIterator<AggregatePurchase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Question {
  id: ID_Output;
  text: String;
  description: String;
}

export interface QuestionPromise extends Promise<Question>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  description: () => Promise<String>;
  templates: <T = FragmentableArray<TodoTemplate>>(
    args?: {
      where?: TodoTemplateWhereInput;
      orderBy?: TodoTemplateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface QuestionSubscription
  extends Promise<AsyncIterator<Question>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  templates: <T = Promise<AsyncIterator<TodoTemplateSubscription>>>(
    args?: {
      where?: TodoTemplateWhereInput;
      orderBy?: TodoTemplateOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
}

export interface TodoTemplate {
  id: ID_Output;
  text: String;
  offsetDays: Int;
}

export interface TodoTemplatePromise
  extends Promise<TodoTemplate>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  offsetDays: () => Promise<Int>;
}

export interface TodoTemplateSubscription
  extends Promise<AsyncIterator<TodoTemplate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  offsetDays: () => Promise<AsyncIterator<Int>>;
}

export interface QuestionConnection {
  pageInfo: PageInfo;
  edges: QuestionEdge[];
}

export interface QuestionConnectionPromise
  extends Promise<QuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionEdge>>() => T;
  aggregate: <T = AggregateQuestionPromise>() => T;
}

export interface QuestionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionSubscription>() => T;
}

export interface QuestionEdge {
  node: Question;
  cursor: String;
}

export interface QuestionEdgePromise
  extends Promise<QuestionEdge>,
    Fragmentable {
  node: <T = QuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionEdgeSubscription
  extends Promise<AsyncIterator<QuestionEdge>>,
    Fragmentable {
  node: <T = QuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestion {
  count: Int;
}

export interface AggregateQuestionPromise
  extends Promise<AggregateQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionSubscription
  extends Promise<AsyncIterator<AggregateQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TodoConnection {
  pageInfo: PageInfo;
  edges: TodoEdge[];
}

export interface TodoConnectionPromise
  extends Promise<TodoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TodoEdge>>() => T;
  aggregate: <T = AggregateTodoPromise>() => T;
}

export interface TodoConnectionSubscription
  extends Promise<AsyncIterator<TodoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TodoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTodoSubscription>() => T;
}

export interface TodoEdge {
  node: Todo;
  cursor: String;
}

export interface TodoEdgePromise extends Promise<TodoEdge>, Fragmentable {
  node: <T = TodoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TodoEdgeSubscription
  extends Promise<AsyncIterator<TodoEdge>>,
    Fragmentable {
  node: <T = TodoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTodo {
  count: Int;
}

export interface AggregateTodoPromise
  extends Promise<AggregateTodo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTodoSubscription
  extends Promise<AsyncIterator<AggregateTodo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TodoTemplateConnection {
  pageInfo: PageInfo;
  edges: TodoTemplateEdge[];
}

export interface TodoTemplateConnectionPromise
  extends Promise<TodoTemplateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TodoTemplateEdge>>() => T;
  aggregate: <T = AggregateTodoTemplatePromise>() => T;
}

export interface TodoTemplateConnectionSubscription
  extends Promise<AsyncIterator<TodoTemplateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TodoTemplateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTodoTemplateSubscription>() => T;
}

export interface TodoTemplateEdge {
  node: TodoTemplate;
  cursor: String;
}

export interface TodoTemplateEdgePromise
  extends Promise<TodoTemplateEdge>,
    Fragmentable {
  node: <T = TodoTemplatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TodoTemplateEdgeSubscription
  extends Promise<AsyncIterator<TodoTemplateEdge>>,
    Fragmentable {
  node: <T = TodoTemplateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTodoTemplate {
  count: Int;
}

export interface AggregateTodoTemplatePromise
  extends Promise<AggregateTodoTemplate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTodoTemplateSubscription
  extends Promise<AsyncIterator<AggregateTodoTemplate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ClientSubscriptionPayload {
  mutation: MutationType;
  node: Client;
  updatedFields: String[];
  previousValues: ClientPreviousValues;
}

export interface ClientSubscriptionPayloadPromise
  extends Promise<ClientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClientPreviousValuesPromise>() => T;
}

export interface ClientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClientPreviousValuesSubscription>() => T;
}

export interface ClientPreviousValues {
  id: ID_Output;
  identity: String;
  secret: String;
  name: String;
  trusted: Boolean;
}

export interface ClientPreviousValuesPromise
  extends Promise<ClientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientPreviousValuesSubscription
  extends Promise<AsyncIterator<ClientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identity: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trusted: () => Promise<AsyncIterator<Boolean>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  text: String;
  date: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommitteeSubscriptionPayload {
  mutation: MutationType;
  node: Committee;
  updatedFields: String[];
  previousValues: CommitteePreviousValues;
}

export interface CommitteeSubscriptionPayloadPromise
  extends Promise<CommitteeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommitteePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommitteePreviousValuesPromise>() => T;
}

export interface CommitteeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommitteeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommitteeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommitteePreviousValuesSubscription>() => T;
}

export interface CommitteePreviousValues {
  id: ID_Output;
}

export interface CommitteePreviousValuesPromise
  extends Promise<CommitteePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CommitteePreviousValuesSubscription
  extends Promise<AsyncIterator<CommitteePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  date: DateTimeOutput;
  image: String;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  image: () => Promise<String>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  fileId: String;
  hash: String;
  uri: String;
  filename: String;
  path: String;
  mimetype: String;
  extension: String;
  createdAt: DateTimeOutput;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileId: () => Promise<String>;
  hash: () => Promise<String>;
  uri: () => Promise<String>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileId: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  extension: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InvitationSubscriptionPayload {
  mutation: MutationType;
  node: Invitation;
  updatedFields: String[];
  previousValues: InvitationPreviousValues;
}

export interface InvitationSubscriptionPayloadPromise
  extends Promise<InvitationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvitationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvitationPreviousValuesPromise>() => T;
}

export interface InvitationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvitationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvitationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvitationPreviousValuesSubscription>() => T;
}

export interface InvitationPreviousValues {
  id: ID_Output;
  status: InvitationStatus;
}

export interface InvitationPreviousValuesPromise
  extends Promise<InvitationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<InvitationStatus>;
}

export interface InvitationPreviousValuesSubscription
  extends Promise<AsyncIterator<InvitationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  price: Float;
  amount: Int;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Float>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  amount: Float;
  date: DateTimeOutput;
  verified: Boolean;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  date: () => Promise<DateTimeOutput>;
  verified: () => Promise<Boolean>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostPreviousValues {
  id: ID_Output;
  text: String;
  image?: String;
  link?: String;
  date: DateTimeOutput;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  price: Float;
  index: Int;
  thumbnail?: String;
  deleted: Boolean;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  deleted: () => Promise<Boolean>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  index: () => Promise<AsyncIterator<Int>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductionSubscriptionPayload {
  mutation: MutationType;
  node: Production;
  updatedFields: String[];
  previousValues: ProductionPreviousValues;
}

export interface ProductionSubscriptionPayloadPromise
  extends Promise<ProductionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductionPreviousValuesPromise>() => T;
}

export interface ProductionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductionPreviousValuesSubscription>() => T;
}

export interface ProductionPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
  index: Int;
  show: Boolean;
}

export interface ProductionPreviousValuesPromise
  extends Promise<ProductionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  index: () => Promise<Int>;
  show: () => Promise<Boolean>;
}

export interface ProductionPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  index: () => Promise<AsyncIterator<Int>>;
  show: () => Promise<AsyncIterator<Boolean>>;
}

export interface PurchaseSubscriptionPayload {
  mutation: MutationType;
  node: Purchase;
  updatedFields: String[];
  previousValues: PurchasePreviousValues;
}

export interface PurchaseSubscriptionPayloadPromise
  extends Promise<PurchaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PurchasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PurchasePreviousValuesPromise>() => T;
}

export interface PurchaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PurchaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PurchaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PurchasePreviousValuesSubscription>() => T;
}

export interface PurchasePreviousValues {
  id: ID_Output;
  total: Float;
  date: DateTimeOutput;
}

export interface PurchasePreviousValuesPromise
  extends Promise<PurchasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  date: () => Promise<DateTimeOutput>;
}

export interface PurchasePreviousValuesSubscription
  extends Promise<AsyncIterator<PurchasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface QuestionSubscriptionPayload {
  mutation: MutationType;
  node: Question;
  updatedFields: String[];
  previousValues: QuestionPreviousValues;
}

export interface QuestionSubscriptionPayloadPromise
  extends Promise<QuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionPreviousValuesPromise>() => T;
}

export interface QuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionPreviousValuesSubscription>() => T;
}

export interface QuestionPreviousValues {
  id: ID_Output;
  text: String;
  description: String;
}

export interface QuestionPreviousValuesPromise
  extends Promise<QuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  description: () => Promise<String>;
}

export interface QuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface TodoSubscriptionPayload {
  mutation: MutationType;
  node: Todo;
  updatedFields: String[];
  previousValues: TodoPreviousValues;
}

export interface TodoSubscriptionPayloadPromise
  extends Promise<TodoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TodoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TodoPreviousValuesPromise>() => T;
}

export interface TodoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TodoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TodoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TodoPreviousValuesSubscription>() => T;
}

export interface TodoPreviousValues {
  id: ID_Output;
  due: DateTimeOutput;
  text: String;
  done?: Boolean;
  link?: String;
  doneAt?: DateTimeOutput;
}

export interface TodoPreviousValuesPromise
  extends Promise<TodoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  due: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  done: () => Promise<Boolean>;
  link: () => Promise<String>;
  doneAt: () => Promise<DateTimeOutput>;
}

export interface TodoPreviousValuesSubscription
  extends Promise<AsyncIterator<TodoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  due: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  done: () => Promise<AsyncIterator<Boolean>>;
  link: () => Promise<AsyncIterator<String>>;
  doneAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TodoTemplateSubscriptionPayload {
  mutation: MutationType;
  node: TodoTemplate;
  updatedFields: String[];
  previousValues: TodoTemplatePreviousValues;
}

export interface TodoTemplateSubscriptionPayloadPromise
  extends Promise<TodoTemplateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TodoTemplatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TodoTemplatePreviousValuesPromise>() => T;
}

export interface TodoTemplateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TodoTemplateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TodoTemplateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TodoTemplatePreviousValuesSubscription>() => T;
}

export interface TodoTemplatePreviousValues {
  id: ID_Output;
  text: String;
  offsetDays: Int;
}

export interface TodoTemplatePreviousValuesPromise
  extends Promise<TodoTemplatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  offsetDays: () => Promise<Int>;
}

export interface TodoTemplatePreviousValuesSubscription
  extends Promise<AsyncIterator<TodoTemplatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  offsetDays: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface TransactionPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  type: TransactionType;
  balance: Float;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
  balance: () => Promise<Float>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  balance: () => Promise<AsyncIterator<Float>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  avatar?: String;
  role: UserRole;
  balance: Float;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  avatar: () => Promise<String>;
  role: () => Promise<UserRole>;
  balance: () => Promise<Float>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  balance: () => Promise<AsyncIterator<Float>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Client",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Purchase",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Production",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Committee",
    embedded: false
  },
  {
    name: "Invitation",
    embedded: false
  },
  {
    name: "Todo",
    embedded: false
  },
  {
    name: "Question",
    embedded: false
  },
  {
    name: "TodoTemplate",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "TransactionType",
    embedded: false
  },
  {
    name: "InvitationStatus",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
