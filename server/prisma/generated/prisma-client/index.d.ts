// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  client: (where?: ClientWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  committee: (where?: CommitteeWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  invitation: (where?: InvitationWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  production: (where?: ProductionWhereInput) => Promise<boolean>;
  purchase: (where?: PurchaseWhereInput) => Promise<boolean>;
  question: (where?: QuestionWhereInput) => Promise<boolean>;
  todo: (where?: TodoWhereInput) => Promise<boolean>;
  todoTemplate: (where?: TodoTemplateWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  client: (where: ClientWhereUniqueInput) => ClientNullablePromise;
  clients: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Client>;
  clientsConnection: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClientConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  committee: (where: CommitteeWhereUniqueInput) => CommitteeNullablePromise;
  committees: (args?: {
    where?: CommitteeWhereInput;
    orderBy?: CommitteeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Committee>;
  committeesConnection: (args?: {
    where?: CommitteeWhereInput;
    orderBy?: CommitteeOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommitteeConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  invitation: (where: InvitationWhereUniqueInput) => InvitationNullablePromise;
  invitations: (args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Invitation>;
  invitationsConnection: (args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => InvitationConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentNullablePromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  production: (where: ProductionWhereUniqueInput) => ProductionNullablePromise;
  productions: (args?: {
    where?: ProductionWhereInput;
    orderBy?: ProductionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Production>;
  productionsConnection: (args?: {
    where?: ProductionWhereInput;
    orderBy?: ProductionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductionConnectionPromise;
  purchase: (where: PurchaseWhereUniqueInput) => PurchaseNullablePromise;
  purchases: (args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Purchase>;
  purchasesConnection: (args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PurchaseConnectionPromise;
  question: (where: QuestionWhereUniqueInput) => QuestionNullablePromise;
  questions: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Question>;
  questionsConnection: (args?: {
    where?: QuestionWhereInput;
    orderBy?: QuestionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => QuestionConnectionPromise;
  todo: (where: TodoWhereUniqueInput) => TodoNullablePromise;
  todoes: (args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Todo>;
  todoesConnection: (args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TodoConnectionPromise;
  todoTemplate: (
    where: TodoTemplateWhereUniqueInput
  ) => TodoTemplateNullablePromise;
  todoTemplates: (args?: {
    where?: TodoTemplateWhereInput;
    orderBy?: TodoTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<TodoTemplate>;
  todoTemplatesConnection: (args?: {
    where?: TodoTemplateWhereInput;
    orderBy?: TodoTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TodoTemplateConnectionPromise;
  transaction: (
    where: TransactionWhereUniqueInput
  ) => TransactionNullablePromise;
  transactions: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transaction>;
  transactionsConnection: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TransactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createClient: (data: ClientCreateInput) => ClientPromise;
  updateClient: (args: {
    data: ClientUpdateInput;
    where: ClientWhereUniqueInput;
  }) => ClientPromise;
  updateManyClients: (args: {
    data: ClientUpdateManyMutationInput;
    where?: ClientWhereInput;
  }) => BatchPayloadPromise;
  upsertClient: (args: {
    where: ClientWhereUniqueInput;
    create: ClientCreateInput;
    update: ClientUpdateInput;
  }) => ClientPromise;
  deleteClient: (where: ClientWhereUniqueInput) => ClientPromise;
  deleteManyClients: (where?: ClientWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createCommittee: (data: CommitteeCreateInput) => CommitteePromise;
  updateCommittee: (args: {
    data: CommitteeUpdateInput;
    where: CommitteeWhereUniqueInput;
  }) => CommitteePromise;
  upsertCommittee: (args: {
    where: CommitteeWhereUniqueInput;
    create: CommitteeCreateInput;
    update: CommitteeUpdateInput;
  }) => CommitteePromise;
  deleteCommittee: (where: CommitteeWhereUniqueInput) => CommitteePromise;
  deleteManyCommittees: (where?: CommitteeWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createInvitation: (data: InvitationCreateInput) => InvitationPromise;
  updateInvitation: (args: {
    data: InvitationUpdateInput;
    where: InvitationWhereUniqueInput;
  }) => InvitationPromise;
  updateManyInvitations: (args: {
    data: InvitationUpdateManyMutationInput;
    where?: InvitationWhereInput;
  }) => BatchPayloadPromise;
  upsertInvitation: (args: {
    where: InvitationWhereUniqueInput;
    create: InvitationCreateInput;
    update: InvitationUpdateInput;
  }) => InvitationPromise;
  deleteInvitation: (where: InvitationWhereUniqueInput) => InvitationPromise;
  deleteManyInvitations: (where?: InvitationWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: {
    data: PostUpdateInput;
    where: PostWhereUniqueInput;
  }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProduction: (data: ProductionCreateInput) => ProductionPromise;
  updateProduction: (args: {
    data: ProductionUpdateInput;
    where: ProductionWhereUniqueInput;
  }) => ProductionPromise;
  updateManyProductions: (args: {
    data: ProductionUpdateManyMutationInput;
    where?: ProductionWhereInput;
  }) => BatchPayloadPromise;
  upsertProduction: (args: {
    where: ProductionWhereUniqueInput;
    create: ProductionCreateInput;
    update: ProductionUpdateInput;
  }) => ProductionPromise;
  deleteProduction: (where: ProductionWhereUniqueInput) => ProductionPromise;
  deleteManyProductions: (where?: ProductionWhereInput) => BatchPayloadPromise;
  createPurchase: (data: PurchaseCreateInput) => PurchasePromise;
  updatePurchase: (args: {
    data: PurchaseUpdateInput;
    where: PurchaseWhereUniqueInput;
  }) => PurchasePromise;
  updateManyPurchases: (args: {
    data: PurchaseUpdateManyMutationInput;
    where?: PurchaseWhereInput;
  }) => BatchPayloadPromise;
  upsertPurchase: (args: {
    where: PurchaseWhereUniqueInput;
    create: PurchaseCreateInput;
    update: PurchaseUpdateInput;
  }) => PurchasePromise;
  deletePurchase: (where: PurchaseWhereUniqueInput) => PurchasePromise;
  deleteManyPurchases: (where?: PurchaseWhereInput) => BatchPayloadPromise;
  createQuestion: (data: QuestionCreateInput) => QuestionPromise;
  updateQuestion: (args: {
    data: QuestionUpdateInput;
    where: QuestionWhereUniqueInput;
  }) => QuestionPromise;
  updateManyQuestions: (args: {
    data: QuestionUpdateManyMutationInput;
    where?: QuestionWhereInput;
  }) => BatchPayloadPromise;
  upsertQuestion: (args: {
    where: QuestionWhereUniqueInput;
    create: QuestionCreateInput;
    update: QuestionUpdateInput;
  }) => QuestionPromise;
  deleteQuestion: (where: QuestionWhereUniqueInput) => QuestionPromise;
  deleteManyQuestions: (where?: QuestionWhereInput) => BatchPayloadPromise;
  createTodo: (data: TodoCreateInput) => TodoPromise;
  updateTodo: (args: {
    data: TodoUpdateInput;
    where: TodoWhereUniqueInput;
  }) => TodoPromise;
  updateManyTodoes: (args: {
    data: TodoUpdateManyMutationInput;
    where?: TodoWhereInput;
  }) => BatchPayloadPromise;
  upsertTodo: (args: {
    where: TodoWhereUniqueInput;
    create: TodoCreateInput;
    update: TodoUpdateInput;
  }) => TodoPromise;
  deleteTodo: (where: TodoWhereUniqueInput) => TodoPromise;
  deleteManyTodoes: (where?: TodoWhereInput) => BatchPayloadPromise;
  createTodoTemplate: (data: TodoTemplateCreateInput) => TodoTemplatePromise;
  updateTodoTemplate: (args: {
    data: TodoTemplateUpdateInput;
    where: TodoTemplateWhereUniqueInput;
  }) => TodoTemplatePromise;
  updateManyTodoTemplates: (args: {
    data: TodoTemplateUpdateManyMutationInput;
    where?: TodoTemplateWhereInput;
  }) => BatchPayloadPromise;
  upsertTodoTemplate: (args: {
    where: TodoTemplateWhereUniqueInput;
    create: TodoTemplateCreateInput;
    update: TodoTemplateUpdateInput;
  }) => TodoTemplatePromise;
  deleteTodoTemplate: (
    where: TodoTemplateWhereUniqueInput
  ) => TodoTemplatePromise;
  deleteManyTodoTemplates: (
    where?: TodoTemplateWhereInput
  ) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (args: {
    data: TransactionUpdateInput;
    where: TransactionWhereUniqueInput;
  }) => TransactionPromise;
  updateManyTransactions: (args: {
    data: TransactionUpdateManyMutationInput;
    where?: TransactionWhereInput;
  }) => BatchPayloadPromise;
  upsertTransaction: (args: {
    where: TransactionWhereUniqueInput;
    create: TransactionCreateInput;
    update: TransactionUpdateInput;
  }) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  client: (
    where?: ClientSubscriptionWhereInput
  ) => ClientSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  committee: (
    where?: CommitteeSubscriptionWhereInput
  ) => CommitteeSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  invitation: (
    where?: InvitationSubscriptionWhereInput
  ) => InvitationSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  production: (
    where?: ProductionSubscriptionWhereInput
  ) => ProductionSubscriptionPayloadSubscription;
  purchase: (
    where?: PurchaseSubscriptionWhereInput
  ) => PurchaseSubscriptionPayloadSubscription;
  question: (
    where?: QuestionSubscriptionWhereInput
  ) => QuestionSubscriptionPayloadSubscription;
  todo: (
    where?: TodoSubscriptionWhereInput
  ) => TodoSubscriptionPayloadSubscription;
  todoTemplate: (
    where?: TodoTemplateSubscriptionWhereInput
  ) => TodoTemplateSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ClientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "identity_ASC"
  | "identity_DESC"
  | "secret_ASC"
  | "secret_DESC"
  | "name_ASC"
  | "name_DESC"
  | "trusted_ASC"
  | "trusted_DESC";

export type TransactionType = "PAYMENT" | "PURCHASE";

export type UserRole = "SUPER" | "ADMIN" | "MEMBER";

export type InvitationStatus = "PENDING" | "ACCEPTED" | "DECLINED";

export type PurchaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_ASC"
  | "total_DESC"
  | "date_ASC"
  | "date_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "date_ASC"
  | "date_DESC"
  | "verified_ASC"
  | "verified_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "type_ASC"
  | "type_DESC"
  | "balance_ASC"
  | "balance_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "image_ASC"
  | "image_DESC"
  | "link_ASC"
  | "link_DESC"
  | "date_ASC"
  | "date_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "role_ASC"
  | "role_DESC"
  | "balance_ASC"
  | "balance_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "date_ASC"
  | "date_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "date_ASC"
  | "date_DESC"
  | "image_ASC"
  | "image_DESC";

export type InvitationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "status_ASC"
  | "status_DESC";

export type TodoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "due_ASC"
  | "due_DESC"
  | "text_ASC"
  | "text_DESC"
  | "done_ASC"
  | "done_DESC"
  | "link_ASC"
  | "link_DESC"
  | "doneAt_ASC"
  | "doneAt_DESC";

export type CommitteeOrderByInput = "id_ASC" | "id_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fileId_ASC"
  | "fileId_DESC"
  | "hash_ASC"
  | "hash_DESC"
  | "uri_ASC"
  | "uri_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "path_ASC"
  | "path_DESC"
  | "mimetype_ASC"
  | "mimetype_DESC"
  | "extension_ASC"
  | "extension_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "index_ASC"
  | "index_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC"
  | "deleted_ASC"
  | "deleted_DESC";

export type ProductionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "image_ASC"
  | "image_DESC"
  | "index_ASC"
  | "index_DESC"
  | "show_ASC"
  | "show_DESC";

export type TodoTemplateOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "offsetDays_ASC"
  | "offsetDays_DESC";

export type QuestionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "description_ASC"
  | "description_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ClientWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  identity?: Maybe<String>;
}>;

export interface ClientWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  identity?: Maybe<String>;
  identity_not?: Maybe<String>;
  identity_in?: Maybe<String[] | String>;
  identity_not_in?: Maybe<String[] | String>;
  identity_lt?: Maybe<String>;
  identity_lte?: Maybe<String>;
  identity_gt?: Maybe<String>;
  identity_gte?: Maybe<String>;
  identity_contains?: Maybe<String>;
  identity_not_contains?: Maybe<String>;
  identity_starts_with?: Maybe<String>;
  identity_not_starts_with?: Maybe<String>;
  identity_ends_with?: Maybe<String>;
  identity_not_ends_with?: Maybe<String>;
  secret?: Maybe<String>;
  secret_not?: Maybe<String>;
  secret_in?: Maybe<String[] | String>;
  secret_not_in?: Maybe<String[] | String>;
  secret_lt?: Maybe<String>;
  secret_lte?: Maybe<String>;
  secret_gt?: Maybe<String>;
  secret_gte?: Maybe<String>;
  secret_contains?: Maybe<String>;
  secret_not_contains?: Maybe<String>;
  secret_starts_with?: Maybe<String>;
  secret_not_starts_with?: Maybe<String>;
  secret_ends_with?: Maybe<String>;
  secret_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  trusted?: Maybe<Boolean>;
  trusted_not?: Maybe<Boolean>;
  AND?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  OR?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  NOT?: Maybe<ClientWhereInput[] | ClientWhereInput>;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PurchaseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  transaction?: Maybe<TransactionWhereInput>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  user?: Maybe<UserWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PurchaseWhereInput[] | PurchaseWhereInput>;
  OR?: Maybe<PurchaseWhereInput[] | PurchaseWhereInput>;
  NOT?: Maybe<PurchaseWhereInput[] | PurchaseWhereInput>;
}

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  product?: Maybe<ProductWhereInput>;
  user?: Maybe<UserWhereInput>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  index?: Maybe<Int>;
  index_not?: Maybe<Int>;
  index_in?: Maybe<Int[] | Int>;
  index_not_in?: Maybe<Int[] | Int>;
  index_lt?: Maybe<Int>;
  index_lte?: Maybe<Int>;
  index_gt?: Maybe<Int>;
  index_gte?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  thumbnail_not?: Maybe<String>;
  thumbnail_in?: Maybe<String[] | String>;
  thumbnail_not_in?: Maybe<String[] | String>;
  thumbnail_lt?: Maybe<String>;
  thumbnail_lte?: Maybe<String>;
  thumbnail_gt?: Maybe<String>;
  thumbnail_gte?: Maybe<String>;
  thumbnail_contains?: Maybe<String>;
  thumbnail_not_contains?: Maybe<String>;
  thumbnail_starts_with?: Maybe<String>;
  thumbnail_not_starts_with?: Maybe<String>;
  thumbnail_ends_with?: Maybe<String>;
  thumbnail_not_ends_with?: Maybe<String>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  purchases_every?: Maybe<PurchaseWhereInput>;
  purchases_some?: Maybe<PurchaseWhereInput>;
  purchases_none?: Maybe<PurchaseWhereInput>;
  payments_every?: Maybe<PaymentWhereInput>;
  payments_some?: Maybe<PaymentWhereInput>;
  payments_none?: Maybe<PaymentWhereInput>;
  transactions_every?: Maybe<TransactionWhereInput>;
  transactions_some?: Maybe<TransactionWhereInput>;
  transactions_none?: Maybe<TransactionWhereInput>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  balance?: Maybe<Float>;
  balance_not?: Maybe<Float>;
  balance_in?: Maybe<Float[] | Float>;
  balance_not_in?: Maybe<Float[] | Float>;
  balance_lt?: Maybe<Float>;
  balance_lte?: Maybe<Float>;
  balance_gt?: Maybe<Float>;
  balance_gte?: Maybe<Float>;
  posts_every?: Maybe<PostWhereInput>;
  posts_some?: Maybe<PostWhereInput>;
  posts_none?: Maybe<PostWhereInput>;
  likedPosts_every?: Maybe<PostWhereInput>;
  likedPosts_some?: Maybe<PostWhereInput>;
  likedPosts_none?: Maybe<PostWhereInput>;
  likedEvents_every?: Maybe<EventWhereInput>;
  likedEvents_some?: Maybe<EventWhereInput>;
  likedEvents_none?: Maybe<EventWhereInput>;
  supportedEvents_every?: Maybe<EventWhereInput>;
  supportedEvents_some?: Maybe<EventWhereInput>;
  supportedEvents_none?: Maybe<EventWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  likedComments_every?: Maybe<CommentWhereInput>;
  likedComments_some?: Maybe<CommentWhereInput>;
  likedComments_none?: Maybe<CommentWhereInput>;
  invitations_every?: Maybe<InvitationWhereInput>;
  invitations_some?: Maybe<InvitationWhereInput>;
  invitations_none?: Maybe<InvitationWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface PaymentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  user?: Maybe<UserWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  transaction?: Maybe<TransactionWhereInput>;
  AND?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  OR?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  NOT?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
}

export interface TransactionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  type_not?: Maybe<TransactionType>;
  type_in?: Maybe<TransactionType[] | TransactionType>;
  type_not_in?: Maybe<TransactionType[] | TransactionType>;
  balance?: Maybe<Float>;
  balance_not?: Maybe<Float>;
  balance_in?: Maybe<Float[] | Float>;
  balance_not_in?: Maybe<Float[] | Float>;
  balance_lt?: Maybe<Float>;
  balance_lte?: Maybe<Float>;
  balance_gt?: Maybe<Float>;
  balance_gte?: Maybe<Float>;
  payment?: Maybe<PaymentWhereInput>;
  purchase?: Maybe<PurchaseWhereInput>;
  AND?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  OR?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  NOT?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
}

export interface PostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  likedBy_every?: Maybe<UserWhereInput>;
  likedBy_some?: Maybe<UserWhereInput>;
  likedBy_none?: Maybe<UserWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
  OR?: Maybe<PostWhereInput[] | PostWhereInput>;
  NOT?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  author?: Maybe<UserWhereInput>;
  likedBy_every?: Maybe<UserWhereInput>;
  likedBy_some?: Maybe<UserWhereInput>;
  likedBy_none?: Maybe<UserWhereInput>;
  post?: Maybe<PostWhereInput>;
  event?: Maybe<EventWhereInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  supporters_every?: Maybe<UserWhereInput>;
  supporters_some?: Maybe<UserWhereInput>;
  supporters_none?: Maybe<UserWhereInput>;
  likedBy_every?: Maybe<UserWhereInput>;
  likedBy_some?: Maybe<UserWhereInput>;
  likedBy_none?: Maybe<UserWhereInput>;
  owner?: Maybe<UserWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  committee?: Maybe<CommitteeWhereInput>;
  todos_every?: Maybe<TodoWhereInput>;
  todos_some?: Maybe<TodoWhereInput>;
  todos_none?: Maybe<TodoWhereInput>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface CommitteeWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  creator?: Maybe<UserWhereInput>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  event?: Maybe<EventWhereInput>;
  invitations_every?: Maybe<InvitationWhereInput>;
  invitations_some?: Maybe<InvitationWhereInput>;
  invitations_none?: Maybe<InvitationWhereInput>;
  AND?: Maybe<CommitteeWhereInput[] | CommitteeWhereInput>;
  OR?: Maybe<CommitteeWhereInput[] | CommitteeWhereInput>;
  NOT?: Maybe<CommitteeWhereInput[] | CommitteeWhereInput>;
}

export interface InvitationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  committee?: Maybe<CommitteeWhereInput>;
  status?: Maybe<InvitationStatus>;
  status_not?: Maybe<InvitationStatus>;
  status_in?: Maybe<InvitationStatus[] | InvitationStatus>;
  status_not_in?: Maybe<InvitationStatus[] | InvitationStatus>;
  AND?: Maybe<InvitationWhereInput[] | InvitationWhereInput>;
  OR?: Maybe<InvitationWhereInput[] | InvitationWhereInput>;
  NOT?: Maybe<InvitationWhereInput[] | InvitationWhereInput>;
}

export interface TodoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  due?: Maybe<DateTimeInput>;
  due_not?: Maybe<DateTimeInput>;
  due_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  due_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  due_lt?: Maybe<DateTimeInput>;
  due_lte?: Maybe<DateTimeInput>;
  due_gt?: Maybe<DateTimeInput>;
  due_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  done?: Maybe<Boolean>;
  done_not?: Maybe<Boolean>;
  assigned?: Maybe<UserWhereInput>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  doneBy?: Maybe<UserWhereInput>;
  doneAt?: Maybe<DateTimeInput>;
  doneAt_not?: Maybe<DateTimeInput>;
  doneAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  doneAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  doneAt_lt?: Maybe<DateTimeInput>;
  doneAt_lte?: Maybe<DateTimeInput>;
  doneAt_gt?: Maybe<DateTimeInput>;
  doneAt_gte?: Maybe<DateTimeInput>;
  event?: Maybe<EventWhereInput>;
  AND?: Maybe<TodoWhereInput[] | TodoWhereInput>;
  OR?: Maybe<TodoWhereInput[] | TodoWhereInput>;
  NOT?: Maybe<TodoWhereInput[] | TodoWhereInput>;
}

export type CommitteeWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  fileId?: Maybe<String>;
  hash?: Maybe<String>;
  uri?: Maybe<String>;
}>;

export interface FileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileId?: Maybe<String>;
  fileId_not?: Maybe<String>;
  fileId_in?: Maybe<String[] | String>;
  fileId_not_in?: Maybe<String[] | String>;
  fileId_lt?: Maybe<String>;
  fileId_lte?: Maybe<String>;
  fileId_gt?: Maybe<String>;
  fileId_gte?: Maybe<String>;
  fileId_contains?: Maybe<String>;
  fileId_not_contains?: Maybe<String>;
  fileId_starts_with?: Maybe<String>;
  fileId_not_starts_with?: Maybe<String>;
  fileId_ends_with?: Maybe<String>;
  fileId_not_ends_with?: Maybe<String>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  path?: Maybe<String>;
  path_not?: Maybe<String>;
  path_in?: Maybe<String[] | String>;
  path_not_in?: Maybe<String[] | String>;
  path_lt?: Maybe<String>;
  path_lte?: Maybe<String>;
  path_gt?: Maybe<String>;
  path_gte?: Maybe<String>;
  path_contains?: Maybe<String>;
  path_not_contains?: Maybe<String>;
  path_starts_with?: Maybe<String>;
  path_not_starts_with?: Maybe<String>;
  path_ends_with?: Maybe<String>;
  path_not_ends_with?: Maybe<String>;
  mimetype?: Maybe<String>;
  mimetype_not?: Maybe<String>;
  mimetype_in?: Maybe<String[] | String>;
  mimetype_not_in?: Maybe<String[] | String>;
  mimetype_lt?: Maybe<String>;
  mimetype_lte?: Maybe<String>;
  mimetype_gt?: Maybe<String>;
  mimetype_gte?: Maybe<String>;
  mimetype_contains?: Maybe<String>;
  mimetype_not_contains?: Maybe<String>;
  mimetype_starts_with?: Maybe<String>;
  mimetype_not_starts_with?: Maybe<String>;
  mimetype_ends_with?: Maybe<String>;
  mimetype_not_ends_with?: Maybe<String>;
  extension?: Maybe<String>;
  extension_not?: Maybe<String>;
  extension_in?: Maybe<String[] | String>;
  extension_not_in?: Maybe<String[] | String>;
  extension_lt?: Maybe<String>;
  extension_lte?: Maybe<String>;
  extension_gt?: Maybe<String>;
  extension_gte?: Maybe<String>;
  extension_contains?: Maybe<String>;
  extension_not_contains?: Maybe<String>;
  extension_starts_with?: Maybe<String>;
  extension_not_starts_with?: Maybe<String>;
  extension_ends_with?: Maybe<String>;
  extension_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
  OR?: Maybe<FileWhereInput[] | FileWhereInput>;
  NOT?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export type InvitationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  index?: Maybe<Int>;
  index_not?: Maybe<Int>;
  index_in?: Maybe<Int[] | Int>;
  index_not_in?: Maybe<Int[] | Int>;
  index_lt?: Maybe<Int>;
  index_lte?: Maybe<Int>;
  index_gt?: Maybe<Int>;
  index_gte?: Maybe<Int>;
  show?: Maybe<Boolean>;
  show_not?: Maybe<Boolean>;
  AND?: Maybe<ProductionWhereInput[] | ProductionWhereInput>;
  OR?: Maybe<ProductionWhereInput[] | ProductionWhereInput>;
  NOT?: Maybe<ProductionWhereInput[] | ProductionWhereInput>;
}

export type PurchaseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type QuestionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TodoTemplateWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  offsetDays?: Maybe<Int>;
  offsetDays_not?: Maybe<Int>;
  offsetDays_in?: Maybe<Int[] | Int>;
  offsetDays_not_in?: Maybe<Int[] | Int>;
  offsetDays_lt?: Maybe<Int>;
  offsetDays_lte?: Maybe<Int>;
  offsetDays_gt?: Maybe<Int>;
  offsetDays_gte?: Maybe<Int>;
  AND?: Maybe<TodoTemplateWhereInput[] | TodoTemplateWhereInput>;
  OR?: Maybe<TodoTemplateWhereInput[] | TodoTemplateWhereInput>;
  NOT?: Maybe<TodoTemplateWhereInput[] | TodoTemplateWhereInput>;
}

export interface QuestionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  templates_every?: Maybe<TodoTemplateWhereInput>;
  templates_some?: Maybe<TodoTemplateWhereInput>;
  templates_none?: Maybe<TodoTemplateWhereInput>;
  AND?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  OR?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
  NOT?: Maybe<QuestionWhereInput[] | QuestionWhereInput>;
}

export type TodoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TodoTemplateWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ClientCreateInput {
  identity: String;
  secret: String;
  name: String;
  trusted?: Maybe<Boolean>;
}

export interface ClientUpdateInput {
  identity?: Maybe<String>;
  secret?: Maybe<String>;
  name?: Maybe<String>;
  trusted?: Maybe<Boolean>;
}

export interface ClientUpdateManyMutationInput {
  identity?: Maybe<String>;
  secret?: Maybe<String>;
  name?: Maybe<String>;
  trusted?: Maybe<Boolean>;
}

export interface CommentCreateInput {
  text: String;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostCreateOneWithoutCommentsInput>;
  event?: Maybe<EventCreateOneWithoutCommentsInput>;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCommentsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface PurchaseCreateManyWithoutUserInput {
  create?: Maybe<
    PurchaseCreateWithoutUserInput[] | PurchaseCreateWithoutUserInput
  >;
  connect?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
}

export interface PurchaseCreateWithoutUserInput {
  items?: Maybe<ItemCreateManyInput>;
  transaction: TransactionCreateOneWithoutPurchaseInput;
  total: Float;
  date: DateTimeInput;
}

export interface ItemCreateManyInput {
  create?: Maybe<ItemCreateInput[] | ItemCreateInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface ItemCreateInput {
  product: ProductCreateOneInput;
  user: UserCreateOneWithoutItemsInput;
  price: Float;
  amount: Int;
}

export interface ProductCreateOneInput {
  create?: Maybe<ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductCreateInput {
  name: String;
  price: Float;
  index: Int;
  thumbnail?: Maybe<String>;
  deleted?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutItemsInput {
  create?: Maybe<UserCreateWithoutItemsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutItemsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface PaymentCreateManyWithoutUserInput {
  create?: Maybe<
    PaymentCreateWithoutUserInput[] | PaymentCreateWithoutUserInput
  >;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutUserInput {
  amount: Float;
  date: DateTimeInput;
  verified?: Maybe<Boolean>;
  transaction: TransactionCreateOneWithoutPaymentInput;
}

export interface TransactionCreateOneWithoutPaymentInput {
  create?: Maybe<TransactionCreateWithoutPaymentInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface TransactionCreateWithoutPaymentInput {
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  purchase?: Maybe<PurchaseCreateOneWithoutTransactionInput>;
}

export interface UserCreateOneWithoutTransactionsInput {
  create?: Maybe<UserCreateWithoutTransactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutTransactionsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface ItemCreateManyWithoutUserInput {
  create?: Maybe<ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface ItemCreateWithoutUserInput {
  product: ProductCreateOneInput;
  price: Float;
  amount: Int;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface PostCreateWithoutAuthorInput {
  text: String;
  image?: Maybe<String>;
  link?: Maybe<String>;
  likedBy?: Maybe<UserCreateManyWithoutLikedPostsInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  date: DateTimeInput;
}

export interface UserCreateManyWithoutLikedPostsInput {
  create?: Maybe<
    UserCreateWithoutLikedPostsInput[] | UserCreateWithoutLikedPostsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutLikedPostsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface TransactionCreateManyWithoutUserInput {
  create?: Maybe<
    TransactionCreateWithoutUserInput[] | TransactionCreateWithoutUserInput
  >;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
}

export interface TransactionCreateWithoutUserInput {
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  payment?: Maybe<PaymentCreateOneWithoutTransactionInput>;
  purchase?: Maybe<PurchaseCreateOneWithoutTransactionInput>;
}

export interface PaymentCreateOneWithoutTransactionInput {
  create?: Maybe<PaymentCreateWithoutTransactionInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutTransactionInput {
  amount: Float;
  user: UserCreateOneWithoutPaymentsInput;
  date: DateTimeInput;
  verified?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutPaymentsInput {
  create?: Maybe<UserCreateWithoutPaymentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPaymentsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface PostCreateManyWithoutLikedByInput {
  create?: Maybe<
    PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput
  >;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface PostCreateWithoutLikedByInput {
  text: String;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author: UserCreateOneWithoutPostsInput;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  date: DateTimeInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPostsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface EventCreateManyWithoutLikedByInput {
  create?: Maybe<
    EventCreateWithoutLikedByInput[] | EventCreateWithoutLikedByInput
  >;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface EventCreateWithoutLikedByInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: Maybe<UserCreateManyWithoutSupportedEventsInput>;
  owner: UserCreateOneInput;
  comments?: Maybe<CommentCreateManyWithoutEventInput>;
  committee: CommitteeCreateOneWithoutEventInput;
  todos?: Maybe<TodoCreateManyWithoutEventInput>;
}

export interface UserCreateManyWithoutSupportedEventsInput {
  create?: Maybe<
    | UserCreateWithoutSupportedEventsInput[]
    | UserCreateWithoutSupportedEventsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutSupportedEventsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface CommentCreateManyWithoutAuthorInput {
  create?: Maybe<
    CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutAuthorInput {
  text: String;
  date: DateTimeInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostCreateOneWithoutCommentsInput>;
  event?: Maybe<EventCreateOneWithoutCommentsInput>;
}

export interface UserCreateManyWithoutLikedCommentsInput {
  create?: Maybe<
    UserCreateWithoutLikedCommentsInput[] | UserCreateWithoutLikedCommentsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutLikedCommentsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface EventCreateManyWithoutSupportersInput {
  create?: Maybe<
    EventCreateWithoutSupportersInput[] | EventCreateWithoutSupportersInput
  >;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface EventCreateWithoutSupportersInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  likedBy?: Maybe<UserCreateManyWithoutLikedEventsInput>;
  owner: UserCreateOneInput;
  comments?: Maybe<CommentCreateManyWithoutEventInput>;
  committee: CommitteeCreateOneWithoutEventInput;
  todos?: Maybe<TodoCreateManyWithoutEventInput>;
}

export interface UserCreateManyWithoutLikedEventsInput {
  create?: Maybe<
    UserCreateWithoutLikedEventsInput[] | UserCreateWithoutLikedEventsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutLikedEventsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface CommentCreateManyWithoutLikedByInput {
  create?: Maybe<
    CommentCreateWithoutLikedByInput[] | CommentCreateWithoutLikedByInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutLikedByInput {
  text: String;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  post?: Maybe<PostCreateOneWithoutCommentsInput>;
  event?: Maybe<EventCreateOneWithoutCommentsInput>;
}

export interface PostCreateOneWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostCreateWithoutCommentsInput {
  text: String;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author: UserCreateOneWithoutPostsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedPostsInput>;
  date: DateTimeInput;
}

export interface EventCreateOneWithoutCommentsInput {
  create?: Maybe<EventCreateWithoutCommentsInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventCreateWithoutCommentsInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: Maybe<UserCreateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikedEventsInput>;
  owner: UserCreateOneInput;
  committee: CommitteeCreateOneWithoutEventInput;
  todos?: Maybe<TodoCreateManyWithoutEventInput>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface InvitationCreateManyWithoutUserInput {
  create?: Maybe<
    InvitationCreateWithoutUserInput[] | InvitationCreateWithoutUserInput
  >;
  connect?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
}

export interface InvitationCreateWithoutUserInput {
  committee: CommitteeCreateOneWithoutInvitationsInput;
  status?: Maybe<InvitationStatus>;
}

export interface CommitteeCreateOneWithoutInvitationsInput {
  create?: Maybe<CommitteeCreateWithoutInvitationsInput>;
  connect?: Maybe<CommitteeWhereUniqueInput>;
}

export interface CommitteeCreateWithoutInvitationsInput {
  creator: UserCreateOneInput;
  members?: Maybe<UserCreateManyInput>;
  event: EventCreateOneWithoutCommitteeInput;
}

export interface UserCreateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface EventCreateOneWithoutCommitteeInput {
  create?: Maybe<EventCreateWithoutCommitteeInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventCreateWithoutCommitteeInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: Maybe<UserCreateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikedEventsInput>;
  owner: UserCreateOneInput;
  comments?: Maybe<CommentCreateManyWithoutEventInput>;
  todos?: Maybe<TodoCreateManyWithoutEventInput>;
}

export interface CommentCreateManyWithoutEventInput {
  create?: Maybe<
    CommentCreateWithoutEventInput[] | CommentCreateWithoutEventInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutEventInput {
  text: String;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostCreateOneWithoutCommentsInput>;
}

export interface TodoCreateManyWithoutEventInput {
  create?: Maybe<TodoCreateWithoutEventInput[] | TodoCreateWithoutEventInput>;
  connect?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
}

export interface TodoCreateWithoutEventInput {
  due: DateTimeInput;
  text: String;
  done?: Maybe<Boolean>;
  assigned?: Maybe<UserCreateOneInput>;
  link?: Maybe<String>;
  doneBy?: Maybe<UserCreateOneInput>;
  doneAt?: Maybe<DateTimeInput>;
}

export interface CommitteeCreateOneWithoutEventInput {
  create?: Maybe<CommitteeCreateWithoutEventInput>;
  connect?: Maybe<CommitteeWhereUniqueInput>;
}

export interface CommitteeCreateWithoutEventInput {
  creator: UserCreateOneInput;
  members?: Maybe<UserCreateManyInput>;
  invitations?: Maybe<InvitationCreateManyWithoutCommitteeInput>;
}

export interface InvitationCreateManyWithoutCommitteeInput {
  create?: Maybe<
    | InvitationCreateWithoutCommitteeInput[]
    | InvitationCreateWithoutCommitteeInput
  >;
  connect?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
}

export interface InvitationCreateWithoutCommitteeInput {
  user: UserCreateOneWithoutInvitationsInput;
  status?: Maybe<InvitationStatus>;
}

export interface UserCreateOneWithoutInvitationsInput {
  create?: Maybe<UserCreateWithoutInvitationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutInvitationsInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
}

export interface CommentCreateManyWithoutPostInput {
  create?: Maybe<
    CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutPostInput {
  text: String;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedCommentsInput>;
  event?: Maybe<EventCreateOneWithoutCommentsInput>;
}

export interface PurchaseCreateOneWithoutTransactionInput {
  create?: Maybe<PurchaseCreateWithoutTransactionInput>;
  connect?: Maybe<PurchaseWhereUniqueInput>;
}

export interface PurchaseCreateWithoutTransactionInput {
  items?: Maybe<ItemCreateManyInput>;
  total: Float;
  user: UserCreateOneWithoutPurchasesInput;
  date: DateTimeInput;
}

export interface UserCreateOneWithoutPurchasesInput {
  create?: Maybe<UserCreateWithoutPurchasesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPurchasesInput {
  name: String;
  email: String;
  password: String;
  avatar?: Maybe<String>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationCreateManyWithoutUserInput>;
}

export interface TransactionCreateOneWithoutPurchaseInput {
  create?: Maybe<TransactionCreateWithoutPurchaseInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface TransactionCreateWithoutPurchaseInput {
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  payment?: Maybe<PaymentCreateOneWithoutTransactionInput>;
}

export interface CommentUpdateInput {
  text?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostUpdateOneWithoutCommentsInput>;
  event?: Maybe<EventUpdateOneWithoutCommentsInput>;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  update?: Maybe<UserUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCommentsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface PurchaseUpdateManyWithoutUserInput {
  create?: Maybe<
    PurchaseCreateWithoutUserInput[] | PurchaseCreateWithoutUserInput
  >;
  delete?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  connect?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  set?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  disconnect?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  update?: Maybe<
    | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    | PurchaseUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    | PurchaseUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
  updateMany?: Maybe<
    | PurchaseUpdateManyWithWhereNestedInput[]
    | PurchaseUpdateManyWithWhereNestedInput
  >;
}

export interface PurchaseUpdateWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput;
  data: PurchaseUpdateWithoutUserDataInput;
}

export interface PurchaseUpdateWithoutUserDataInput {
  items?: Maybe<ItemUpdateManyInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutPurchaseInput>;
  total?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface ItemUpdateManyInput {
  create?: Maybe<ItemCreateInput[] | ItemCreateInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueNestedInput[]
    | ItemUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueNestedInput[]
    | ItemUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateDataInput;
}

export interface ItemUpdateDataInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutItemsInput>;
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface ProductUpdateOneRequiredInput {
  create?: Maybe<ProductCreateInput>;
  update?: Maybe<ProductUpdateDataInput>;
  upsert?: Maybe<ProductUpsertNestedInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductUpdateDataInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  index?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  deleted?: Maybe<Boolean>;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface UserUpdateOneRequiredWithoutItemsInput {
  create?: Maybe<UserCreateWithoutItemsInput>;
  update?: Maybe<UserUpdateWithoutItemsDataInput>;
  upsert?: Maybe<UserUpsertWithoutItemsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutItemsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface PaymentUpdateManyWithoutUserInput {
  create?: Maybe<
    PaymentCreateWithoutUserInput[] | PaymentCreateWithoutUserInput
  >;
  delete?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  set?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  disconnect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  update?: Maybe<
    | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    | PaymentUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    | PaymentUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  updateMany?: Maybe<
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput
  >;
}

export interface PaymentUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutUserDataInput;
}

export interface PaymentUpdateWithoutUserDataInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutPaymentInput>;
}

export interface TransactionUpdateOneRequiredWithoutPaymentInput {
  create?: Maybe<TransactionCreateWithoutPaymentInput>;
  update?: Maybe<TransactionUpdateWithoutPaymentDataInput>;
  upsert?: Maybe<TransactionUpsertWithoutPaymentInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface TransactionUpdateWithoutPaymentDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
  purchase?: Maybe<PurchaseUpdateOneWithoutTransactionInput>;
}

export interface UserUpdateOneRequiredWithoutTransactionsInput {
  create?: Maybe<UserCreateWithoutTransactionsInput>;
  update?: Maybe<UserUpdateWithoutTransactionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutTransactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutTransactionsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface ItemUpdateManyWithoutUserInput {
  create?: Maybe<ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput>;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutUserInput[]
    | ItemUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutUserInput[]
    | ItemUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutUserDataInput;
}

export interface ItemUpdateWithoutUserDataInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface ItemUpsertWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutUserDataInput;
  create: ItemCreateWithoutUserInput;
}

export interface ItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface ItemUpdateManyDataInput {
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface PostUpdateWithoutAuthorDataInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedPostsInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpdateManyWithoutLikedPostsInput {
  create?: Maybe<
    UserCreateWithoutLikedPostsInput[] | UserCreateWithoutLikedPostsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutLikedPostsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedPostsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutLikedPostsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedPostsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedPostsDataInput;
}

export interface UserUpdateWithoutLikedPostsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface TransactionUpdateManyWithoutUserInput {
  create?: Maybe<
    TransactionCreateWithoutUserInput[] | TransactionCreateWithoutUserInput
  >;
  delete?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  set?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  disconnect?: Maybe<
    TransactionWhereUniqueInput[] | TransactionWhereUniqueInput
  >;
  update?: Maybe<
    | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    | TransactionUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    | TransactionUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    TransactionScalarWhereInput[] | TransactionScalarWhereInput
  >;
  updateMany?: Maybe<
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput
  >;
}

export interface TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutUserDataInput;
}

export interface TransactionUpdateWithoutUserDataInput {
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
  payment?: Maybe<PaymentUpdateOneWithoutTransactionInput>;
  purchase?: Maybe<PurchaseUpdateOneWithoutTransactionInput>;
}

export interface PaymentUpdateOneWithoutTransactionInput {
  create?: Maybe<PaymentCreateWithoutTransactionInput>;
  update?: Maybe<PaymentUpdateWithoutTransactionDataInput>;
  upsert?: Maybe<PaymentUpsertWithoutTransactionInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentUpdateWithoutTransactionDataInput {
  amount?: Maybe<Float>;
  user?: Maybe<UserUpdateOneRequiredWithoutPaymentsInput>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
}

export interface UserUpdateOneRequiredWithoutPaymentsInput {
  create?: Maybe<UserCreateWithoutPaymentsInput>;
  update?: Maybe<UserUpdateWithoutPaymentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPaymentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPaymentsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface PostUpdateManyWithoutLikedByInput {
  create?: Maybe<
    PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput
  >;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutLikedByInput[]
    | PostUpdateWithWhereUniqueWithoutLikedByInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutLikedByInput[]
    | PostUpsertWithWhereUniqueWithoutLikedByInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpdateWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutLikedByDataInput;
}

export interface PostUpdateWithoutLikedByDataInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  update?: Maybe<UserUpdateWithoutPostsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPostsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface EventUpdateManyWithoutLikedByInput {
  create?: Maybe<
    EventCreateWithoutLikedByInput[] | EventCreateWithoutLikedByInput
  >;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutLikedByInput[]
    | EventUpdateWithWhereUniqueWithoutLikedByInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutLikedByInput[]
    | EventUpsertWithWhereUniqueWithoutLikedByInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpdateWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutLikedByDataInput;
}

export interface EventUpdateWithoutLikedByDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  supporters?: Maybe<UserUpdateManyWithoutSupportedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  comments?: Maybe<CommentUpdateManyWithoutEventInput>;
  committee?: Maybe<CommitteeUpdateOneRequiredWithoutEventInput>;
  todos?: Maybe<TodoUpdateManyWithoutEventInput>;
}

export interface UserUpdateManyWithoutSupportedEventsInput {
  create?: Maybe<
    | UserCreateWithoutSupportedEventsInput[]
    | UserCreateWithoutSupportedEventsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutSupportedEventsInput[]
    | UserUpdateWithWhereUniqueWithoutSupportedEventsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutSupportedEventsInput[]
    | UserUpsertWithWhereUniqueWithoutSupportedEventsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutSupportedEventsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSupportedEventsDataInput;
}

export interface UserUpdateWithoutSupportedEventsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface CommentUpdateManyWithoutAuthorInput {
  create?: Maybe<
    CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    | CommentUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    | CommentUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutAuthorDataInput;
}

export interface CommentUpdateWithoutAuthorDataInput {
  text?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostUpdateOneWithoutCommentsInput>;
  event?: Maybe<EventUpdateOneWithoutCommentsInput>;
}

export interface UserUpdateManyWithoutLikedCommentsInput {
  create?: Maybe<
    UserCreateWithoutLikedCommentsInput[] | UserCreateWithoutLikedCommentsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutLikedCommentsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedCommentsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutLikedCommentsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedCommentsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedCommentsDataInput;
}

export interface UserUpdateWithoutLikedCommentsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface EventUpdateManyWithoutSupportersInput {
  create?: Maybe<
    EventCreateWithoutSupportersInput[] | EventCreateWithoutSupportersInput
  >;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutSupportersInput[]
    | EventUpdateWithWhereUniqueWithoutSupportersInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutSupportersInput[]
    | EventUpsertWithWhereUniqueWithoutSupportersInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpdateWithWhereUniqueWithoutSupportersInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutSupportersDataInput;
}

export interface EventUpdateWithoutSupportersDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  comments?: Maybe<CommentUpdateManyWithoutEventInput>;
  committee?: Maybe<CommitteeUpdateOneRequiredWithoutEventInput>;
  todos?: Maybe<TodoUpdateManyWithoutEventInput>;
}

export interface UserUpdateManyWithoutLikedEventsInput {
  create?: Maybe<
    UserCreateWithoutLikedEventsInput[] | UserCreateWithoutLikedEventsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutLikedEventsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedEventsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutLikedEventsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedEventsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedEventsDataInput;
}

export interface UserUpdateWithoutLikedEventsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface CommentUpdateManyWithoutLikedByInput {
  create?: Maybe<
    CommentCreateWithoutLikedByInput[] | CommentCreateWithoutLikedByInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutLikedByInput[]
    | CommentUpdateWithWhereUniqueWithoutLikedByInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutLikedByInput[]
    | CommentUpsertWithWhereUniqueWithoutLikedByInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutLikedByDataInput;
}

export interface CommentUpdateWithoutLikedByDataInput {
  text?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  post?: Maybe<PostUpdateOneWithoutCommentsInput>;
  event?: Maybe<EventUpdateOneWithoutCommentsInput>;
}

export interface PostUpdateOneWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  update?: Maybe<PostUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<PostUpsertWithoutCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostUpdateWithoutCommentsDataInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedPostsInput>;
  date?: Maybe<DateTimeInput>;
}

export interface PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput;
  create: PostCreateWithoutCommentsInput;
}

export interface EventUpdateOneWithoutCommentsInput {
  create?: Maybe<EventCreateWithoutCommentsInput>;
  update?: Maybe<EventUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<EventUpsertWithoutCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutCommentsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  supporters?: Maybe<UserUpdateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  committee?: Maybe<CommitteeUpdateOneRequiredWithoutEventInput>;
  todos?: Maybe<TodoUpdateManyWithoutEventInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface InvitationUpdateManyWithoutUserInput {
  create?: Maybe<
    InvitationCreateWithoutUserInput[] | InvitationCreateWithoutUserInput
  >;
  delete?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
  connect?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
  set?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
  disconnect?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
  update?: Maybe<
    | InvitationUpdateWithWhereUniqueWithoutUserInput[]
    | InvitationUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | InvitationUpsertWithWhereUniqueWithoutUserInput[]
    | InvitationUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<InvitationScalarWhereInput[] | InvitationScalarWhereInput>;
  updateMany?: Maybe<
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput
  >;
}

export interface InvitationUpdateWithWhereUniqueWithoutUserInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutUserDataInput;
}

export interface InvitationUpdateWithoutUserDataInput {
  committee?: Maybe<CommitteeUpdateOneRequiredWithoutInvitationsInput>;
  status?: Maybe<InvitationStatus>;
}

export interface CommitteeUpdateOneRequiredWithoutInvitationsInput {
  create?: Maybe<CommitteeCreateWithoutInvitationsInput>;
  update?: Maybe<CommitteeUpdateWithoutInvitationsDataInput>;
  upsert?: Maybe<CommitteeUpsertWithoutInvitationsInput>;
  connect?: Maybe<CommitteeWhereUniqueInput>;
}

export interface CommitteeUpdateWithoutInvitationsDataInput {
  creator?: Maybe<UserUpdateOneRequiredInput>;
  members?: Maybe<UserUpdateManyInput>;
  event?: Maybe<EventUpdateOneRequiredWithoutCommitteeInput>;
}

export interface UserUpdateManyInput {
  create?: Maybe<UserCreateInput[] | UserCreateInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueNestedInput[]
    | UserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueNestedInput[]
    | UserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  data: UserUpdateDataInput;
}

export interface UserUpsertWithWhereUniqueNestedInput {
  where: UserWhereUniqueInput;
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  balance?: Maybe<Float>;
  balance_not?: Maybe<Float>;
  balance_in?: Maybe<Float[] | Float>;
  balance_not_in?: Maybe<Float[] | Float>;
  balance_lt?: Maybe<Float>;
  balance_lte?: Maybe<Float>;
  balance_gt?: Maybe<Float>;
  balance_gte?: Maybe<Float>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
}

export interface EventUpdateOneRequiredWithoutCommitteeInput {
  create?: Maybe<EventCreateWithoutCommitteeInput>;
  update?: Maybe<EventUpdateWithoutCommitteeDataInput>;
  upsert?: Maybe<EventUpsertWithoutCommitteeInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutCommitteeDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  supporters?: Maybe<UserUpdateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  comments?: Maybe<CommentUpdateManyWithoutEventInput>;
  todos?: Maybe<TodoUpdateManyWithoutEventInput>;
}

export interface CommentUpdateManyWithoutEventInput {
  create?: Maybe<
    CommentCreateWithoutEventInput[] | CommentCreateWithoutEventInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutEventInput[]
    | CommentUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutEventInput[]
    | CommentUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutEventDataInput;
}

export interface CommentUpdateWithoutEventDataInput {
  text?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostUpdateOneWithoutCommentsInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutEventDataInput;
  create: CommentCreateWithoutEventInput;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  text?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface TodoUpdateManyWithoutEventInput {
  create?: Maybe<TodoCreateWithoutEventInput[] | TodoCreateWithoutEventInput>;
  delete?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
  connect?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
  set?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
  disconnect?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
  update?: Maybe<
    | TodoUpdateWithWhereUniqueWithoutEventInput[]
    | TodoUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | TodoUpsertWithWhereUniqueWithoutEventInput[]
    | TodoUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<TodoScalarWhereInput[] | TodoScalarWhereInput>;
  updateMany?: Maybe<
    TodoUpdateManyWithWhereNestedInput[] | TodoUpdateManyWithWhereNestedInput
  >;
}

export interface TodoUpdateWithWhereUniqueWithoutEventInput {
  where: TodoWhereUniqueInput;
  data: TodoUpdateWithoutEventDataInput;
}

export interface TodoUpdateWithoutEventDataInput {
  due?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  done?: Maybe<Boolean>;
  assigned?: Maybe<UserUpdateOneInput>;
  link?: Maybe<String>;
  doneBy?: Maybe<UserUpdateOneInput>;
  doneAt?: Maybe<DateTimeInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface TodoUpsertWithWhereUniqueWithoutEventInput {
  where: TodoWhereUniqueInput;
  update: TodoUpdateWithoutEventDataInput;
  create: TodoCreateWithoutEventInput;
}

export interface TodoScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  due?: Maybe<DateTimeInput>;
  due_not?: Maybe<DateTimeInput>;
  due_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  due_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  due_lt?: Maybe<DateTimeInput>;
  due_lte?: Maybe<DateTimeInput>;
  due_gt?: Maybe<DateTimeInput>;
  due_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  done?: Maybe<Boolean>;
  done_not?: Maybe<Boolean>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  doneAt?: Maybe<DateTimeInput>;
  doneAt_not?: Maybe<DateTimeInput>;
  doneAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  doneAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  doneAt_lt?: Maybe<DateTimeInput>;
  doneAt_lte?: Maybe<DateTimeInput>;
  doneAt_gt?: Maybe<DateTimeInput>;
  doneAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TodoScalarWhereInput[] | TodoScalarWhereInput>;
  OR?: Maybe<TodoScalarWhereInput[] | TodoScalarWhereInput>;
  NOT?: Maybe<TodoScalarWhereInput[] | TodoScalarWhereInput>;
}

export interface TodoUpdateManyWithWhereNestedInput {
  where: TodoScalarWhereInput;
  data: TodoUpdateManyDataInput;
}

export interface TodoUpdateManyDataInput {
  due?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  done?: Maybe<Boolean>;
  link?: Maybe<String>;
  doneAt?: Maybe<DateTimeInput>;
}

export interface EventUpsertWithoutCommitteeInput {
  update: EventUpdateWithoutCommitteeDataInput;
  create: EventCreateWithoutCommitteeInput;
}

export interface CommitteeUpsertWithoutInvitationsInput {
  update: CommitteeUpdateWithoutInvitationsDataInput;
  create: CommitteeCreateWithoutInvitationsInput;
}

export interface InvitationUpsertWithWhereUniqueWithoutUserInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutUserDataInput;
  create: InvitationCreateWithoutUserInput;
}

export interface InvitationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  status?: Maybe<InvitationStatus>;
  status_not?: Maybe<InvitationStatus>;
  status_in?: Maybe<InvitationStatus[] | InvitationStatus>;
  status_not_in?: Maybe<InvitationStatus[] | InvitationStatus>;
  AND?: Maybe<InvitationScalarWhereInput[] | InvitationScalarWhereInput>;
  OR?: Maybe<InvitationScalarWhereInput[] | InvitationScalarWhereInput>;
  NOT?: Maybe<InvitationScalarWhereInput[] | InvitationScalarWhereInput>;
}

export interface InvitationUpdateManyWithWhereNestedInput {
  where: InvitationScalarWhereInput;
  data: InvitationUpdateManyDataInput;
}

export interface InvitationUpdateManyDataInput {
  status?: Maybe<InvitationStatus>;
}

export interface CommitteeUpdateOneRequiredWithoutEventInput {
  create?: Maybe<CommitteeCreateWithoutEventInput>;
  update?: Maybe<CommitteeUpdateWithoutEventDataInput>;
  upsert?: Maybe<CommitteeUpsertWithoutEventInput>;
  connect?: Maybe<CommitteeWhereUniqueInput>;
}

export interface CommitteeUpdateWithoutEventDataInput {
  creator?: Maybe<UserUpdateOneRequiredInput>;
  members?: Maybe<UserUpdateManyInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutCommitteeInput>;
}

export interface InvitationUpdateManyWithoutCommitteeInput {
  create?: Maybe<
    | InvitationCreateWithoutCommitteeInput[]
    | InvitationCreateWithoutCommitteeInput
  >;
  delete?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
  connect?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
  set?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
  disconnect?: Maybe<InvitationWhereUniqueInput[] | InvitationWhereUniqueInput>;
  update?: Maybe<
    | InvitationUpdateWithWhereUniqueWithoutCommitteeInput[]
    | InvitationUpdateWithWhereUniqueWithoutCommitteeInput
  >;
  upsert?: Maybe<
    | InvitationUpsertWithWhereUniqueWithoutCommitteeInput[]
    | InvitationUpsertWithWhereUniqueWithoutCommitteeInput
  >;
  deleteMany?: Maybe<InvitationScalarWhereInput[] | InvitationScalarWhereInput>;
  updateMany?: Maybe<
    | InvitationUpdateManyWithWhereNestedInput[]
    | InvitationUpdateManyWithWhereNestedInput
  >;
}

export interface InvitationUpdateWithWhereUniqueWithoutCommitteeInput {
  where: InvitationWhereUniqueInput;
  data: InvitationUpdateWithoutCommitteeDataInput;
}

export interface InvitationUpdateWithoutCommitteeDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutInvitationsInput>;
  status?: Maybe<InvitationStatus>;
}

export interface UserUpdateOneRequiredWithoutInvitationsInput {
  create?: Maybe<UserCreateWithoutInvitationsInput>;
  update?: Maybe<UserUpdateWithoutInvitationsDataInput>;
  upsert?: Maybe<UserUpsertWithoutInvitationsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutInvitationsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
}

export interface UserUpsertWithoutInvitationsInput {
  update: UserUpdateWithoutInvitationsDataInput;
  create: UserCreateWithoutInvitationsInput;
}

export interface InvitationUpsertWithWhereUniqueWithoutCommitteeInput {
  where: InvitationWhereUniqueInput;
  update: InvitationUpdateWithoutCommitteeDataInput;
  create: InvitationCreateWithoutCommitteeInput;
}

export interface CommitteeUpsertWithoutEventInput {
  update: CommitteeUpdateWithoutEventDataInput;
  create: CommitteeCreateWithoutEventInput;
}

export interface EventUpsertWithoutCommentsInput {
  update: EventUpdateWithoutCommentsDataInput;
  create: EventCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutLikedByDataInput;
  create: CommentCreateWithoutLikedByInput;
}

export interface UserUpsertWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedEventsDataInput;
  create: UserCreateWithoutLikedEventsInput;
}

export interface EventUpsertWithWhereUniqueWithoutSupportersInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutSupportersDataInput;
  create: EventCreateWithoutSupportersInput;
}

export interface EventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  AND?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  OR?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  NOT?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface EventUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
}

export interface UserUpsertWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedCommentsDataInput;
  create: UserCreateWithoutLikedCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutAuthorDataInput;
  create: CommentCreateWithoutAuthorInput;
}

export interface UserUpsertWithWhereUniqueWithoutSupportedEventsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSupportedEventsDataInput;
  create: UserCreateWithoutSupportedEventsInput;
}

export interface EventUpsertWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutLikedByDataInput;
  create: EventCreateWithoutLikedByInput;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface CommentUpdateManyWithoutPostInput {
  create?: Maybe<
    CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutPostInput[]
    | CommentUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutPostInput[]
    | CommentUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutPostDataInput;
}

export interface CommentUpdateWithoutPostDataInput {
  text?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedCommentsInput>;
  event?: Maybe<EventUpdateOneWithoutCommentsInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutPostDataInput;
  create: CommentCreateWithoutPostInput;
}

export interface PostUpsertWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutLikedByDataInput;
  create: PostCreateWithoutLikedByInput;
}

export interface PostScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface PostUpdateManyDataInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpsertWithoutPaymentsInput {
  update: UserUpdateWithoutPaymentsDataInput;
  create: UserCreateWithoutPaymentsInput;
}

export interface PaymentUpsertWithoutTransactionInput {
  update: PaymentUpdateWithoutTransactionDataInput;
  create: PaymentCreateWithoutTransactionInput;
}

export interface PurchaseUpdateOneWithoutTransactionInput {
  create?: Maybe<PurchaseCreateWithoutTransactionInput>;
  update?: Maybe<PurchaseUpdateWithoutTransactionDataInput>;
  upsert?: Maybe<PurchaseUpsertWithoutTransactionInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PurchaseWhereUniqueInput>;
}

export interface PurchaseUpdateWithoutTransactionDataInput {
  items?: Maybe<ItemUpdateManyInput>;
  total?: Maybe<Float>;
  user?: Maybe<UserUpdateOneRequiredWithoutPurchasesInput>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpdateOneRequiredWithoutPurchasesInput {
  create?: Maybe<UserCreateWithoutPurchasesInput>;
  update?: Maybe<UserUpdateWithoutPurchasesDataInput>;
  upsert?: Maybe<UserUpsertWithoutPurchasesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPurchasesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface UserUpsertWithoutPurchasesInput {
  update: UserUpdateWithoutPurchasesDataInput;
  create: UserCreateWithoutPurchasesInput;
}

export interface PurchaseUpsertWithoutTransactionInput {
  update: PurchaseUpdateWithoutTransactionDataInput;
  create: PurchaseCreateWithoutTransactionInput;
}

export interface TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutUserDataInput;
  create: TransactionCreateWithoutUserInput;
}

export interface TransactionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  type_not?: Maybe<TransactionType>;
  type_in?: Maybe<TransactionType[] | TransactionType>;
  type_not_in?: Maybe<TransactionType[] | TransactionType>;
  balance?: Maybe<Float>;
  balance_not?: Maybe<Float>;
  balance_in?: Maybe<Float[] | Float>;
  balance_not_in?: Maybe<Float[] | Float>;
  balance_lt?: Maybe<Float>;
  balance_lte?: Maybe<Float>;
  balance_gt?: Maybe<Float>;
  balance_gte?: Maybe<Float>;
  AND?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  OR?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  NOT?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface TransactionUpdateManyDataInput {
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
}

export interface UserUpsertWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedPostsDataInput;
  create: UserCreateWithoutLikedPostsInput;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput;
  create: UserCreateWithoutTransactionsInput;
}

export interface TransactionUpsertWithoutPaymentInput {
  update: TransactionUpdateWithoutPaymentDataInput;
  create: TransactionCreateWithoutPaymentInput;
}

export interface PaymentUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutUserDataInput;
  create: PaymentCreateWithoutUserInput;
}

export interface PaymentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  AND?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  OR?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  NOT?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface PaymentUpdateManyDataInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
}

export interface UserUpsertWithoutItemsInput {
  update: UserUpdateWithoutItemsDataInput;
  create: UserCreateWithoutItemsInput;
}

export interface ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface TransactionUpdateOneRequiredWithoutPurchaseInput {
  create?: Maybe<TransactionCreateWithoutPurchaseInput>;
  update?: Maybe<TransactionUpdateWithoutPurchaseDataInput>;
  upsert?: Maybe<TransactionUpsertWithoutPurchaseInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface TransactionUpdateWithoutPurchaseDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
  payment?: Maybe<PaymentUpdateOneWithoutTransactionInput>;
}

export interface TransactionUpsertWithoutPurchaseInput {
  update: TransactionUpdateWithoutPurchaseDataInput;
  create: TransactionCreateWithoutPurchaseInput;
}

export interface PurchaseUpsertWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput;
  update: PurchaseUpdateWithoutUserDataInput;
  create: PurchaseCreateWithoutUserInput;
}

export interface PurchaseScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
  OR?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
  NOT?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
}

export interface PurchaseUpdateManyWithWhereNestedInput {
  where: PurchaseScalarWhereInput;
  data: PurchaseUpdateManyDataInput;
}

export interface PurchaseUpdateManyDataInput {
  total?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface CommentUpdateManyMutationInput {
  text?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface CommitteeCreateInput {
  creator: UserCreateOneInput;
  members?: Maybe<UserCreateManyInput>;
  event: EventCreateOneWithoutCommitteeInput;
  invitations?: Maybe<InvitationCreateManyWithoutCommitteeInput>;
}

export interface CommitteeUpdateInput {
  creator?: Maybe<UserUpdateOneRequiredInput>;
  members?: Maybe<UserUpdateManyInput>;
  event?: Maybe<EventUpdateOneRequiredWithoutCommitteeInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutCommitteeInput>;
}

export interface EventCreateInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: Maybe<UserCreateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikedEventsInput>;
  owner: UserCreateOneInput;
  comments?: Maybe<CommentCreateManyWithoutEventInput>;
  committee: CommitteeCreateOneWithoutEventInput;
  todos?: Maybe<TodoCreateManyWithoutEventInput>;
}

export interface EventUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  supporters?: Maybe<UserUpdateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  comments?: Maybe<CommentUpdateManyWithoutEventInput>;
  committee?: Maybe<CommitteeUpdateOneRequiredWithoutEventInput>;
  todos?: Maybe<TodoUpdateManyWithoutEventInput>;
}

export interface EventUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
}

export interface FileCreateInput {
  fileId: String;
  hash: String;
  uri: String;
  filename: String;
  path: String;
  mimetype: String;
  extension: String;
}

export interface FileUpdateInput {
  fileId?: Maybe<String>;
  hash?: Maybe<String>;
  uri?: Maybe<String>;
  filename?: Maybe<String>;
  path?: Maybe<String>;
  mimetype?: Maybe<String>;
  extension?: Maybe<String>;
}

export interface FileUpdateManyMutationInput {
  fileId?: Maybe<String>;
  hash?: Maybe<String>;
  uri?: Maybe<String>;
  filename?: Maybe<String>;
  path?: Maybe<String>;
  mimetype?: Maybe<String>;
  extension?: Maybe<String>;
}

export interface InvitationCreateInput {
  user: UserCreateOneWithoutInvitationsInput;
  committee: CommitteeCreateOneWithoutInvitationsInput;
  status?: Maybe<InvitationStatus>;
}

export interface InvitationUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutInvitationsInput>;
  committee?: Maybe<CommitteeUpdateOneRequiredWithoutInvitationsInput>;
  status?: Maybe<InvitationStatus>;
}

export interface InvitationUpdateManyMutationInput {
  status?: Maybe<InvitationStatus>;
}

export interface ItemUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutItemsInput>;
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface ItemUpdateManyMutationInput {
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface PaymentCreateInput {
  amount: Float;
  user: UserCreateOneWithoutPaymentsInput;
  date: DateTimeInput;
  verified?: Maybe<Boolean>;
  transaction: TransactionCreateOneWithoutPaymentInput;
}

export interface PaymentUpdateInput {
  amount?: Maybe<Float>;
  user?: Maybe<UserUpdateOneRequiredWithoutPaymentsInput>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutPaymentInput>;
}

export interface PaymentUpdateManyMutationInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
}

export interface PostCreateInput {
  text: String;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author: UserCreateOneWithoutPostsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedPostsInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  date: DateTimeInput;
}

export interface PostUpdateInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedPostsInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  date?: Maybe<DateTimeInput>;
}

export interface PostUpdateManyMutationInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  index?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  deleted?: Maybe<Boolean>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  index?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  deleted?: Maybe<Boolean>;
}

export interface ProductionCreateInput {
  title: String;
  description: String;
  image: String;
  index: Int;
  show?: Maybe<Boolean>;
}

export interface ProductionUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  index?: Maybe<Int>;
  show?: Maybe<Boolean>;
}

export interface ProductionUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  image?: Maybe<String>;
  index?: Maybe<Int>;
  show?: Maybe<Boolean>;
}

export interface PurchaseCreateInput {
  items?: Maybe<ItemCreateManyInput>;
  transaction: TransactionCreateOneWithoutPurchaseInput;
  total: Float;
  user: UserCreateOneWithoutPurchasesInput;
  date: DateTimeInput;
}

export interface PurchaseUpdateInput {
  items?: Maybe<ItemUpdateManyInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutPurchaseInput>;
  total?: Maybe<Float>;
  user?: Maybe<UserUpdateOneRequiredWithoutPurchasesInput>;
  date?: Maybe<DateTimeInput>;
}

export interface PurchaseUpdateManyMutationInput {
  total?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface QuestionCreateInput {
  text: String;
  description: String;
  templates?: Maybe<TodoTemplateCreateManyInput>;
}

export interface TodoTemplateCreateManyInput {
  create?: Maybe<TodoTemplateCreateInput[] | TodoTemplateCreateInput>;
  connect?: Maybe<
    TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput
  >;
}

export interface TodoTemplateCreateInput {
  text: String;
  offsetDays: Int;
}

export interface QuestionUpdateInput {
  text?: Maybe<String>;
  description?: Maybe<String>;
  templates?: Maybe<TodoTemplateUpdateManyInput>;
}

export interface TodoTemplateUpdateManyInput {
  create?: Maybe<TodoTemplateCreateInput[] | TodoTemplateCreateInput>;
  update?: Maybe<
    | TodoTemplateUpdateWithWhereUniqueNestedInput[]
    | TodoTemplateUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | TodoTemplateUpsertWithWhereUniqueNestedInput[]
    | TodoTemplateUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput>;
  connect?: Maybe<
    TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput
  >;
  set?: Maybe<TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput>;
  disconnect?: Maybe<
    TodoTemplateWhereUniqueInput[] | TodoTemplateWhereUniqueInput
  >;
  deleteMany?: Maybe<
    TodoTemplateScalarWhereInput[] | TodoTemplateScalarWhereInput
  >;
  updateMany?: Maybe<
    | TodoTemplateUpdateManyWithWhereNestedInput[]
    | TodoTemplateUpdateManyWithWhereNestedInput
  >;
}

export interface TodoTemplateUpdateWithWhereUniqueNestedInput {
  where: TodoTemplateWhereUniqueInput;
  data: TodoTemplateUpdateDataInput;
}

export interface TodoTemplateUpdateDataInput {
  text?: Maybe<String>;
  offsetDays?: Maybe<Int>;
}

export interface TodoTemplateUpsertWithWhereUniqueNestedInput {
  where: TodoTemplateWhereUniqueInput;
  update: TodoTemplateUpdateDataInput;
  create: TodoTemplateCreateInput;
}

export interface TodoTemplateScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  offsetDays?: Maybe<Int>;
  offsetDays_not?: Maybe<Int>;
  offsetDays_in?: Maybe<Int[] | Int>;
  offsetDays_not_in?: Maybe<Int[] | Int>;
  offsetDays_lt?: Maybe<Int>;
  offsetDays_lte?: Maybe<Int>;
  offsetDays_gt?: Maybe<Int>;
  offsetDays_gte?: Maybe<Int>;
  AND?: Maybe<TodoTemplateScalarWhereInput[] | TodoTemplateScalarWhereInput>;
  OR?: Maybe<TodoTemplateScalarWhereInput[] | TodoTemplateScalarWhereInput>;
  NOT?: Maybe<TodoTemplateScalarWhereInput[] | TodoTemplateScalarWhereInput>;
}

export interface TodoTemplateUpdateManyWithWhereNestedInput {
  where: TodoTemplateScalarWhereInput;
  data: TodoTemplateUpdateManyDataInput;
}

export interface TodoTemplateUpdateManyDataInput {
  text?: Maybe<String>;
  offsetDays?: Maybe<Int>;
}

export interface QuestionUpdateManyMutationInput {
  text?: Maybe<String>;
  description?: Maybe<String>;
}

export interface TodoCreateInput {
  due: DateTimeInput;
  text: String;
  done?: Maybe<Boolean>;
  assigned?: Maybe<UserCreateOneInput>;
  link?: Maybe<String>;
  doneBy?: Maybe<UserCreateOneInput>;
  doneAt?: Maybe<DateTimeInput>;
  event: EventCreateOneWithoutTodosInput;
}

export interface EventCreateOneWithoutTodosInput {
  create?: Maybe<EventCreateWithoutTodosInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventCreateWithoutTodosInput {
  title: String;
  description: String;
  date: DateTimeInput;
  image: String;
  supporters?: Maybe<UserCreateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikedEventsInput>;
  owner: UserCreateOneInput;
  comments?: Maybe<CommentCreateManyWithoutEventInput>;
  committee: CommitteeCreateOneWithoutEventInput;
}

export interface TodoUpdateInput {
  due?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  done?: Maybe<Boolean>;
  assigned?: Maybe<UserUpdateOneInput>;
  link?: Maybe<String>;
  doneBy?: Maybe<UserUpdateOneInput>;
  doneAt?: Maybe<DateTimeInput>;
  event?: Maybe<EventUpdateOneRequiredWithoutTodosInput>;
}

export interface EventUpdateOneRequiredWithoutTodosInput {
  create?: Maybe<EventCreateWithoutTodosInput>;
  update?: Maybe<EventUpdateWithoutTodosDataInput>;
  upsert?: Maybe<EventUpsertWithoutTodosInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutTodosDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  supporters?: Maybe<UserUpdateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  comments?: Maybe<CommentUpdateManyWithoutEventInput>;
  committee?: Maybe<CommitteeUpdateOneRequiredWithoutEventInput>;
}

export interface EventUpsertWithoutTodosInput {
  update: EventUpdateWithoutTodosDataInput;
  create: EventCreateWithoutTodosInput;
}

export interface TodoUpdateManyMutationInput {
  due?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  done?: Maybe<Boolean>;
  link?: Maybe<String>;
  doneAt?: Maybe<DateTimeInput>;
}

export interface TodoTemplateUpdateInput {
  text?: Maybe<String>;
  offsetDays?: Maybe<Int>;
}

export interface TodoTemplateUpdateManyMutationInput {
  text?: Maybe<String>;
  offsetDays?: Maybe<Int>;
}

export interface TransactionCreateInput {
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  payment?: Maybe<PaymentCreateOneWithoutTransactionInput>;
  purchase?: Maybe<PurchaseCreateOneWithoutTransactionInput>;
}

export interface TransactionUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
  payment?: Maybe<PaymentUpdateOneWithoutTransactionInput>;
  purchase?: Maybe<PurchaseUpdateOneWithoutTransactionInput>;
}

export interface TransactionUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  invitations?: Maybe<InvitationUpdateManyWithoutUserInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  password?: Maybe<String>;
  avatar?: Maybe<String>;
  role?: Maybe<UserRole>;
  balance?: Maybe<Float>;
}

export interface ClientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClientWhereInput>;
  AND?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  OR?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  NOT?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface CommitteeSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommitteeWhereInput>;
  AND?: Maybe<
    CommitteeSubscriptionWhereInput[] | CommitteeSubscriptionWhereInput
  >;
  OR?: Maybe<
    CommitteeSubscriptionWhereInput[] | CommitteeSubscriptionWhereInput
  >;
  NOT?: Maybe<
    CommitteeSubscriptionWhereInput[] | CommitteeSubscriptionWhereInput
  >;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  OR?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  NOT?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface InvitationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<InvitationWhereInput>;
  AND?: Maybe<
    InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput
  >;
  OR?: Maybe<
    InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    InvitationSubscriptionWhereInput[] | InvitationSubscriptionWhereInput
  >;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentWhereInput>;
  AND?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  OR?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  NOT?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface ProductionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductionWhereInput>;
  AND?: Maybe<
    ProductionSubscriptionWhereInput[] | ProductionSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProductionSubscriptionWhereInput[] | ProductionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProductionSubscriptionWhereInput[] | ProductionSubscriptionWhereInput
  >;
}

export interface PurchaseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PurchaseWhereInput>;
  AND?: Maybe<
    PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput
  >;
  OR?: Maybe<PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput>;
  NOT?: Maybe<
    PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput
  >;
}

export interface QuestionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<QuestionWhereInput>;
  AND?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
  OR?: Maybe<QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput>;
  NOT?: Maybe<
    QuestionSubscriptionWhereInput[] | QuestionSubscriptionWhereInput
  >;
}

export interface TodoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TodoWhereInput>;
  AND?: Maybe<TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput>;
  OR?: Maybe<TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput>;
  NOT?: Maybe<TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput>;
}

export interface TodoTemplateSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TodoTemplateWhereInput>;
  AND?: Maybe<
    TodoTemplateSubscriptionWhereInput[] | TodoTemplateSubscriptionWhereInput
  >;
  OR?: Maybe<
    TodoTemplateSubscriptionWhereInput[] | TodoTemplateSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TodoTemplateSubscriptionWhereInput[] | TodoTemplateSubscriptionWhereInput
  >;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TransactionWhereInput>;
  AND?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  OR?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Client {
  id: ID_Output;
  identity: String;
  secret: String;
  name: String;
  trusted: Boolean;
}

export interface ClientPromise extends Promise<Client>, Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientSubscription
  extends Promise<AsyncIterator<Client>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identity: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trusted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ClientNullablePromise
  extends Promise<Client | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientConnection {
  pageInfo: PageInfo;
  edges: ClientEdge[];
}

export interface ClientConnectionPromise
  extends Promise<ClientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClientEdge>>() => T;
  aggregate: <T = AggregateClientPromise>() => T;
}

export interface ClientConnectionSubscription
  extends Promise<AsyncIterator<ClientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClientSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ClientEdge {
  node: Client;
  cursor: String;
}

export interface ClientEdgePromise extends Promise<ClientEdge>, Fragmentable {
  node: <T = ClientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClientEdgeSubscription
  extends Promise<AsyncIterator<ClientEdge>>,
    Fragmentable {
  node: <T = ClientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClient {
  count: Int;
}

export interface AggregateClientPromise
  extends Promise<AggregateClient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClientSubscription
  extends Promise<AsyncIterator<AggregateClient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Comment {
  id: ID_Output;
  text: String;
  date: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  post: <T = PostPromise>() => T;
  event: <T = EventPromise>() => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  post: <T = PostSubscription>() => T;
  event: <T = EventSubscription>() => T;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  post: <T = PostPromise>() => T;
  event: <T = EventPromise>() => T;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  avatar?: String;
  role: UserRole;
  balance: Float;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  avatar: () => Promise<String>;
  purchases: <T = FragmentableArray<Purchase>>(args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<UserRole>;
  balance: () => Promise<Float>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedPosts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  supportedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedComments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  purchases: <T = Promise<AsyncIterator<PurchaseSubscription>>>(args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<AsyncIterator<UserRole>>;
  balance: () => Promise<AsyncIterator<Float>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedPosts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedEvents: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  supportedEvents: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedComments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  avatar: () => Promise<String>;
  purchases: <T = FragmentableArray<Purchase>>(args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  role: () => Promise<UserRole>;
  balance: () => Promise<Float>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedPosts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  supportedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedComments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Purchase {
  id: ID_Output;
  total: Float;
  date: DateTimeOutput;
}

export interface PurchasePromise extends Promise<Purchase>, Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionPromise>() => T;
  total: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface PurchaseSubscription
  extends Promise<AsyncIterator<Purchase>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionSubscription>() => T;
  total: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PurchaseNullablePromise
  extends Promise<Purchase | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionPromise>() => T;
  total: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface Item {
  id: ID_Output;
  price: Float;
  amount: Int;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  user: <T = UserPromise>() => T;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  user: <T = UserSubscription>() => T;
  price: () => Promise<AsyncIterator<Float>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  user: <T = UserPromise>() => T;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface Product {
  id: ID_Output;
  name: String;
  price: Float;
  index: Int;
  thumbnail?: String;
  deleted: Boolean;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  deleted: () => Promise<Boolean>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  index: () => Promise<AsyncIterator<Int>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  deleted: () => Promise<Boolean>;
}

export interface Transaction {
  id: ID_Output;
  date: DateTimeOutput;
  type: TransactionType;
  balance: Float;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
  balance: () => Promise<Float>;
  payment: <T = PaymentPromise>() => T;
  purchase: <T = PurchasePromise>() => T;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  balance: () => Promise<AsyncIterator<Float>>;
  payment: <T = PaymentSubscription>() => T;
  purchase: <T = PurchaseSubscription>() => T;
}

export interface TransactionNullablePromise
  extends Promise<Transaction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
  balance: () => Promise<Float>;
  payment: <T = PaymentPromise>() => T;
  purchase: <T = PurchasePromise>() => T;
}

export interface Payment {
  id: ID_Output;
  amount: Float;
  date: DateTimeOutput;
  verified: Boolean;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  verified: () => Promise<Boolean>;
  transaction: <T = TransactionPromise>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  transaction: <T = TransactionSubscription>() => T;
}

export interface PaymentNullablePromise
  extends Promise<Payment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  verified: () => Promise<Boolean>;
  transaction: <T = TransactionPromise>() => T;
}

export interface Post {
  id: ID_Output;
  text: String;
  image?: String;
  link?: String;
  date: DateTimeOutput;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<DateTimeOutput>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostNullablePromise
  extends Promise<Post | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<DateTimeOutput>;
}

export interface Event {
  id: ID_Output;
  title: String;
  description: String;
  date: DateTimeOutput;
  image: String;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  image: () => Promise<String>;
  supporters: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  committee: <T = CommitteePromise>() => T;
  todos: <T = FragmentableArray<Todo>>(args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  image: () => Promise<AsyncIterator<String>>;
  supporters: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  committee: <T = CommitteeSubscription>() => T;
  todos: <T = Promise<AsyncIterator<TodoSubscription>>>(args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  image: () => Promise<String>;
  supporters: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  committee: <T = CommitteePromise>() => T;
  todos: <T = FragmentableArray<Todo>>(args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Committee {
  id: ID_Output;
}

export interface CommitteePromise extends Promise<Committee>, Fragmentable {
  id: () => Promise<ID_Output>;
  creator: <T = UserPromise>() => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  event: <T = EventPromise>() => T;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CommitteeSubscription
  extends Promise<AsyncIterator<Committee>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  creator: <T = UserSubscription>() => T;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  event: <T = EventSubscription>() => T;
  invitations: <T = Promise<AsyncIterator<InvitationSubscription>>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CommitteeNullablePromise
  extends Promise<Committee | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  creator: <T = UserPromise>() => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  event: <T = EventPromise>() => T;
  invitations: <T = FragmentableArray<Invitation>>(args?: {
    where?: InvitationWhereInput;
    orderBy?: InvitationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Invitation {
  id: ID_Output;
  status: InvitationStatus;
}

export interface InvitationPromise extends Promise<Invitation>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  committee: <T = CommitteePromise>() => T;
  status: () => Promise<InvitationStatus>;
}

export interface InvitationSubscription
  extends Promise<AsyncIterator<Invitation>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  committee: <T = CommitteeSubscription>() => T;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
}

export interface InvitationNullablePromise
  extends Promise<Invitation | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  committee: <T = CommitteePromise>() => T;
  status: () => Promise<InvitationStatus>;
}

export interface Todo {
  id: ID_Output;
  due: DateTimeOutput;
  text: String;
  done?: Boolean;
  link?: String;
  doneAt?: DateTimeOutput;
}

export interface TodoPromise extends Promise<Todo>, Fragmentable {
  id: () => Promise<ID_Output>;
  due: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  done: () => Promise<Boolean>;
  assigned: <T = UserPromise>() => T;
  link: () => Promise<String>;
  doneBy: <T = UserPromise>() => T;
  doneAt: () => Promise<DateTimeOutput>;
  event: <T = EventPromise>() => T;
}

export interface TodoSubscription
  extends Promise<AsyncIterator<Todo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  due: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  done: () => Promise<AsyncIterator<Boolean>>;
  assigned: <T = UserSubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
  doneBy: <T = UserSubscription>() => T;
  doneAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  event: <T = EventSubscription>() => T;
}

export interface TodoNullablePromise
  extends Promise<Todo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  due: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  done: () => Promise<Boolean>;
  assigned: <T = UserPromise>() => T;
  link: () => Promise<String>;
  doneBy: <T = UserPromise>() => T;
  doneAt: () => Promise<DateTimeOutput>;
  event: <T = EventPromise>() => T;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommitteeConnection {
  pageInfo: PageInfo;
  edges: CommitteeEdge[];
}

export interface CommitteeConnectionPromise
  extends Promise<CommitteeConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommitteeEdge>>() => T;
  aggregate: <T = AggregateCommitteePromise>() => T;
}

export interface CommitteeConnectionSubscription
  extends Promise<AsyncIterator<CommitteeConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommitteeEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommitteeSubscription>() => T;
}

export interface CommitteeEdge {
  node: Committee;
  cursor: String;
}

export interface CommitteeEdgePromise
  extends Promise<CommitteeEdge>,
    Fragmentable {
  node: <T = CommitteePromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommitteeEdgeSubscription
  extends Promise<AsyncIterator<CommitteeEdge>>,
    Fragmentable {
  node: <T = CommitteeSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCommittee {
  count: Int;
}

export interface AggregateCommitteePromise
  extends Promise<AggregateCommittee>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommitteeSubscription
  extends Promise<AsyncIterator<AggregateCommittee>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface File {
  id: ID_Output;
  fileId: String;
  hash: String;
  uri: String;
  filename: String;
  path: String;
  mimetype: String;
  extension: String;
  createdAt: DateTimeOutput;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileId: () => Promise<String>;
  hash: () => Promise<String>;
  uri: () => Promise<String>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileId: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  extension: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileId: () => Promise<String>;
  hash: () => Promise<String>;
  uri: () => Promise<String>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface InvitationConnection {
  pageInfo: PageInfo;
  edges: InvitationEdge[];
}

export interface InvitationConnectionPromise
  extends Promise<InvitationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<InvitationEdge>>() => T;
  aggregate: <T = AggregateInvitationPromise>() => T;
}

export interface InvitationConnectionSubscription
  extends Promise<AsyncIterator<InvitationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<InvitationEdgeSubscription>>>() => T;
  aggregate: <T = AggregateInvitationSubscription>() => T;
}

export interface InvitationEdge {
  node: Invitation;
  cursor: String;
}

export interface InvitationEdgePromise
  extends Promise<InvitationEdge>,
    Fragmentable {
  node: <T = InvitationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface InvitationEdgeSubscription
  extends Promise<AsyncIterator<InvitationEdge>>,
    Fragmentable {
  node: <T = InvitationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateInvitation {
  count: Int;
}

export interface AggregateInvitationPromise
  extends Promise<AggregateInvitation>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateInvitationSubscription
  extends Promise<AsyncIterator<AggregateInvitation>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Production {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
  index: Int;
  show: Boolean;
}

export interface ProductionPromise extends Promise<Production>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  index: () => Promise<Int>;
  show: () => Promise<Boolean>;
}

export interface ProductionSubscription
  extends Promise<AsyncIterator<Production>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  index: () => Promise<AsyncIterator<Int>>;
  show: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductionNullablePromise
  extends Promise<Production | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  index: () => Promise<Int>;
  show: () => Promise<Boolean>;
}

export interface ProductionConnection {
  pageInfo: PageInfo;
  edges: ProductionEdge[];
}

export interface ProductionConnectionPromise
  extends Promise<ProductionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductionEdge>>() => T;
  aggregate: <T = AggregateProductionPromise>() => T;
}

export interface ProductionConnectionSubscription
  extends Promise<AsyncIterator<ProductionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductionSubscription>() => T;
}

export interface ProductionEdge {
  node: Production;
  cursor: String;
}

export interface ProductionEdgePromise
  extends Promise<ProductionEdge>,
    Fragmentable {
  node: <T = ProductionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductionEdgeSubscription
  extends Promise<AsyncIterator<ProductionEdge>>,
    Fragmentable {
  node: <T = ProductionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduction {
  count: Int;
}

export interface AggregateProductionPromise
  extends Promise<AggregateProduction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductionSubscription
  extends Promise<AsyncIterator<AggregateProduction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PurchaseConnection {
  pageInfo: PageInfo;
  edges: PurchaseEdge[];
}

export interface PurchaseConnectionPromise
  extends Promise<PurchaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PurchaseEdge>>() => T;
  aggregate: <T = AggregatePurchasePromise>() => T;
}

export interface PurchaseConnectionSubscription
  extends Promise<AsyncIterator<PurchaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PurchaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePurchaseSubscription>() => T;
}

export interface PurchaseEdge {
  node: Purchase;
  cursor: String;
}

export interface PurchaseEdgePromise
  extends Promise<PurchaseEdge>,
    Fragmentable {
  node: <T = PurchasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PurchaseEdgeSubscription
  extends Promise<AsyncIterator<PurchaseEdge>>,
    Fragmentable {
  node: <T = PurchaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePurchase {
  count: Int;
}

export interface AggregatePurchasePromise
  extends Promise<AggregatePurchase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePurchaseSubscription
  extends Promise<AsyncIterator<AggregatePurchase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Question {
  id: ID_Output;
  text: String;
  description: String;
}

export interface QuestionPromise extends Promise<Question>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  description: () => Promise<String>;
  templates: <T = FragmentableArray<TodoTemplate>>(args?: {
    where?: TodoTemplateWhereInput;
    orderBy?: TodoTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionSubscription
  extends Promise<AsyncIterator<Question>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  templates: <T = Promise<AsyncIterator<TodoTemplateSubscription>>>(args?: {
    where?: TodoTemplateWhereInput;
    orderBy?: TodoTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface QuestionNullablePromise
  extends Promise<Question | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  description: () => Promise<String>;
  templates: <T = FragmentableArray<TodoTemplate>>(args?: {
    where?: TodoTemplateWhereInput;
    orderBy?: TodoTemplateOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TodoTemplate {
  id: ID_Output;
  text: String;
  offsetDays: Int;
}

export interface TodoTemplatePromise
  extends Promise<TodoTemplate>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  offsetDays: () => Promise<Int>;
}

export interface TodoTemplateSubscription
  extends Promise<AsyncIterator<TodoTemplate>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  offsetDays: () => Promise<AsyncIterator<Int>>;
}

export interface TodoTemplateNullablePromise
  extends Promise<TodoTemplate | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  offsetDays: () => Promise<Int>;
}

export interface QuestionConnection {
  pageInfo: PageInfo;
  edges: QuestionEdge[];
}

export interface QuestionConnectionPromise
  extends Promise<QuestionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<QuestionEdge>>() => T;
  aggregate: <T = AggregateQuestionPromise>() => T;
}

export interface QuestionConnectionSubscription
  extends Promise<AsyncIterator<QuestionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<QuestionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateQuestionSubscription>() => T;
}

export interface QuestionEdge {
  node: Question;
  cursor: String;
}

export interface QuestionEdgePromise
  extends Promise<QuestionEdge>,
    Fragmentable {
  node: <T = QuestionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface QuestionEdgeSubscription
  extends Promise<AsyncIterator<QuestionEdge>>,
    Fragmentable {
  node: <T = QuestionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateQuestion {
  count: Int;
}

export interface AggregateQuestionPromise
  extends Promise<AggregateQuestion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateQuestionSubscription
  extends Promise<AsyncIterator<AggregateQuestion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TodoConnection {
  pageInfo: PageInfo;
  edges: TodoEdge[];
}

export interface TodoConnectionPromise
  extends Promise<TodoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TodoEdge>>() => T;
  aggregate: <T = AggregateTodoPromise>() => T;
}

export interface TodoConnectionSubscription
  extends Promise<AsyncIterator<TodoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TodoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTodoSubscription>() => T;
}

export interface TodoEdge {
  node: Todo;
  cursor: String;
}

export interface TodoEdgePromise extends Promise<TodoEdge>, Fragmentable {
  node: <T = TodoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TodoEdgeSubscription
  extends Promise<AsyncIterator<TodoEdge>>,
    Fragmentable {
  node: <T = TodoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTodo {
  count: Int;
}

export interface AggregateTodoPromise
  extends Promise<AggregateTodo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTodoSubscription
  extends Promise<AsyncIterator<AggregateTodo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TodoTemplateConnection {
  pageInfo: PageInfo;
  edges: TodoTemplateEdge[];
}

export interface TodoTemplateConnectionPromise
  extends Promise<TodoTemplateConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TodoTemplateEdge>>() => T;
  aggregate: <T = AggregateTodoTemplatePromise>() => T;
}

export interface TodoTemplateConnectionSubscription
  extends Promise<AsyncIterator<TodoTemplateConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TodoTemplateEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTodoTemplateSubscription>() => T;
}

export interface TodoTemplateEdge {
  node: TodoTemplate;
  cursor: String;
}

export interface TodoTemplateEdgePromise
  extends Promise<TodoTemplateEdge>,
    Fragmentable {
  node: <T = TodoTemplatePromise>() => T;
  cursor: () => Promise<String>;
}

export interface TodoTemplateEdgeSubscription
  extends Promise<AsyncIterator<TodoTemplateEdge>>,
    Fragmentable {
  node: <T = TodoTemplateSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTodoTemplate {
  count: Int;
}

export interface AggregateTodoTemplatePromise
  extends Promise<AggregateTodoTemplate>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTodoTemplateSubscription
  extends Promise<AsyncIterator<AggregateTodoTemplate>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ClientSubscriptionPayload {
  mutation: MutationType;
  node: Client;
  updatedFields: String[];
  previousValues: ClientPreviousValues;
}

export interface ClientSubscriptionPayloadPromise
  extends Promise<ClientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClientPreviousValuesPromise>() => T;
}

export interface ClientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClientPreviousValuesSubscription>() => T;
}

export interface ClientPreviousValues {
  id: ID_Output;
  identity: String;
  secret: String;
  name: String;
  trusted: Boolean;
}

export interface ClientPreviousValuesPromise
  extends Promise<ClientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientPreviousValuesSubscription
  extends Promise<AsyncIterator<ClientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identity: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trusted: () => Promise<AsyncIterator<Boolean>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  text: String;
  date: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface CommitteeSubscriptionPayload {
  mutation: MutationType;
  node: Committee;
  updatedFields: String[];
  previousValues: CommitteePreviousValues;
}

export interface CommitteeSubscriptionPayloadPromise
  extends Promise<CommitteeSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommitteePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommitteePreviousValuesPromise>() => T;
}

export interface CommitteeSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommitteeSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommitteeSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommitteePreviousValuesSubscription>() => T;
}

export interface CommitteePreviousValues {
  id: ID_Output;
}

export interface CommitteePreviousValuesPromise
  extends Promise<CommitteePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
}

export interface CommitteePreviousValuesSubscription
  extends Promise<AsyncIterator<CommitteePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  date: DateTimeOutput;
  image: String;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  image: () => Promise<String>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  image: () => Promise<AsyncIterator<String>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  fileId: String;
  hash: String;
  uri: String;
  filename: String;
  path: String;
  mimetype: String;
  extension: String;
  createdAt: DateTimeOutput;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileId: () => Promise<String>;
  hash: () => Promise<String>;
  uri: () => Promise<String>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileId: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  extension: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface InvitationSubscriptionPayload {
  mutation: MutationType;
  node: Invitation;
  updatedFields: String[];
  previousValues: InvitationPreviousValues;
}

export interface InvitationSubscriptionPayloadPromise
  extends Promise<InvitationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = InvitationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = InvitationPreviousValuesPromise>() => T;
}

export interface InvitationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<InvitationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = InvitationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = InvitationPreviousValuesSubscription>() => T;
}

export interface InvitationPreviousValues {
  id: ID_Output;
  status: InvitationStatus;
}

export interface InvitationPreviousValuesPromise
  extends Promise<InvitationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  status: () => Promise<InvitationStatus>;
}

export interface InvitationPreviousValuesSubscription
  extends Promise<AsyncIterator<InvitationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  status: () => Promise<AsyncIterator<InvitationStatus>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  price: Float;
  amount: Int;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Float>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  amount: Float;
  date: DateTimeOutput;
  verified: Boolean;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  date: () => Promise<DateTimeOutput>;
  verified: () => Promise<Boolean>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostPreviousValues {
  id: ID_Output;
  text: String;
  image?: String;
  link?: String;
  date: DateTimeOutput;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  price: Float;
  index: Int;
  thumbnail?: String;
  deleted: Boolean;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  deleted: () => Promise<Boolean>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  index: () => Promise<AsyncIterator<Int>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductionSubscriptionPayload {
  mutation: MutationType;
  node: Production;
  updatedFields: String[];
  previousValues: ProductionPreviousValues;
}

export interface ProductionSubscriptionPayloadPromise
  extends Promise<ProductionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductionPreviousValuesPromise>() => T;
}

export interface ProductionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductionPreviousValuesSubscription>() => T;
}

export interface ProductionPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  image: String;
  index: Int;
  show: Boolean;
}

export interface ProductionPreviousValuesPromise
  extends Promise<ProductionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  image: () => Promise<String>;
  index: () => Promise<Int>;
  show: () => Promise<Boolean>;
}

export interface ProductionPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  index: () => Promise<AsyncIterator<Int>>;
  show: () => Promise<AsyncIterator<Boolean>>;
}

export interface PurchaseSubscriptionPayload {
  mutation: MutationType;
  node: Purchase;
  updatedFields: String[];
  previousValues: PurchasePreviousValues;
}

export interface PurchaseSubscriptionPayloadPromise
  extends Promise<PurchaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PurchasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PurchasePreviousValuesPromise>() => T;
}

export interface PurchaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PurchaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PurchaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PurchasePreviousValuesSubscription>() => T;
}

export interface PurchasePreviousValues {
  id: ID_Output;
  total: Float;
  date: DateTimeOutput;
}

export interface PurchasePreviousValuesPromise
  extends Promise<PurchasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  date: () => Promise<DateTimeOutput>;
}

export interface PurchasePreviousValuesSubscription
  extends Promise<AsyncIterator<PurchasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface QuestionSubscriptionPayload {
  mutation: MutationType;
  node: Question;
  updatedFields: String[];
  previousValues: QuestionPreviousValues;
}

export interface QuestionSubscriptionPayloadPromise
  extends Promise<QuestionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = QuestionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = QuestionPreviousValuesPromise>() => T;
}

export interface QuestionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<QuestionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = QuestionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = QuestionPreviousValuesSubscription>() => T;
}

export interface QuestionPreviousValues {
  id: ID_Output;
  text: String;
  description: String;
}

export interface QuestionPreviousValuesPromise
  extends Promise<QuestionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  description: () => Promise<String>;
}

export interface QuestionPreviousValuesSubscription
  extends Promise<AsyncIterator<QuestionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface TodoSubscriptionPayload {
  mutation: MutationType;
  node: Todo;
  updatedFields: String[];
  previousValues: TodoPreviousValues;
}

export interface TodoSubscriptionPayloadPromise
  extends Promise<TodoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TodoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TodoPreviousValuesPromise>() => T;
}

export interface TodoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TodoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TodoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TodoPreviousValuesSubscription>() => T;
}

export interface TodoPreviousValues {
  id: ID_Output;
  due: DateTimeOutput;
  text: String;
  done?: Boolean;
  link?: String;
  doneAt?: DateTimeOutput;
}

export interface TodoPreviousValuesPromise
  extends Promise<TodoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  due: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  done: () => Promise<Boolean>;
  link: () => Promise<String>;
  doneAt: () => Promise<DateTimeOutput>;
}

export interface TodoPreviousValuesSubscription
  extends Promise<AsyncIterator<TodoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  due: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  done: () => Promise<AsyncIterator<Boolean>>;
  link: () => Promise<AsyncIterator<String>>;
  doneAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TodoTemplateSubscriptionPayload {
  mutation: MutationType;
  node: TodoTemplate;
  updatedFields: String[];
  previousValues: TodoTemplatePreviousValues;
}

export interface TodoTemplateSubscriptionPayloadPromise
  extends Promise<TodoTemplateSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TodoTemplatePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TodoTemplatePreviousValuesPromise>() => T;
}

export interface TodoTemplateSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TodoTemplateSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TodoTemplateSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TodoTemplatePreviousValuesSubscription>() => T;
}

export interface TodoTemplatePreviousValues {
  id: ID_Output;
  text: String;
  offsetDays: Int;
}

export interface TodoTemplatePreviousValuesPromise
  extends Promise<TodoTemplatePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  offsetDays: () => Promise<Int>;
}

export interface TodoTemplatePreviousValuesSubscription
  extends Promise<AsyncIterator<TodoTemplatePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  offsetDays: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface TransactionPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  type: TransactionType;
  balance: Float;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
  balance: () => Promise<Float>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  balance: () => Promise<AsyncIterator<Float>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  avatar?: String;
  role: UserRole;
  balance: Float;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  avatar: () => Promise<String>;
  role: () => Promise<UserRole>;
  balance: () => Promise<Float>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  avatar: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  balance: () => Promise<AsyncIterator<Float>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Client",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Purchase",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "TransactionType",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "Production",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Committee",
    embedded: false
  },
  {
    name: "Invitation",
    embedded: false
  },
  {
    name: "InvitationStatus",
    embedded: false
  },
  {
    name: "Todo",
    embedded: false
  },
  {
    name: "Question",
    embedded: false
  },
  {
    name: "TodoTemplate",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
