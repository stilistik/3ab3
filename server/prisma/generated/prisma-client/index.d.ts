// Code generated by Prisma (prisma@1.27.1). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export interface Exists {
  client: (where?: ClientWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  purchase: (where?: PurchaseWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  client: (where: ClientWhereUniqueInput) => ClientPromise;
  clients: (
    args?: {
      where?: ClientWhereInput;
      orderBy?: ClientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Client>;
  clientsConnection: (
    args?: {
      where?: ClientWhereInput;
      orderBy?: ClientOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ClientConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventPromise;
  events: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Event>;
  eventsConnection: (
    args?: {
      where?: EventWhereInput;
      orderBy?: EventOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => EventConnectionPromise;
  file: (where: FileWhereUniqueInput) => FilePromise;
  files: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<File>;
  filesConnection: (
    args?: {
      where?: FileWhereInput;
      orderBy?: FileOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FileConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemPromise;
  items: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Item>;
  itemsConnection: (
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ItemConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  payments: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Payment>;
  paymentsConnection: (
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PaymentConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductPromise;
  products: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Product>;
  productsConnection: (
    args?: {
      where?: ProductWhereInput;
      orderBy?: ProductOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => ProductConnectionPromise;
  purchase: (where: PurchaseWhereUniqueInput) => PurchasePromise;
  purchases: (
    args?: {
      where?: PurchaseWhereInput;
      orderBy?: PurchaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Purchase>;
  purchasesConnection: (
    args?: {
      where?: PurchaseWhereInput;
      orderBy?: PurchaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => PurchaseConnectionPromise;
  transaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  transactions: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<Transaction>;
  transactionsConnection: (
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => TransactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserPromise;
  users: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => FragmentableArray<User>;
  usersConnection: (
    args?: {
      where?: UserWhereInput;
      orderBy?: UserOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createClient: (data: ClientCreateInput) => ClientPromise;
  updateClient: (
    args: { data: ClientUpdateInput; where: ClientWhereUniqueInput }
  ) => ClientPromise;
  updateManyClients: (
    args: { data: ClientUpdateManyMutationInput; where?: ClientWhereInput }
  ) => BatchPayloadPromise;
  upsertClient: (
    args: {
      where: ClientWhereUniqueInput;
      create: ClientCreateInput;
      update: ClientUpdateInput;
    }
  ) => ClientPromise;
  deleteClient: (where: ClientWhereUniqueInput) => ClientPromise;
  deleteManyClients: (where?: ClientWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (
    args: { data: EventUpdateInput; where: EventWhereUniqueInput }
  ) => EventPromise;
  updateManyEvents: (
    args: { data: EventUpdateManyMutationInput; where?: EventWhereInput }
  ) => BatchPayloadPromise;
  upsertEvent: (
    args: {
      where: EventWhereUniqueInput;
      create: EventCreateInput;
      update: EventUpdateInput;
    }
  ) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (
    args: { data: FileUpdateInput; where: FileWhereUniqueInput }
  ) => FilePromise;
  updateManyFiles: (
    args: { data: FileUpdateManyMutationInput; where?: FileWhereInput }
  ) => BatchPayloadPromise;
  upsertFile: (
    args: {
      where: FileWhereUniqueInput;
      create: FileCreateInput;
      update: FileUpdateInput;
    }
  ) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (
    args: { data: ItemUpdateInput; where: ItemWhereUniqueInput }
  ) => ItemPromise;
  updateManyItems: (
    args: { data: ItemUpdateManyMutationInput; where?: ItemWhereInput }
  ) => BatchPayloadPromise;
  upsertItem: (
    args: {
      where: ItemWhereUniqueInput;
      create: ItemCreateInput;
      update: ItemUpdateInput;
    }
  ) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (
    args: { data: PaymentUpdateInput; where: PaymentWhereUniqueInput }
  ) => PaymentPromise;
  updateManyPayments: (
    args: { data: PaymentUpdateManyMutationInput; where?: PaymentWhereInput }
  ) => BatchPayloadPromise;
  upsertPayment: (
    args: {
      where: PaymentWhereUniqueInput;
      create: PaymentCreateInput;
      update: PaymentUpdateInput;
    }
  ) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (
    args: { data: ProductUpdateInput; where: ProductWhereUniqueInput }
  ) => ProductPromise;
  updateManyProducts: (
    args: { data: ProductUpdateManyMutationInput; where?: ProductWhereInput }
  ) => BatchPayloadPromise;
  upsertProduct: (
    args: {
      where: ProductWhereUniqueInput;
      create: ProductCreateInput;
      update: ProductUpdateInput;
    }
  ) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createPurchase: (data: PurchaseCreateInput) => PurchasePromise;
  updatePurchase: (
    args: { data: PurchaseUpdateInput; where: PurchaseWhereUniqueInput }
  ) => PurchasePromise;
  updateManyPurchases: (
    args: { data: PurchaseUpdateManyMutationInput; where?: PurchaseWhereInput }
  ) => BatchPayloadPromise;
  upsertPurchase: (
    args: {
      where: PurchaseWhereUniqueInput;
      create: PurchaseCreateInput;
      update: PurchaseUpdateInput;
    }
  ) => PurchasePromise;
  deletePurchase: (where: PurchaseWhereUniqueInput) => PurchasePromise;
  deleteManyPurchases: (where?: PurchaseWhereInput) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (
    args: { data: TransactionUpdateInput; where: TransactionWhereUniqueInput }
  ) => TransactionPromise;
  updateManyTransactions: (
    args: {
      data: TransactionUpdateManyMutationInput;
      where?: TransactionWhereInput;
    }
  ) => BatchPayloadPromise;
  upsertTransaction: (
    args: {
      where: TransactionWhereUniqueInput;
      create: TransactionCreateInput;
      update: TransactionUpdateInput;
    }
  ) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (
    args: { data: UserUpdateInput; where: UserWhereUniqueInput }
  ) => UserPromise;
  updateManyUsers: (
    args: { data: UserUpdateManyMutationInput; where?: UserWhereInput }
  ) => BatchPayloadPromise;
  upsertUser: (
    args: {
      where: UserWhereUniqueInput;
      create: UserCreateInput;
      update: UserUpdateInput;
    }
  ) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  client: (
    where?: ClientSubscriptionWhereInput
  ) => ClientSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  purchase: (
    where?: PurchaseSubscriptionWhereInput
  ) => PurchaseSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "date_ASC"
  | "date_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "path_ASC"
  | "path_DESC"
  | "uri_ASC"
  | "uri_DESC"
  | "mimetype_ASC"
  | "mimetype_DESC"
  | "extension_ASC"
  | "extension_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransactionType = "PAYMENT" | "PURCHASE";

export type PurchaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_ASC"
  | "total_DESC"
  | "date_ASC"
  | "date_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ClientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "identity_ASC"
  | "identity_DESC"
  | "secret_ASC"
  | "secret_DESC"
  | "name_ASC"
  | "name_DESC"
  | "trusted_ASC"
  | "trusted_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "type_ASC"
  | "type_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "index_ASC"
  | "index_DESC"
  | "show_ASC"
  | "show_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "balance_ASC"
  | "balance_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export interface UserCreateOneWithoutPaymentsInput {
  create?: UserCreateWithoutPaymentsInput;
  connect?: UserWhereUniqueInput;
}

export type ClientWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  identity?: String;
}>;

export interface ItemCreateInput {
  product: ProductCreateOneInput;
  user: UserCreateOneWithoutItemsInput;
  price: Float;
  amount: Int;
}

export interface UserUpsertWithoutPaymentsInput {
  update: UserUpdateWithoutPaymentsDataInput;
  create: UserCreateWithoutPaymentsInput;
}

export interface ProductCreateOneInput {
  create?: ProductCreateInput;
  connect?: ProductWhereUniqueInput;
}

export interface ProductUpdateDataInput {
  name?: String;
  price?: Float;
  index?: Int;
  show?: Boolean;
}

export interface ProductCreateInput {
  name: String;
  price: Float;
  index: Int;
  show?: Boolean;
}

export type EventWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserCreateOneWithoutItemsInput {
  create?: UserCreateWithoutItemsInput;
  connect?: UserWhereUniqueInput;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: TransactionWhereInput;
  AND?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  OR?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
  NOT?: TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput;
}

export interface UserCreateWithoutItemsInput {
  name: String;
  email: String;
  password: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  balance?: Float;
}

export type FileWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface PurchaseCreateManyWithoutUserInput {
  create?: PurchaseCreateWithoutUserInput[] | PurchaseCreateWithoutUserInput;
  connect?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
}

export interface FileWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  filename?: String;
  filename_not?: String;
  filename_in?: String[] | String;
  filename_not_in?: String[] | String;
  filename_lt?: String;
  filename_lte?: String;
  filename_gt?: String;
  filename_gte?: String;
  filename_contains?: String;
  filename_not_contains?: String;
  filename_starts_with?: String;
  filename_not_starts_with?: String;
  filename_ends_with?: String;
  filename_not_ends_with?: String;
  path?: String;
  path_not?: String;
  path_in?: String[] | String;
  path_not_in?: String[] | String;
  path_lt?: String;
  path_lte?: String;
  path_gt?: String;
  path_gte?: String;
  path_contains?: String;
  path_not_contains?: String;
  path_starts_with?: String;
  path_not_starts_with?: String;
  path_ends_with?: String;
  path_not_ends_with?: String;
  uri?: String;
  uri_not?: String;
  uri_in?: String[] | String;
  uri_not_in?: String[] | String;
  uri_lt?: String;
  uri_lte?: String;
  uri_gt?: String;
  uri_gte?: String;
  uri_contains?: String;
  uri_not_contains?: String;
  uri_starts_with?: String;
  uri_not_starts_with?: String;
  uri_ends_with?: String;
  uri_not_ends_with?: String;
  mimetype?: String;
  mimetype_not?: String;
  mimetype_in?: String[] | String;
  mimetype_not_in?: String[] | String;
  mimetype_lt?: String;
  mimetype_lte?: String;
  mimetype_gt?: String;
  mimetype_gte?: String;
  mimetype_contains?: String;
  mimetype_not_contains?: String;
  mimetype_starts_with?: String;
  mimetype_not_starts_with?: String;
  mimetype_ends_with?: String;
  mimetype_not_ends_with?: String;
  extension?: String;
  extension_not?: String;
  extension_in?: String[] | String;
  extension_not_in?: String[] | String;
  extension_lt?: String;
  extension_lte?: String;
  extension_gt?: String;
  extension_gte?: String;
  extension_contains?: String;
  extension_not_contains?: String;
  extension_starts_with?: String;
  extension_not_starts_with?: String;
  extension_ends_with?: String;
  extension_not_ends_with?: String;
  createdAt?: DateTimeInput;
  createdAt_not?: DateTimeInput;
  createdAt_in?: DateTimeInput[] | DateTimeInput;
  createdAt_not_in?: DateTimeInput[] | DateTimeInput;
  createdAt_lt?: DateTimeInput;
  createdAt_lte?: DateTimeInput;
  createdAt_gt?: DateTimeInput;
  createdAt_gte?: DateTimeInput;
  AND?: FileWhereInput[] | FileWhereInput;
  OR?: FileWhereInput[] | FileWhereInput;
  NOT?: FileWhereInput[] | FileWhereInput;
}

export interface PurchaseCreateWithoutUserInput {
  items?: ItemCreateManyInput;
  transaction: TransactionCreateOneWithoutPurchaseInput;
  total: Float;
  date: DateTimeInput;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ItemWhereInput;
  AND?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  OR?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
  NOT?: ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput;
}

export interface ItemCreateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: EventWhereInput;
  AND?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  OR?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
  NOT?: EventSubscriptionWhereInput[] | EventSubscriptionWhereInput;
}

export interface TransactionCreateOneWithoutPurchaseInput {
  create?: TransactionCreateWithoutPurchaseInput;
  connect?: TransactionWhereUniqueInput;
}

export interface ClientSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ClientWhereInput;
  AND?: ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput;
  OR?: ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput;
  NOT?: ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput;
}

export interface TransactionCreateWithoutPurchaseInput {
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  payment?: PaymentCreateOneWithoutTransactionInput;
}

export interface UserUpdateInput {
  name?: String;
  email?: String;
  password?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  balance?: Float;
}

export interface UserCreateOneWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface PurchaseWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  transaction?: TransactionWhereInput;
  total?: Float;
  total_not?: Float;
  total_in?: Float[] | Float;
  total_not_in?: Float[] | Float;
  total_lt?: Float;
  total_lte?: Float;
  total_gt?: Float;
  total_gte?: Float;
  user?: UserWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: PurchaseWhereInput[] | PurchaseWhereInput;
  OR?: PurchaseWhereInput[] | PurchaseWhereInput;
  NOT?: PurchaseWhereInput[] | PurchaseWhereInput;
}

export interface UserCreateWithoutTransactionsInput {
  name: String;
  email: String;
  password: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  balance?: Float;
}

export interface ProductWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  index?: Int;
  index_not?: Int;
  index_in?: Int[] | Int;
  index_not_in?: Int[] | Int;
  index_lt?: Int;
  index_lte?: Int;
  index_gt?: Int;
  index_gte?: Int;
  show?: Boolean;
  show_not?: Boolean;
  AND?: ProductWhereInput[] | ProductWhereInput;
  OR?: ProductWhereInput[] | ProductWhereInput;
  NOT?: ProductWhereInput[] | ProductWhereInput;
}

export interface PaymentCreateManyWithoutUserInput {
  create?: PaymentCreateWithoutUserInput[] | PaymentCreateWithoutUserInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
}

export interface PaymentWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  user?: UserWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  transaction?: TransactionWhereInput;
  AND?: PaymentWhereInput[] | PaymentWhereInput;
  OR?: PaymentWhereInput[] | PaymentWhereInput;
  NOT?: PaymentWhereInput[] | PaymentWhereInput;
}

export interface PaymentCreateWithoutUserInput {
  amount: Float;
  date: DateTimeInput;
  transaction: TransactionCreateOneWithoutPaymentInput;
}

export interface TransactionUpdateManyMutationInput {
  date?: DateTimeInput;
  type?: TransactionType;
}

export interface TransactionCreateOneWithoutPaymentInput {
  create?: TransactionCreateWithoutPaymentInput;
  connect?: TransactionWhereUniqueInput;
}

export interface TransactionCreateInput {
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  payment?: PaymentCreateOneWithoutTransactionInput;
  purchase?: PurchaseCreateOneWithoutTransactionInput;
}

export interface TransactionCreateWithoutPaymentInput {
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  purchase?: PurchaseCreateOneWithoutTransactionInput;
}

export interface PurchaseUpdateInput {
  items?: ItemUpdateManyInput;
  transaction?: TransactionUpdateOneRequiredWithoutPurchaseInput;
  total?: Float;
  user?: UserUpdateOneRequiredWithoutPurchasesInput;
  date?: DateTimeInput;
}

export interface PurchaseCreateOneWithoutTransactionInput {
  create?: PurchaseCreateWithoutTransactionInput;
  connect?: PurchaseWhereUniqueInput;
}

export interface ProductUpdateManyMutationInput {
  name?: String;
  price?: Float;
  index?: Int;
  show?: Boolean;
}

export interface PurchaseCreateWithoutTransactionInput {
  items?: ItemCreateManyInput;
  total: Float;
  user: UserCreateOneWithoutPurchasesInput;
  date: DateTimeInput;
}

export interface ProductUpdateInput {
  name?: String;
  price?: Float;
  index?: Int;
  show?: Boolean;
}

export interface UserCreateOneWithoutPurchasesInput {
  create?: UserCreateWithoutPurchasesInput;
  connect?: UserWhereUniqueInput;
}

export interface PaymentUpdateInput {
  amount?: Float;
  user?: UserUpdateOneRequiredWithoutPaymentsInput;
  date?: DateTimeInput;
  transaction?: TransactionUpdateOneRequiredWithoutPaymentInput;
}

export interface UserCreateWithoutPurchasesInput {
  name: String;
  email: String;
  password: String;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  balance?: Float;
}

export interface PaymentCreateInput {
  amount: Float;
  user: UserCreateOneWithoutPaymentsInput;
  date: DateTimeInput;
  transaction: TransactionCreateOneWithoutPaymentInput;
}

export interface TransactionCreateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
}

export interface UserUpsertWithoutItemsInput {
  update: UserUpdateWithoutItemsDataInput;
  create: UserCreateWithoutItemsInput;
}

export interface TransactionCreateWithoutUserInput {
  date: DateTimeInput;
  type: TransactionType;
  payment?: PaymentCreateOneWithoutTransactionInput;
  purchase?: PurchaseCreateOneWithoutTransactionInput;
}

export interface PurchaseUpdateManyDataInput {
  total?: Float;
  date?: DateTimeInput;
}

export interface PaymentCreateOneWithoutTransactionInput {
  create?: PaymentCreateWithoutTransactionInput;
  connect?: PaymentWhereUniqueInput;
}

export interface PurchaseScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  total?: Float;
  total_not?: Float;
  total_in?: Float[] | Float;
  total_not_in?: Float[] | Float;
  total_lt?: Float;
  total_lte?: Float;
  total_gt?: Float;
  total_gte?: Float;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: PurchaseScalarWhereInput[] | PurchaseScalarWhereInput;
  OR?: PurchaseScalarWhereInput[] | PurchaseScalarWhereInput;
  NOT?: PurchaseScalarWhereInput[] | PurchaseScalarWhereInput;
}

export interface PaymentCreateWithoutTransactionInput {
  amount: Float;
  user: UserCreateOneWithoutPaymentsInput;
  date: DateTimeInput;
}

export type PurchaseWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutUserDataInput;
  create: TransactionCreateWithoutUserInput;
}

export interface UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput;
  create: UserCreateWithoutTransactionsInput;
}

export interface UserCreateWithoutPaymentsInput {
  name: String;
  email: String;
  password: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  balance?: Float;
}

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface ItemCreateManyWithoutUserInput {
  create?: ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
}

export interface PaymentScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  amount?: Float;
  amount_not?: Float;
  amount_in?: Float[] | Float;
  amount_not_in?: Float[] | Float;
  amount_lt?: Float;
  amount_lte?: Float;
  amount_gt?: Float;
  amount_gte?: Float;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  AND?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  OR?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  NOT?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
}

export interface ItemCreateWithoutUserInput {
  product: ProductCreateOneInput;
  price: Float;
  amount: Int;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
  email?: String;
}>;

export interface ItemUpdateInput {
  product?: ProductUpdateOneRequiredInput;
  user?: UserUpdateOneRequiredWithoutItemsInput;
  price?: Float;
  amount?: Int;
}

export interface PurchaseUpsertWithoutTransactionInput {
  update: PurchaseUpdateWithoutTransactionDataInput;
  create: PurchaseCreateWithoutTransactionInput;
}

export interface ProductUpdateOneRequiredInput {
  create?: ProductCreateInput;
  update?: ProductUpdateDataInput;
  upsert?: ProductUpsertNestedInput;
  connect?: ProductWhereUniqueInput;
}

export interface TransactionUpdateManyDataInput {
  date?: DateTimeInput;
  type?: TransactionType;
}

export interface PaymentUpsertWithoutTransactionInput {
  update: PaymentUpdateWithoutTransactionDataInput;
  create: PaymentCreateWithoutTransactionInput;
}

export interface ClientCreateInput {
  identity: String;
  secret: String;
  name: String;
  trusted?: Boolean;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface ClientUpdateManyMutationInput {
  identity?: String;
  secret?: String;
  name?: String;
  trusted?: Boolean;
}

export interface UserUpdateOneRequiredWithoutItemsInput {
  create?: UserCreateWithoutItemsInput;
  update?: UserUpdateWithoutItemsDataInput;
  upsert?: UserUpsertWithoutItemsInput;
  connect?: UserWhereUniqueInput;
}

export interface TransactionScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  AND?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  OR?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  NOT?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
}

export interface UserUpdateWithoutItemsDataInput {
  name?: String;
  email?: String;
  password?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  balance?: Float;
}

export interface EventUpdateInput {
  title?: String;
  description?: String;
  date?: DateTimeInput;
  thumbnail?: String;
}

export interface PurchaseUpdateManyWithoutUserInput {
  create?: PurchaseCreateWithoutUserInput[] | PurchaseCreateWithoutUserInput;
  delete?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
  connect?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
  set?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
  disconnect?: PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput;
  update?:
    | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    | PurchaseUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    | PurchaseUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: PurchaseScalarWhereInput[] | PurchaseScalarWhereInput;
  updateMany?:
    | PurchaseUpdateManyWithWhereNestedInput[]
    | PurchaseUpdateManyWithWhereNestedInput;
}

export interface FileCreateInput {
  filename: String;
  path: String;
  uri: String;
  mimetype: String;
  extension: String;
}

export interface PurchaseUpdateWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput;
  data: PurchaseUpdateWithoutUserDataInput;
}

export interface FileUpdateManyMutationInput {
  filename?: String;
  path?: String;
  uri?: String;
  mimetype?: String;
  extension?: String;
}

export interface PurchaseUpdateWithoutUserDataInput {
  items?: ItemUpdateManyInput;
  transaction?: TransactionUpdateOneRequiredWithoutPurchaseInput;
  total?: Float;
  date?: DateTimeInput;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: UserWhereInput;
  AND?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  OR?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
  NOT?: UserSubscriptionWhereInput[] | UserSubscriptionWhereInput;
}

export interface ItemUpdateManyInput {
  create?: ItemCreateInput[] | ItemCreateInput;
  update?:
    | ItemUpdateWithWhereUniqueNestedInput[]
    | ItemUpdateWithWhereUniqueNestedInput;
  upsert?:
    | ItemUpsertWithWhereUniqueNestedInput[]
    | ItemUpsertWithWhereUniqueNestedInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  set?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  deleteMany?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  updateMany?:
    | ItemUpdateManyWithWhereNestedInput[]
    | ItemUpdateManyWithWhereNestedInput;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: ProductWhereInput;
  AND?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  OR?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
  NOT?: ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput;
}

export interface ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateDataInput;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: FileWhereInput;
  AND?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  OR?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
  NOT?: FileSubscriptionWhereInput[] | FileSubscriptionWhereInput;
}

export interface ItemUpdateDataInput {
  product?: ProductUpdateOneRequiredInput;
  user?: UserUpdateOneRequiredWithoutItemsInput;
  price?: Float;
  amount?: Int;
}

export interface UserUpdateManyMutationInput {
  name?: String;
  email?: String;
  password?: String;
  balance?: Float;
}

export interface ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface ItemWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  product?: ProductWhereInput;
  user?: UserWhereInput;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  AND?: ItemWhereInput[] | ItemWhereInput;
  OR?: ItemWhereInput[] | ItemWhereInput;
  NOT?: ItemWhereInput[] | ItemWhereInput;
}

export interface ItemScalarWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  price?: Float;
  price_not?: Float;
  price_in?: Float[] | Float;
  price_not_in?: Float[] | Float;
  price_lt?: Float;
  price_lte?: Float;
  price_gt?: Float;
  price_gte?: Float;
  amount?: Int;
  amount_not?: Int;
  amount_in?: Int[] | Int;
  amount_not_in?: Int[] | Int;
  amount_lt?: Int;
  amount_lte?: Int;
  amount_gt?: Int;
  amount_gte?: Int;
  AND?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  OR?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  NOT?: ItemScalarWhereInput[] | ItemScalarWhereInput;
}

export interface TransactionWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  user?: UserWhereInput;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  type?: TransactionType;
  type_not?: TransactionType;
  type_in?: TransactionType[] | TransactionType;
  type_not_in?: TransactionType[] | TransactionType;
  payment?: PaymentWhereInput;
  purchase?: PurchaseWhereInput;
  AND?: TransactionWhereInput[] | TransactionWhereInput;
  OR?: TransactionWhereInput[] | TransactionWhereInput;
  NOT?: TransactionWhereInput[] | TransactionWhereInput;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface PurchaseUpdateManyMutationInput {
  total?: Float;
  date?: DateTimeInput;
}

export interface ItemUpdateManyDataInput {
  price?: Float;
  amount?: Int;
}

export interface ClientWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  identity?: String;
  identity_not?: String;
  identity_in?: String[] | String;
  identity_not_in?: String[] | String;
  identity_lt?: String;
  identity_lte?: String;
  identity_gt?: String;
  identity_gte?: String;
  identity_contains?: String;
  identity_not_contains?: String;
  identity_starts_with?: String;
  identity_not_starts_with?: String;
  identity_ends_with?: String;
  identity_not_ends_with?: String;
  secret?: String;
  secret_not?: String;
  secret_in?: String[] | String;
  secret_not_in?: String[] | String;
  secret_lt?: String;
  secret_lte?: String;
  secret_gt?: String;
  secret_gte?: String;
  secret_contains?: String;
  secret_not_contains?: String;
  secret_starts_with?: String;
  secret_not_starts_with?: String;
  secret_ends_with?: String;
  secret_not_ends_with?: String;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  trusted?: Boolean;
  trusted_not?: Boolean;
  AND?: ClientWhereInput[] | ClientWhereInput;
  OR?: ClientWhereInput[] | ClientWhereInput;
  NOT?: ClientWhereInput[] | ClientWhereInput;
}

export interface TransactionUpdateOneRequiredWithoutPurchaseInput {
  create?: TransactionCreateWithoutPurchaseInput;
  update?: TransactionUpdateWithoutPurchaseDataInput;
  upsert?: TransactionUpsertWithoutPurchaseInput;
  connect?: TransactionWhereUniqueInput;
}

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface TransactionUpdateWithoutPurchaseDataInput {
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
  date?: DateTimeInput;
  type?: TransactionType;
  payment?: PaymentUpdateOneWithoutTransactionInput;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredWithoutTransactionsInput {
  create?: UserCreateWithoutTransactionsInput;
  update?: UserUpdateWithoutTransactionsDataInput;
  upsert?: UserUpsertWithoutTransactionsInput;
  connect?: UserWhereUniqueInput;
}

export interface PurchaseUpsertWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput;
  update: PurchaseUpdateWithoutUserDataInput;
  create: PurchaseCreateWithoutUserInput;
}

export interface UserUpdateWithoutTransactionsDataInput {
  name?: String;
  email?: String;
  password?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  payments?: PaymentUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  balance?: Float;
}

export interface PaymentUpdateManyDataInput {
  amount?: Float;
  date?: DateTimeInput;
}

export interface PaymentUpdateManyWithoutUserInput {
  create?: PaymentCreateWithoutUserInput[] | PaymentCreateWithoutUserInput;
  delete?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  connect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  set?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  disconnect?: PaymentWhereUniqueInput[] | PaymentWhereUniqueInput;
  update?:
    | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    | PaymentUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    | PaymentUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: PaymentScalarWhereInput[] | PaymentScalarWhereInput;
  updateMany?:
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput;
}

export interface PaymentUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutUserDataInput;
  create: PaymentCreateWithoutUserInput;
}

export interface PaymentUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutUserDataInput;
}

export interface UserUpsertWithoutPurchasesInput {
  update: UserUpdateWithoutPurchasesDataInput;
  create: UserCreateWithoutPurchasesInput;
}

export interface PaymentUpdateWithoutUserDataInput {
  amount?: Float;
  date?: DateTimeInput;
  transaction?: TransactionUpdateOneRequiredWithoutPaymentInput;
}

export interface ClientUpdateInput {
  identity?: String;
  secret?: String;
  name?: String;
  trusted?: Boolean;
}

export interface TransactionUpdateOneRequiredWithoutPaymentInput {
  create?: TransactionCreateWithoutPaymentInput;
  update?: TransactionUpdateWithoutPaymentDataInput;
  upsert?: TransactionUpsertWithoutPaymentInput;
  connect?: TransactionWhereUniqueInput;
}

export interface EventCreateInput {
  title: String;
  description: String;
  date: DateTimeInput;
  thumbnail: String;
}

export interface TransactionUpdateWithoutPaymentDataInput {
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
  date?: DateTimeInput;
  type?: TransactionType;
  purchase?: PurchaseUpdateOneWithoutTransactionInput;
}

export interface FileUpdateInput {
  filename?: String;
  path?: String;
  uri?: String;
  mimetype?: String;
  extension?: String;
}

export interface PurchaseUpdateOneWithoutTransactionInput {
  create?: PurchaseCreateWithoutTransactionInput;
  update?: PurchaseUpdateWithoutTransactionDataInput;
  upsert?: PurchaseUpsertWithoutTransactionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PurchaseWhereUniqueInput;
}

export interface PurchaseSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PurchaseWhereInput;
  AND?: PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput;
  OR?: PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput;
  NOT?: PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput;
}

export interface PurchaseUpdateWithoutTransactionDataInput {
  items?: ItemUpdateManyInput;
  total?: Float;
  user?: UserUpdateOneRequiredWithoutPurchasesInput;
  date?: DateTimeInput;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: ID_Input;
}>;

export interface UserUpdateOneRequiredWithoutPurchasesInput {
  create?: UserCreateWithoutPurchasesInput;
  update?: UserUpdateWithoutPurchasesDataInput;
  upsert?: UserUpsertWithoutPurchasesInput;
  connect?: UserWhereUniqueInput;
}

export interface UserWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  name?: String;
  name_not?: String;
  name_in?: String[] | String;
  name_not_in?: String[] | String;
  name_lt?: String;
  name_lte?: String;
  name_gt?: String;
  name_gte?: String;
  name_contains?: String;
  name_not_contains?: String;
  name_starts_with?: String;
  name_not_starts_with?: String;
  name_ends_with?: String;
  name_not_ends_with?: String;
  email?: String;
  email_not?: String;
  email_in?: String[] | String;
  email_not_in?: String[] | String;
  email_lt?: String;
  email_lte?: String;
  email_gt?: String;
  email_gte?: String;
  email_contains?: String;
  email_not_contains?: String;
  email_starts_with?: String;
  email_not_starts_with?: String;
  email_ends_with?: String;
  email_not_ends_with?: String;
  password?: String;
  password_not?: String;
  password_in?: String[] | String;
  password_not_in?: String[] | String;
  password_lt?: String;
  password_lte?: String;
  password_gt?: String;
  password_gte?: String;
  password_contains?: String;
  password_not_contains?: String;
  password_starts_with?: String;
  password_not_starts_with?: String;
  password_ends_with?: String;
  password_not_ends_with?: String;
  purchases_every?: PurchaseWhereInput;
  purchases_some?: PurchaseWhereInput;
  purchases_none?: PurchaseWhereInput;
  payments_every?: PaymentWhereInput;
  payments_some?: PaymentWhereInput;
  payments_none?: PaymentWhereInput;
  transactions_every?: TransactionWhereInput;
  transactions_some?: TransactionWhereInput;
  transactions_none?: TransactionWhereInput;
  items_every?: ItemWhereInput;
  items_some?: ItemWhereInput;
  items_none?: ItemWhereInput;
  balance?: Float;
  balance_not?: Float;
  balance_in?: Float[] | Float;
  balance_not_in?: Float[] | Float;
  balance_lt?: Float;
  balance_lte?: Float;
  balance_gt?: Float;
  balance_gte?: Float;
  AND?: UserWhereInput[] | UserWhereInput;
  OR?: UserWhereInput[] | UserWhereInput;
  NOT?: UserWhereInput[] | UserWhereInput;
}

export interface UserUpdateWithoutPurchasesDataInput {
  name?: String;
  email?: String;
  password?: String;
  payments?: PaymentUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  balance?: Float;
}

export interface PurchaseCreateInput {
  items?: ItemCreateManyInput;
  transaction: TransactionCreateOneWithoutPurchaseInput;
  total: Float;
  user: UserCreateOneWithoutPurchasesInput;
  date: DateTimeInput;
}

export interface TransactionUpdateManyWithoutUserInput {
  create?:
    | TransactionCreateWithoutUserInput[]
    | TransactionCreateWithoutUserInput;
  delete?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  connect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  set?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  disconnect?: TransactionWhereUniqueInput[] | TransactionWhereUniqueInput;
  update?:
    | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    | TransactionUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    | TransactionUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: TransactionScalarWhereInput[] | TransactionScalarWhereInput;
  updateMany?:
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput;
}

export interface ItemUpdateManyMutationInput {
  price?: Float;
  amount?: Int;
}

export interface TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutUserDataInput;
}

export interface TransactionUpsertWithoutPurchaseInput {
  update: TransactionUpdateWithoutPurchaseDataInput;
  create: TransactionCreateWithoutPurchaseInput;
}

export interface TransactionUpdateWithoutUserDataInput {
  date?: DateTimeInput;
  type?: TransactionType;
  payment?: PaymentUpdateOneWithoutTransactionInput;
  purchase?: PurchaseUpdateOneWithoutTransactionInput;
}

export interface TransactionUpsertWithoutPaymentInput {
  update: TransactionUpdateWithoutPaymentDataInput;
  create: TransactionCreateWithoutPaymentInput;
}

export interface PaymentUpdateOneWithoutTransactionInput {
  create?: PaymentCreateWithoutTransactionInput;
  update?: PaymentUpdateWithoutTransactionDataInput;
  upsert?: PaymentUpsertWithoutTransactionInput;
  delete?: Boolean;
  disconnect?: Boolean;
  connect?: PaymentWhereUniqueInput;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface PaymentUpdateWithoutTransactionDataInput {
  amount?: Float;
  user?: UserUpdateOneRequiredWithoutPaymentsInput;
  date?: DateTimeInput;
}

export interface EventWhereInput {
  id?: ID_Input;
  id_not?: ID_Input;
  id_in?: ID_Input[] | ID_Input;
  id_not_in?: ID_Input[] | ID_Input;
  id_lt?: ID_Input;
  id_lte?: ID_Input;
  id_gt?: ID_Input;
  id_gte?: ID_Input;
  id_contains?: ID_Input;
  id_not_contains?: ID_Input;
  id_starts_with?: ID_Input;
  id_not_starts_with?: ID_Input;
  id_ends_with?: ID_Input;
  id_not_ends_with?: ID_Input;
  title?: String;
  title_not?: String;
  title_in?: String[] | String;
  title_not_in?: String[] | String;
  title_lt?: String;
  title_lte?: String;
  title_gt?: String;
  title_gte?: String;
  title_contains?: String;
  title_not_contains?: String;
  title_starts_with?: String;
  title_not_starts_with?: String;
  title_ends_with?: String;
  title_not_ends_with?: String;
  description?: String;
  description_not?: String;
  description_in?: String[] | String;
  description_not_in?: String[] | String;
  description_lt?: String;
  description_lte?: String;
  description_gt?: String;
  description_gte?: String;
  description_contains?: String;
  description_not_contains?: String;
  description_starts_with?: String;
  description_not_starts_with?: String;
  description_ends_with?: String;
  description_not_ends_with?: String;
  date?: DateTimeInput;
  date_not?: DateTimeInput;
  date_in?: DateTimeInput[] | DateTimeInput;
  date_not_in?: DateTimeInput[] | DateTimeInput;
  date_lt?: DateTimeInput;
  date_lte?: DateTimeInput;
  date_gt?: DateTimeInput;
  date_gte?: DateTimeInput;
  thumbnail?: String;
  thumbnail_not?: String;
  thumbnail_in?: String[] | String;
  thumbnail_not_in?: String[] | String;
  thumbnail_lt?: String;
  thumbnail_lte?: String;
  thumbnail_gt?: String;
  thumbnail_gte?: String;
  thumbnail_contains?: String;
  thumbnail_not_contains?: String;
  thumbnail_starts_with?: String;
  thumbnail_not_starts_with?: String;
  thumbnail_ends_with?: String;
  thumbnail_not_ends_with?: String;
  AND?: EventWhereInput[] | EventWhereInput;
  OR?: EventWhereInput[] | EventWhereInput;
  NOT?: EventWhereInput[] | EventWhereInput;
}

export interface UserUpdateOneRequiredWithoutPaymentsInput {
  create?: UserCreateWithoutPaymentsInput;
  update?: UserUpdateWithoutPaymentsDataInput;
  upsert?: UserUpsertWithoutPaymentsInput;
  connect?: UserWhereUniqueInput;
}

export interface UserCreateInput {
  name: String;
  email: String;
  password: String;
  purchases?: PurchaseCreateManyWithoutUserInput;
  payments?: PaymentCreateManyWithoutUserInput;
  transactions?: TransactionCreateManyWithoutUserInput;
  items?: ItemCreateManyWithoutUserInput;
  balance?: Float;
}

export interface UserUpdateWithoutPaymentsDataInput {
  name?: String;
  email?: String;
  password?: String;
  purchases?: PurchaseUpdateManyWithoutUserInput;
  transactions?: TransactionUpdateManyWithoutUserInput;
  items?: ItemUpdateManyWithoutUserInput;
  balance?: Float;
}

export interface PaymentUpdateManyMutationInput {
  amount?: Float;
  date?: DateTimeInput;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface ItemUpsertWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutUserDataInput;
  create: ItemCreateWithoutUserInput;
}

export interface ItemUpdateWithoutUserDataInput {
  product?: ProductUpdateOneRequiredInput;
  price?: Float;
  amount?: Int;
}

export interface ItemUpdateWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutUserDataInput;
}

export interface ItemUpdateManyWithoutUserInput {
  create?: ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput;
  delete?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  connect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  set?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  disconnect?: ItemWhereUniqueInput[] | ItemWhereUniqueInput;
  update?:
    | ItemUpdateWithWhereUniqueWithoutUserInput[]
    | ItemUpdateWithWhereUniqueWithoutUserInput;
  upsert?:
    | ItemUpsertWithWhereUniqueWithoutUserInput[]
    | ItemUpsertWithWhereUniqueWithoutUserInput;
  deleteMany?: ItemScalarWhereInput[] | ItemScalarWhereInput;
  updateMany?:
    | ItemUpdateManyWithWhereNestedInput[]
    | ItemUpdateManyWithWhereNestedInput;
}

export interface PurchaseUpdateManyWithWhereNestedInput {
  where: PurchaseScalarWhereInput;
  data: PurchaseUpdateManyDataInput;
}

export interface TransactionUpdateInput {
  user?: UserUpdateOneRequiredWithoutTransactionsInput;
  date?: DateTimeInput;
  type?: TransactionType;
  payment?: PaymentUpdateOneWithoutTransactionInput;
  purchase?: PurchaseUpdateOneWithoutTransactionInput;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: MutationType[] | MutationType;
  updatedFields_contains?: String;
  updatedFields_contains_every?: String[] | String;
  updatedFields_contains_some?: String[] | String;
  node?: PaymentWhereInput;
  AND?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  OR?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
  NOT?: PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput;
}

export interface EventUpdateManyMutationInput {
  title?: String;
  description?: String;
  date?: DateTimeInput;
  thumbnail?: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  balance: Float;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  balance: () => Promise<Float>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  balance: () => Promise<AsyncIterator<Float>>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  password: String;
  balance: Float;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  purchases: <T = FragmentableArray<Purchase>>(
    args?: {
      where?: PurchaseWhereInput;
      orderBy?: PurchaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  payments: <T = FragmentableArray<Payment>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transactions: <T = FragmentableArray<Transaction>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  items: <T = FragmentableArray<Item>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  balance: () => Promise<Float>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  purchases: <T = Promise<AsyncIterator<PurchaseSubscription>>>(
    args?: {
      where?: PurchaseWhereInput;
      orderBy?: PurchaseOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(
    args?: {
      where?: PaymentWhereInput;
      orderBy?: PaymentOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(
    args?: {
      where?: TransactionWhereInput;
      orderBy?: TransactionOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  balance: () => Promise<AsyncIterator<Float>>;
}

export interface Event {
  id: ID_Output;
  title: String;
  description: String;
  date: DateTimeOutput;
  thumbnail: String;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  thumbnail: () => Promise<String>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
}

export interface ClientEdge {
  node: Client;
  cursor: String;
}

export interface ClientEdgePromise extends Promise<ClientEdge>, Fragmentable {
  node: <T = ClientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClientEdgeSubscription
  extends Promise<AsyncIterator<ClientEdge>>,
    Fragmentable {
  node: <T = ClientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface TransactionPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  type: TransactionType;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface Client {
  id: ID_Output;
  identity: String;
  secret: String;
  name: String;
  trusted: Boolean;
}

export interface ClientPromise extends Promise<Client>, Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientSubscription
  extends Promise<AsyncIterator<Client>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identity: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trusted: () => Promise<AsyncIterator<Boolean>>;
}

export interface Product {
  id: ID_Output;
  name: String;
  price: Float;
  index: Int;
  show: Boolean;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  show: () => Promise<Boolean>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  index: () => Promise<AsyncIterator<Int>>;
  show: () => Promise<AsyncIterator<Boolean>>;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Item {
  id: ID_Output;
  price: Float;
  amount: Int;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  user: <T = UserPromise>() => T;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  user: <T = UserSubscription>() => T;
  price: () => Promise<AsyncIterator<Float>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePurchase {
  count: Int;
}

export interface AggregatePurchasePromise
  extends Promise<AggregatePurchase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePurchaseSubscription
  extends Promise<AsyncIterator<AggregatePurchase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface PurchaseConnection {
  pageInfo: PageInfo;
  edges: PurchaseEdge[];
}

export interface PurchaseConnectionPromise
  extends Promise<PurchaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PurchaseEdge>>() => T;
  aggregate: <T = AggregatePurchasePromise>() => T;
}

export interface PurchaseConnectionSubscription
  extends Promise<AsyncIterator<PurchaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PurchaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePurchaseSubscription>() => T;
}

export interface ClientSubscriptionPayload {
  mutation: MutationType;
  node: Client;
  updatedFields: String[];
  previousValues: ClientPreviousValues;
}

export interface ClientSubscriptionPayloadPromise
  extends Promise<ClientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClientPreviousValuesPromise>() => T;
}

export interface ClientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClientPreviousValuesSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ClientPreviousValues {
  id: ID_Output;
  identity: String;
  secret: String;
  name: String;
  trusted: Boolean;
}

export interface ClientPreviousValuesPromise
  extends Promise<ClientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientPreviousValuesSubscription
  extends Promise<AsyncIterator<ClientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identity: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trusted: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  date: DateTimeOutput;
  thumbnail: String;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  thumbnail: () => Promise<String>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Payment {
  id: ID_Output;
  amount: Float;
  date: DateTimeOutput;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  transaction: <T = TransactionPromise>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  transaction: <T = TransactionSubscription>() => T;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface ClientConnection {
  pageInfo: PageInfo;
  edges: ClientEdge[];
}

export interface ClientConnectionPromise
  extends Promise<ClientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClientEdge>>() => T;
  aggregate: <T = AggregateClientPromise>() => T;
}

export interface ClientConnectionSubscription
  extends Promise<AsyncIterator<ClientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClientSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  filename: String;
  path: String;
  uri: String;
  mimetype: String;
  extension: String;
  createdAt: DateTimeOutput;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  uri: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  filename: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  extension: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  price: Float;
  amount: Int;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Float>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateClient {
  count: Int;
}

export interface AggregateClientPromise
  extends Promise<AggregateClient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClientSubscription
  extends Promise<AsyncIterator<AggregateClient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  amount: Float;
  date: DateTimeOutput;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  date: () => Promise<DateTimeOutput>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface Transaction {
  id: ID_Output;
  date: DateTimeOutput;
  type: TransactionType;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
  payment: <T = PaymentPromise>() => T;
  purchase: <T = PurchasePromise>() => T;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  payment: <T = PaymentSubscription>() => T;
  purchase: <T = PurchaseSubscription>() => T;
}

export interface File {
  id: ID_Output;
  filename: String;
  path: String;
  uri: String;
  mimetype: String;
  extension: String;
  createdAt: DateTimeOutput;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  uri: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  filename: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  extension: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface PurchaseEdge {
  node: Purchase;
  cursor: String;
}

export interface PurchaseEdgePromise
  extends Promise<PurchaseEdge>,
    Fragmentable {
  node: <T = PurchasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PurchaseEdgeSubscription
  extends Promise<AsyncIterator<PurchaseEdge>>,
    Fragmentable {
  node: <T = PurchaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PurchasePreviousValues {
  id: ID_Output;
  total: Float;
  date: DateTimeOutput;
}

export interface PurchasePreviousValuesPromise
  extends Promise<PurchasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  date: () => Promise<DateTimeOutput>;
}

export interface PurchasePreviousValuesSubscription
  extends Promise<AsyncIterator<PurchasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PurchaseSubscriptionPayload {
  mutation: MutationType;
  node: Purchase;
  updatedFields: String[];
  previousValues: PurchasePreviousValues;
}

export interface PurchaseSubscriptionPayloadPromise
  extends Promise<PurchaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PurchasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PurchasePreviousValuesPromise>() => T;
}

export interface PurchaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PurchaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PurchaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PurchasePreviousValuesSubscription>() => T;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  price: Float;
  index: Int;
  show: Boolean;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  show: () => Promise<Boolean>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  index: () => Promise<AsyncIterator<Int>>;
  show: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Purchase {
  id: ID_Output;
  total: Float;
  date: DateTimeOutput;
}

export interface PurchasePromise extends Promise<Purchase>, Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<Item>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transaction: <T = TransactionPromise>() => T;
  total: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface PurchaseSubscription
  extends Promise<AsyncIterator<Purchase>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(
    args?: {
      where?: ItemWhereInput;
      orderBy?: ItemOrderByInput;
      skip?: Int;
      after?: String;
      before?: String;
      first?: Int;
      last?: Int;
    }
  ) => T;
  transaction: <T = TransactionSubscription>() => T;
  total: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point). 
*/
export type Float = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1. 
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Client",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Purchase",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "TransactionType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
