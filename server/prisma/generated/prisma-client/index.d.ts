// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  chat: (where?: ChatWhereInput) => Promise<boolean>;
  client: (where?: ClientWhereInput) => Promise<boolean>;
  comment: (where?: CommentWhereInput) => Promise<boolean>;
  event: (where?: EventWhereInput) => Promise<boolean>;
  file: (where?: FileWhereInput) => Promise<boolean>;
  item: (where?: ItemWhereInput) => Promise<boolean>;
  message: (where?: MessageWhereInput) => Promise<boolean>;
  payment: (where?: PaymentWhereInput) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  purchase: (where?: PurchaseWhereInput) => Promise<boolean>;
  todo: (where?: TodoWhereInput) => Promise<boolean>;
  transaction: (where?: TransactionWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  chat: (where: ChatWhereUniqueInput) => ChatNullablePromise;
  chats: (args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Chat>;
  chatsConnection: (args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChatConnectionPromise;
  client: (where: ClientWhereUniqueInput) => ClientNullablePromise;
  clients: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Client>;
  clientsConnection: (args?: {
    where?: ClientWhereInput;
    orderBy?: ClientOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ClientConnectionPromise;
  comment: (where: CommentWhereUniqueInput) => CommentNullablePromise;
  comments: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Comment>;
  commentsConnection: (args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CommentConnectionPromise;
  event: (where: EventWhereUniqueInput) => EventNullablePromise;
  events: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Event>;
  eventsConnection: (args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EventConnectionPromise;
  file: (where: FileWhereUniqueInput) => FileNullablePromise;
  files: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<File>;
  filesConnection: (args?: {
    where?: FileWhereInput;
    orderBy?: FileOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FileConnectionPromise;
  item: (where: ItemWhereUniqueInput) => ItemNullablePromise;
  items: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Item>;
  itemsConnection: (args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ItemConnectionPromise;
  message: (where: MessageWhereUniqueInput) => MessageNullablePromise;
  messages: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Message>;
  messagesConnection: (args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MessageConnectionPromise;
  payment: (where: PaymentWhereUniqueInput) => PaymentNullablePromise;
  payments: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Payment>;
  paymentsConnection: (args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PaymentConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  purchase: (where: PurchaseWhereUniqueInput) => PurchaseNullablePromise;
  purchases: (args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Purchase>;
  purchasesConnection: (args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PurchaseConnectionPromise;
  todo: (where: TodoWhereUniqueInput) => TodoNullablePromise;
  todoes: (args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Todo>;
  todoesConnection: (args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TodoConnectionPromise;
  transaction: (
    where: TransactionWhereUniqueInput
  ) => TransactionNullablePromise;
  transactions: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Transaction>;
  transactionsConnection: (args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TransactionConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createChat: (data: ChatCreateInput) => ChatPromise;
  updateChat: (args: {
    data: ChatUpdateInput;
    where: ChatWhereUniqueInput;
  }) => ChatPromise;
  updateManyChats: (args: {
    data: ChatUpdateManyMutationInput;
    where?: ChatWhereInput;
  }) => BatchPayloadPromise;
  upsertChat: (args: {
    where: ChatWhereUniqueInput;
    create: ChatCreateInput;
    update: ChatUpdateInput;
  }) => ChatPromise;
  deleteChat: (where: ChatWhereUniqueInput) => ChatPromise;
  deleteManyChats: (where?: ChatWhereInput) => BatchPayloadPromise;
  createClient: (data: ClientCreateInput) => ClientPromise;
  updateClient: (args: {
    data: ClientUpdateInput;
    where: ClientWhereUniqueInput;
  }) => ClientPromise;
  updateManyClients: (args: {
    data: ClientUpdateManyMutationInput;
    where?: ClientWhereInput;
  }) => BatchPayloadPromise;
  upsertClient: (args: {
    where: ClientWhereUniqueInput;
    create: ClientCreateInput;
    update: ClientUpdateInput;
  }) => ClientPromise;
  deleteClient: (where: ClientWhereUniqueInput) => ClientPromise;
  deleteManyClients: (where?: ClientWhereInput) => BatchPayloadPromise;
  createComment: (data: CommentCreateInput) => CommentPromise;
  updateComment: (args: {
    data: CommentUpdateInput;
    where: CommentWhereUniqueInput;
  }) => CommentPromise;
  updateManyComments: (args: {
    data: CommentUpdateManyMutationInput;
    where?: CommentWhereInput;
  }) => BatchPayloadPromise;
  upsertComment: (args: {
    where: CommentWhereUniqueInput;
    create: CommentCreateInput;
    update: CommentUpdateInput;
  }) => CommentPromise;
  deleteComment: (where: CommentWhereUniqueInput) => CommentPromise;
  deleteManyComments: (where?: CommentWhereInput) => BatchPayloadPromise;
  createEvent: (data: EventCreateInput) => EventPromise;
  updateEvent: (args: {
    data: EventUpdateInput;
    where: EventWhereUniqueInput;
  }) => EventPromise;
  updateManyEvents: (args: {
    data: EventUpdateManyMutationInput;
    where?: EventWhereInput;
  }) => BatchPayloadPromise;
  upsertEvent: (args: {
    where: EventWhereUniqueInput;
    create: EventCreateInput;
    update: EventUpdateInput;
  }) => EventPromise;
  deleteEvent: (where: EventWhereUniqueInput) => EventPromise;
  deleteManyEvents: (where?: EventWhereInput) => BatchPayloadPromise;
  createFile: (data: FileCreateInput) => FilePromise;
  updateFile: (args: {
    data: FileUpdateInput;
    where: FileWhereUniqueInput;
  }) => FilePromise;
  updateManyFiles: (args: {
    data: FileUpdateManyMutationInput;
    where?: FileWhereInput;
  }) => BatchPayloadPromise;
  upsertFile: (args: {
    where: FileWhereUniqueInput;
    create: FileCreateInput;
    update: FileUpdateInput;
  }) => FilePromise;
  deleteFile: (where: FileWhereUniqueInput) => FilePromise;
  deleteManyFiles: (where?: FileWhereInput) => BatchPayloadPromise;
  createItem: (data: ItemCreateInput) => ItemPromise;
  updateItem: (args: {
    data: ItemUpdateInput;
    where: ItemWhereUniqueInput;
  }) => ItemPromise;
  updateManyItems: (args: {
    data: ItemUpdateManyMutationInput;
    where?: ItemWhereInput;
  }) => BatchPayloadPromise;
  upsertItem: (args: {
    where: ItemWhereUniqueInput;
    create: ItemCreateInput;
    update: ItemUpdateInput;
  }) => ItemPromise;
  deleteItem: (where: ItemWhereUniqueInput) => ItemPromise;
  deleteManyItems: (where?: ItemWhereInput) => BatchPayloadPromise;
  createMessage: (data: MessageCreateInput) => MessagePromise;
  updateMessage: (args: {
    data: MessageUpdateInput;
    where: MessageWhereUniqueInput;
  }) => MessagePromise;
  updateManyMessages: (args: {
    data: MessageUpdateManyMutationInput;
    where?: MessageWhereInput;
  }) => BatchPayloadPromise;
  upsertMessage: (args: {
    where: MessageWhereUniqueInput;
    create: MessageCreateInput;
    update: MessageUpdateInput;
  }) => MessagePromise;
  deleteMessage: (where: MessageWhereUniqueInput) => MessagePromise;
  deleteManyMessages: (where?: MessageWhereInput) => BatchPayloadPromise;
  createPayment: (data: PaymentCreateInput) => PaymentPromise;
  updatePayment: (args: {
    data: PaymentUpdateInput;
    where: PaymentWhereUniqueInput;
  }) => PaymentPromise;
  updateManyPayments: (args: {
    data: PaymentUpdateManyMutationInput;
    where?: PaymentWhereInput;
  }) => BatchPayloadPromise;
  upsertPayment: (args: {
    where: PaymentWhereUniqueInput;
    create: PaymentCreateInput;
    update: PaymentUpdateInput;
  }) => PaymentPromise;
  deletePayment: (where: PaymentWhereUniqueInput) => PaymentPromise;
  deleteManyPayments: (where?: PaymentWhereInput) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: {
    data: PostUpdateInput;
    where: PostWhereUniqueInput;
  }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createPurchase: (data: PurchaseCreateInput) => PurchasePromise;
  updatePurchase: (args: {
    data: PurchaseUpdateInput;
    where: PurchaseWhereUniqueInput;
  }) => PurchasePromise;
  updateManyPurchases: (args: {
    data: PurchaseUpdateManyMutationInput;
    where?: PurchaseWhereInput;
  }) => BatchPayloadPromise;
  upsertPurchase: (args: {
    where: PurchaseWhereUniqueInput;
    create: PurchaseCreateInput;
    update: PurchaseUpdateInput;
  }) => PurchasePromise;
  deletePurchase: (where: PurchaseWhereUniqueInput) => PurchasePromise;
  deleteManyPurchases: (where?: PurchaseWhereInput) => BatchPayloadPromise;
  createTodo: (data: TodoCreateInput) => TodoPromise;
  updateTodo: (args: {
    data: TodoUpdateInput;
    where: TodoWhereUniqueInput;
  }) => TodoPromise;
  updateManyTodoes: (args: {
    data: TodoUpdateManyMutationInput;
    where?: TodoWhereInput;
  }) => BatchPayloadPromise;
  upsertTodo: (args: {
    where: TodoWhereUniqueInput;
    create: TodoCreateInput;
    update: TodoUpdateInput;
  }) => TodoPromise;
  deleteTodo: (where: TodoWhereUniqueInput) => TodoPromise;
  deleteManyTodoes: (where?: TodoWhereInput) => BatchPayloadPromise;
  createTransaction: (data: TransactionCreateInput) => TransactionPromise;
  updateTransaction: (args: {
    data: TransactionUpdateInput;
    where: TransactionWhereUniqueInput;
  }) => TransactionPromise;
  updateManyTransactions: (args: {
    data: TransactionUpdateManyMutationInput;
    where?: TransactionWhereInput;
  }) => BatchPayloadPromise;
  upsertTransaction: (args: {
    where: TransactionWhereUniqueInput;
    create: TransactionCreateInput;
    update: TransactionUpdateInput;
  }) => TransactionPromise;
  deleteTransaction: (where: TransactionWhereUniqueInput) => TransactionPromise;
  deleteManyTransactions: (
    where?: TransactionWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  chat: (
    where?: ChatSubscriptionWhereInput
  ) => ChatSubscriptionPayloadSubscription;
  client: (
    where?: ClientSubscriptionWhereInput
  ) => ClientSubscriptionPayloadSubscription;
  comment: (
    where?: CommentSubscriptionWhereInput
  ) => CommentSubscriptionPayloadSubscription;
  event: (
    where?: EventSubscriptionWhereInput
  ) => EventSubscriptionPayloadSubscription;
  file: (
    where?: FileSubscriptionWhereInput
  ) => FileSubscriptionPayloadSubscription;
  item: (
    where?: ItemSubscriptionWhereInput
  ) => ItemSubscriptionPayloadSubscription;
  message: (
    where?: MessageSubscriptionWhereInput
  ) => MessageSubscriptionPayloadSubscription;
  payment: (
    where?: PaymentSubscriptionWhereInput
  ) => PaymentSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  purchase: (
    where?: PurchaseSubscriptionWhereInput
  ) => PurchaseSubscriptionPayloadSubscription;
  todo: (
    where?: TodoSubscriptionWhereInput
  ) => TodoSubscriptionPayloadSubscription;
  transaction: (
    where?: TransactionSubscriptionWhereInput
  ) => TransactionSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type UserRole = "SUPER" | "ADMIN" | "MEMBER";

export type TransactionType = "PAYMENT" | "PURCHASE";

export type PurchaseOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "total_ASC"
  | "total_DESC"
  | "date_ASC"
  | "date_DESC";

export type ItemOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "price_ASC"
  | "price_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type PaymentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "amount_ASC"
  | "amount_DESC"
  | "date_ASC"
  | "date_DESC"
  | "verified_ASC"
  | "verified_DESC";

export type TransactionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "date_ASC"
  | "date_DESC"
  | "type_ASC"
  | "type_DESC"
  | "balance_ASC"
  | "balance_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "image_ASC"
  | "image_DESC"
  | "link_ASC"
  | "link_DESC"
  | "date_ASC"
  | "date_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "role_ASC"
  | "role_DESC"
  | "avatar_ASC"
  | "avatar_DESC"
  | "balance_ASC"
  | "balance_DESC"
  | "isOnline_ASC"
  | "isOnline_DESC"
  | "lastOnline_ASC"
  | "lastOnline_DESC";

export type CommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "link_ASC"
  | "link_DESC"
  | "date_ASC"
  | "date_DESC";

export type TodoOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "due_ASC"
  | "due_DESC"
  | "text_ASC"
  | "text_DESC"
  | "done_ASC"
  | "done_DESC"
  | "link_ASC"
  | "link_DESC"
  | "doneAt_ASC"
  | "doneAt_DESC";

export type EventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "date_ASC"
  | "date_DESC"
  | "image_ASC"
  | "image_DESC"
  | "flyer_ASC"
  | "flyer_DESC"
  | "published_ASC"
  | "published_DESC";

export type ChatOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "lastSeen_ASC"
  | "lastSeen_DESC"
  | "usersTyping_ASC"
  | "usersTyping_DESC";

export type MessageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "text_ASC"
  | "text_DESC"
  | "link_ASC"
  | "link_DESC"
  | "date_ASC"
  | "date_DESC";

export type ClientOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "identity_ASC"
  | "identity_DESC"
  | "secret_ASC"
  | "secret_DESC"
  | "name_ASC"
  | "name_DESC"
  | "trusted_ASC"
  | "trusted_DESC";

export type FileOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "fileId_ASC"
  | "fileId_DESC"
  | "hash_ASC"
  | "hash_DESC"
  | "uri_ASC"
  | "uri_DESC"
  | "filename_ASC"
  | "filename_DESC"
  | "path_ASC"
  | "path_DESC"
  | "mimetype_ASC"
  | "mimetype_DESC"
  | "extension_ASC"
  | "extension_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "price_ASC"
  | "price_DESC"
  | "index_ASC"
  | "index_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC"
  | "deleted_ASC"
  | "deleted_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ChatWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PurchaseWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  transaction?: Maybe<TransactionWhereInput>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  user?: Maybe<UserWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PurchaseWhereInput[] | PurchaseWhereInput>;
  OR?: Maybe<PurchaseWhereInput[] | PurchaseWhereInput>;
  NOT?: Maybe<PurchaseWhereInput[] | PurchaseWhereInput>;
}

export interface ItemWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  product?: Maybe<ProductWhereInput>;
  user?: Maybe<UserWhereInput>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  OR?: Maybe<ItemWhereInput[] | ItemWhereInput>;
  NOT?: Maybe<ItemWhereInput[] | ItemWhereInput>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  index?: Maybe<Int>;
  index_not?: Maybe<Int>;
  index_in?: Maybe<Int[] | Int>;
  index_not_in?: Maybe<Int[] | Int>;
  index_lt?: Maybe<Int>;
  index_lte?: Maybe<Int>;
  index_gt?: Maybe<Int>;
  index_gte?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  thumbnail_not?: Maybe<String>;
  thumbnail_in?: Maybe<String[] | String>;
  thumbnail_not_in?: Maybe<String[] | String>;
  thumbnail_lt?: Maybe<String>;
  thumbnail_lte?: Maybe<String>;
  thumbnail_gt?: Maybe<String>;
  thumbnail_gte?: Maybe<String>;
  thumbnail_contains?: Maybe<String>;
  thumbnail_not_contains?: Maybe<String>;
  thumbnail_starts_with?: Maybe<String>;
  thumbnail_not_starts_with?: Maybe<String>;
  thumbnail_ends_with?: Maybe<String>;
  thumbnail_not_ends_with?: Maybe<String>;
  deleted?: Maybe<Boolean>;
  deleted_not?: Maybe<Boolean>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  purchases_every?: Maybe<PurchaseWhereInput>;
  purchases_some?: Maybe<PurchaseWhereInput>;
  purchases_none?: Maybe<PurchaseWhereInput>;
  payments_every?: Maybe<PaymentWhereInput>;
  payments_some?: Maybe<PaymentWhereInput>;
  payments_none?: Maybe<PaymentWhereInput>;
  transactions_every?: Maybe<TransactionWhereInput>;
  transactions_some?: Maybe<TransactionWhereInput>;
  transactions_none?: Maybe<TransactionWhereInput>;
  items_every?: Maybe<ItemWhereInput>;
  items_some?: Maybe<ItemWhereInput>;
  items_none?: Maybe<ItemWhereInput>;
  balance?: Maybe<Float>;
  balance_not?: Maybe<Float>;
  balance_in?: Maybe<Float[] | Float>;
  balance_not_in?: Maybe<Float[] | Float>;
  balance_lt?: Maybe<Float>;
  balance_lte?: Maybe<Float>;
  balance_gt?: Maybe<Float>;
  balance_gte?: Maybe<Float>;
  posts_every?: Maybe<PostWhereInput>;
  posts_some?: Maybe<PostWhereInput>;
  posts_none?: Maybe<PostWhereInput>;
  likedPosts_every?: Maybe<PostWhereInput>;
  likedPosts_some?: Maybe<PostWhereInput>;
  likedPosts_none?: Maybe<PostWhereInput>;
  likedEvents_every?: Maybe<EventWhereInput>;
  likedEvents_some?: Maybe<EventWhereInput>;
  likedEvents_none?: Maybe<EventWhereInput>;
  supportedEvents_every?: Maybe<EventWhereInput>;
  supportedEvents_some?: Maybe<EventWhereInput>;
  supportedEvents_none?: Maybe<EventWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  likedComments_every?: Maybe<CommentWhereInput>;
  likedComments_some?: Maybe<CommentWhereInput>;
  likedComments_none?: Maybe<CommentWhereInput>;
  isOnline?: Maybe<Boolean>;
  isOnline_not?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  lastOnline_not?: Maybe<DateTimeInput>;
  lastOnline_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastOnline_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastOnline_lt?: Maybe<DateTimeInput>;
  lastOnline_lte?: Maybe<DateTimeInput>;
  lastOnline_gt?: Maybe<DateTimeInput>;
  lastOnline_gte?: Maybe<DateTimeInput>;
  ownChats_every?: Maybe<ChatWhereInput>;
  ownChats_some?: Maybe<ChatWhereInput>;
  ownChats_none?: Maybe<ChatWhereInput>;
  chats_every?: Maybe<ChatWhereInput>;
  chats_some?: Maybe<ChatWhereInput>;
  chats_none?: Maybe<ChatWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface PaymentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  user?: Maybe<UserWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  transaction?: Maybe<TransactionWhereInput>;
  AND?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  OR?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
  NOT?: Maybe<PaymentWhereInput[] | PaymentWhereInput>;
}

export interface TransactionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  type_not?: Maybe<TransactionType>;
  type_in?: Maybe<TransactionType[] | TransactionType>;
  type_not_in?: Maybe<TransactionType[] | TransactionType>;
  balance?: Maybe<Float>;
  balance_not?: Maybe<Float>;
  balance_in?: Maybe<Float[] | Float>;
  balance_not_in?: Maybe<Float[] | Float>;
  balance_lt?: Maybe<Float>;
  balance_lte?: Maybe<Float>;
  balance_gt?: Maybe<Float>;
  balance_gte?: Maybe<Float>;
  payment?: Maybe<PaymentWhereInput>;
  purchase?: Maybe<PurchaseWhereInput>;
  AND?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  OR?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
  NOT?: Maybe<TransactionWhereInput[] | TransactionWhereInput>;
}

export interface PostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  likedBy_every?: Maybe<UserWhereInput>;
  likedBy_some?: Maybe<UserWhereInput>;
  likedBy_none?: Maybe<UserWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
  OR?: Maybe<PostWhereInput[] | PostWhereInput>;
  NOT?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface CommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  author?: Maybe<UserWhereInput>;
  likedBy_every?: Maybe<UserWhereInput>;
  likedBy_some?: Maybe<UserWhereInput>;
  likedBy_none?: Maybe<UserWhereInput>;
  post?: Maybe<PostWhereInput>;
  event?: Maybe<EventWhereInput>;
  AND?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  OR?: Maybe<CommentWhereInput[] | CommentWhereInput>;
  NOT?: Maybe<CommentWhereInput[] | CommentWhereInput>;
}

export interface EventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  flyer?: Maybe<String>;
  flyer_not?: Maybe<String>;
  flyer_in?: Maybe<String[] | String>;
  flyer_not_in?: Maybe<String[] | String>;
  flyer_lt?: Maybe<String>;
  flyer_lte?: Maybe<String>;
  flyer_gt?: Maybe<String>;
  flyer_gte?: Maybe<String>;
  flyer_contains?: Maybe<String>;
  flyer_not_contains?: Maybe<String>;
  flyer_starts_with?: Maybe<String>;
  flyer_not_starts_with?: Maybe<String>;
  flyer_ends_with?: Maybe<String>;
  flyer_not_ends_with?: Maybe<String>;
  supporters_every?: Maybe<UserWhereInput>;
  supporters_some?: Maybe<UserWhereInput>;
  supporters_none?: Maybe<UserWhereInput>;
  likedBy_every?: Maybe<UserWhereInput>;
  likedBy_some?: Maybe<UserWhereInput>;
  likedBy_none?: Maybe<UserWhereInput>;
  owner?: Maybe<UserWhereInput>;
  comments_every?: Maybe<CommentWhereInput>;
  comments_some?: Maybe<CommentWhereInput>;
  comments_none?: Maybe<CommentWhereInput>;
  todos_every?: Maybe<TodoWhereInput>;
  todos_some?: Maybe<TodoWhereInput>;
  todos_none?: Maybe<TodoWhereInput>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  AND?: Maybe<EventWhereInput[] | EventWhereInput>;
  OR?: Maybe<EventWhereInput[] | EventWhereInput>;
  NOT?: Maybe<EventWhereInput[] | EventWhereInput>;
}

export interface TodoWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  due?: Maybe<DateTimeInput>;
  due_not?: Maybe<DateTimeInput>;
  due_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  due_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  due_lt?: Maybe<DateTimeInput>;
  due_lte?: Maybe<DateTimeInput>;
  due_gt?: Maybe<DateTimeInput>;
  due_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  done?: Maybe<Boolean>;
  done_not?: Maybe<Boolean>;
  assigned?: Maybe<UserWhereInput>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  doneBy?: Maybe<UserWhereInput>;
  doneAt?: Maybe<DateTimeInput>;
  doneAt_not?: Maybe<DateTimeInput>;
  doneAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  doneAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  doneAt_lt?: Maybe<DateTimeInput>;
  doneAt_lte?: Maybe<DateTimeInput>;
  doneAt_gt?: Maybe<DateTimeInput>;
  doneAt_gte?: Maybe<DateTimeInput>;
  event?: Maybe<EventWhereInput>;
  AND?: Maybe<TodoWhereInput[] | TodoWhereInput>;
  OR?: Maybe<TodoWhereInput[] | TodoWhereInput>;
  NOT?: Maybe<TodoWhereInput[] | TodoWhereInput>;
}

export interface ChatWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  creator?: Maybe<UserWhereInput>;
  members_every?: Maybe<UserWhereInput>;
  members_some?: Maybe<UserWhereInput>;
  members_none?: Maybe<UserWhereInput>;
  messages_every?: Maybe<MessageWhereInput>;
  messages_some?: Maybe<MessageWhereInput>;
  messages_none?: Maybe<MessageWhereInput>;
  AND?: Maybe<ChatWhereInput[] | ChatWhereInput>;
  OR?: Maybe<ChatWhereInput[] | ChatWhereInput>;
  NOT?: Maybe<ChatWhereInput[] | ChatWhereInput>;
}

export interface MessageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  from?: Maybe<UserWhereInput>;
  chat?: Maybe<ChatWhereInput>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  OR?: Maybe<MessageWhereInput[] | MessageWhereInput>;
  NOT?: Maybe<MessageWhereInput[] | MessageWhereInput>;
}

export type ClientWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  identity?: Maybe<String>;
}>;

export interface ClientWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  identity?: Maybe<String>;
  identity_not?: Maybe<String>;
  identity_in?: Maybe<String[] | String>;
  identity_not_in?: Maybe<String[] | String>;
  identity_lt?: Maybe<String>;
  identity_lte?: Maybe<String>;
  identity_gt?: Maybe<String>;
  identity_gte?: Maybe<String>;
  identity_contains?: Maybe<String>;
  identity_not_contains?: Maybe<String>;
  identity_starts_with?: Maybe<String>;
  identity_not_starts_with?: Maybe<String>;
  identity_ends_with?: Maybe<String>;
  identity_not_ends_with?: Maybe<String>;
  secret?: Maybe<String>;
  secret_not?: Maybe<String>;
  secret_in?: Maybe<String[] | String>;
  secret_not_in?: Maybe<String[] | String>;
  secret_lt?: Maybe<String>;
  secret_lte?: Maybe<String>;
  secret_gt?: Maybe<String>;
  secret_gte?: Maybe<String>;
  secret_contains?: Maybe<String>;
  secret_not_contains?: Maybe<String>;
  secret_starts_with?: Maybe<String>;
  secret_not_starts_with?: Maybe<String>;
  secret_ends_with?: Maybe<String>;
  secret_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  trusted?: Maybe<Boolean>;
  trusted_not?: Maybe<Boolean>;
  AND?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  OR?: Maybe<ClientWhereInput[] | ClientWhereInput>;
  NOT?: Maybe<ClientWhereInput[] | ClientWhereInput>;
}

export type CommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type FileWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  fileId?: Maybe<String>;
  hash?: Maybe<String>;
  uri?: Maybe<String>;
}>;

export interface FileWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  fileId?: Maybe<String>;
  fileId_not?: Maybe<String>;
  fileId_in?: Maybe<String[] | String>;
  fileId_not_in?: Maybe<String[] | String>;
  fileId_lt?: Maybe<String>;
  fileId_lte?: Maybe<String>;
  fileId_gt?: Maybe<String>;
  fileId_gte?: Maybe<String>;
  fileId_contains?: Maybe<String>;
  fileId_not_contains?: Maybe<String>;
  fileId_starts_with?: Maybe<String>;
  fileId_not_starts_with?: Maybe<String>;
  fileId_ends_with?: Maybe<String>;
  fileId_not_ends_with?: Maybe<String>;
  hash?: Maybe<String>;
  hash_not?: Maybe<String>;
  hash_in?: Maybe<String[] | String>;
  hash_not_in?: Maybe<String[] | String>;
  hash_lt?: Maybe<String>;
  hash_lte?: Maybe<String>;
  hash_gt?: Maybe<String>;
  hash_gte?: Maybe<String>;
  hash_contains?: Maybe<String>;
  hash_not_contains?: Maybe<String>;
  hash_starts_with?: Maybe<String>;
  hash_not_starts_with?: Maybe<String>;
  hash_ends_with?: Maybe<String>;
  hash_not_ends_with?: Maybe<String>;
  uri?: Maybe<String>;
  uri_not?: Maybe<String>;
  uri_in?: Maybe<String[] | String>;
  uri_not_in?: Maybe<String[] | String>;
  uri_lt?: Maybe<String>;
  uri_lte?: Maybe<String>;
  uri_gt?: Maybe<String>;
  uri_gte?: Maybe<String>;
  uri_contains?: Maybe<String>;
  uri_not_contains?: Maybe<String>;
  uri_starts_with?: Maybe<String>;
  uri_not_starts_with?: Maybe<String>;
  uri_ends_with?: Maybe<String>;
  uri_not_ends_with?: Maybe<String>;
  filename?: Maybe<String>;
  filename_not?: Maybe<String>;
  filename_in?: Maybe<String[] | String>;
  filename_not_in?: Maybe<String[] | String>;
  filename_lt?: Maybe<String>;
  filename_lte?: Maybe<String>;
  filename_gt?: Maybe<String>;
  filename_gte?: Maybe<String>;
  filename_contains?: Maybe<String>;
  filename_not_contains?: Maybe<String>;
  filename_starts_with?: Maybe<String>;
  filename_not_starts_with?: Maybe<String>;
  filename_ends_with?: Maybe<String>;
  filename_not_ends_with?: Maybe<String>;
  path?: Maybe<String>;
  path_not?: Maybe<String>;
  path_in?: Maybe<String[] | String>;
  path_not_in?: Maybe<String[] | String>;
  path_lt?: Maybe<String>;
  path_lte?: Maybe<String>;
  path_gt?: Maybe<String>;
  path_gte?: Maybe<String>;
  path_contains?: Maybe<String>;
  path_not_contains?: Maybe<String>;
  path_starts_with?: Maybe<String>;
  path_not_starts_with?: Maybe<String>;
  path_ends_with?: Maybe<String>;
  path_not_ends_with?: Maybe<String>;
  mimetype?: Maybe<String>;
  mimetype_not?: Maybe<String>;
  mimetype_in?: Maybe<String[] | String>;
  mimetype_not_in?: Maybe<String[] | String>;
  mimetype_lt?: Maybe<String>;
  mimetype_lte?: Maybe<String>;
  mimetype_gt?: Maybe<String>;
  mimetype_gte?: Maybe<String>;
  mimetype_contains?: Maybe<String>;
  mimetype_not_contains?: Maybe<String>;
  mimetype_starts_with?: Maybe<String>;
  mimetype_not_starts_with?: Maybe<String>;
  mimetype_ends_with?: Maybe<String>;
  mimetype_not_ends_with?: Maybe<String>;
  extension?: Maybe<String>;
  extension_not?: Maybe<String>;
  extension_in?: Maybe<String[] | String>;
  extension_not_in?: Maybe<String[] | String>;
  extension_lt?: Maybe<String>;
  extension_lte?: Maybe<String>;
  extension_gt?: Maybe<String>;
  extension_gte?: Maybe<String>;
  extension_contains?: Maybe<String>;
  extension_not_contains?: Maybe<String>;
  extension_starts_with?: Maybe<String>;
  extension_not_starts_with?: Maybe<String>;
  extension_ends_with?: Maybe<String>;
  extension_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<FileWhereInput[] | FileWhereInput>;
  OR?: Maybe<FileWhereInput[] | FileWhereInput>;
  NOT?: Maybe<FileWhereInput[] | FileWhereInput>;
}

export type ItemWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type MessageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PaymentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type PurchaseWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TodoWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type TransactionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ChatCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  creator: UserCreateOneWithoutOwnChatsInput;
  members?: Maybe<UserCreateManyWithoutChatsInput>;
  messages?: Maybe<MessageCreateManyWithoutChatInput>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface UserCreateOneWithoutOwnChatsInput {
  create?: Maybe<UserCreateWithoutOwnChatsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutOwnChatsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface PurchaseCreateManyWithoutUserInput {
  create?: Maybe<
    PurchaseCreateWithoutUserInput[] | PurchaseCreateWithoutUserInput
  >;
  connect?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
}

export interface PurchaseCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  items?: Maybe<ItemCreateManyInput>;
  transaction: TransactionCreateOneWithoutPurchaseInput;
  total: Float;
  date: DateTimeInput;
}

export interface ItemCreateManyInput {
  create?: Maybe<ItemCreateInput[] | ItemCreateInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface ItemCreateInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneInput;
  user: UserCreateOneWithoutItemsInput;
  price: Float;
  amount: Int;
}

export interface ProductCreateOneInput {
  create?: Maybe<ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  price: Float;
  index: Int;
  thumbnail?: Maybe<String>;
  deleted?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutItemsInput {
  create?: Maybe<UserCreateWithoutItemsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutItemsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface PaymentCreateManyWithoutUserInput {
  create?: Maybe<
    PaymentCreateWithoutUserInput[] | PaymentCreateWithoutUserInput
  >;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  amount: Float;
  date: DateTimeInput;
  verified?: Maybe<Boolean>;
  transaction: TransactionCreateOneWithoutPaymentInput;
}

export interface TransactionCreateOneWithoutPaymentInput {
  create?: Maybe<TransactionCreateWithoutPaymentInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface TransactionCreateWithoutPaymentInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  purchase?: Maybe<PurchaseCreateOneWithoutTransactionInput>;
}

export interface UserCreateOneWithoutTransactionsInput {
  create?: Maybe<UserCreateWithoutTransactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutTransactionsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface ItemCreateManyWithoutUserInput {
  create?: Maybe<ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
}

export interface ItemCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneInput;
  price: Float;
  amount: Int;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface PostCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  text: String;
  image?: Maybe<String>;
  link?: Maybe<String>;
  likedBy?: Maybe<UserCreateManyWithoutLikedPostsInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  date: DateTimeInput;
}

export interface UserCreateManyWithoutLikedPostsInput {
  create?: Maybe<
    UserCreateWithoutLikedPostsInput[] | UserCreateWithoutLikedPostsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutLikedPostsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface TransactionCreateManyWithoutUserInput {
  create?: Maybe<
    TransactionCreateWithoutUserInput[] | TransactionCreateWithoutUserInput
  >;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
}

export interface TransactionCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  payment?: Maybe<PaymentCreateOneWithoutTransactionInput>;
  purchase?: Maybe<PurchaseCreateOneWithoutTransactionInput>;
}

export interface PaymentCreateOneWithoutTransactionInput {
  create?: Maybe<PaymentCreateWithoutTransactionInput>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentCreateWithoutTransactionInput {
  id?: Maybe<ID_Input>;
  amount: Float;
  user: UserCreateOneWithoutPaymentsInput;
  date: DateTimeInput;
  verified?: Maybe<Boolean>;
}

export interface UserCreateOneWithoutPaymentsInput {
  create?: Maybe<UserCreateWithoutPaymentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPaymentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface PostCreateManyWithoutLikedByInput {
  create?: Maybe<
    PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput
  >;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface PostCreateWithoutLikedByInput {
  id?: Maybe<ID_Input>;
  text: String;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author: UserCreateOneWithoutPostsInput;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  date: DateTimeInput;
}

export interface UserCreateOneWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPostsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface EventCreateManyWithoutLikedByInput {
  create?: Maybe<
    EventCreateWithoutLikedByInput[] | EventCreateWithoutLikedByInput
  >;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface EventCreateWithoutLikedByInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  date: DateTimeInput;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  supporters?: Maybe<UserCreateManyWithoutSupportedEventsInput>;
  owner: UserCreateOneInput;
  comments?: Maybe<CommentCreateManyWithoutEventInput>;
  todos?: Maybe<TodoCreateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface UserCreateManyWithoutSupportedEventsInput {
  create?: Maybe<
    | UserCreateWithoutSupportedEventsInput[]
    | UserCreateWithoutSupportedEventsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutSupportedEventsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface CommentCreateManyWithoutAuthorInput {
  create?: Maybe<
    CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  text: String;
  link?: Maybe<String>;
  date: DateTimeInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostCreateOneWithoutCommentsInput>;
  event?: Maybe<EventCreateOneWithoutCommentsInput>;
}

export interface UserCreateManyWithoutLikedCommentsInput {
  create?: Maybe<
    UserCreateWithoutLikedCommentsInput[] | UserCreateWithoutLikedCommentsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutLikedCommentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface EventCreateManyWithoutSupportersInput {
  create?: Maybe<
    EventCreateWithoutSupportersInput[] | EventCreateWithoutSupportersInput
  >;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
}

export interface EventCreateWithoutSupportersInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  date: DateTimeInput;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  likedBy?: Maybe<UserCreateManyWithoutLikedEventsInput>;
  owner: UserCreateOneInput;
  comments?: Maybe<CommentCreateManyWithoutEventInput>;
  todos?: Maybe<TodoCreateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface UserCreateManyWithoutLikedEventsInput {
  create?: Maybe<
    UserCreateWithoutLikedEventsInput[] | UserCreateWithoutLikedEventsInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutLikedEventsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface CommentCreateManyWithoutLikedByInput {
  create?: Maybe<
    CommentCreateWithoutLikedByInput[] | CommentCreateWithoutLikedByInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutLikedByInput {
  id?: Maybe<ID_Input>;
  text: String;
  link?: Maybe<String>;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  post?: Maybe<PostCreateOneWithoutCommentsInput>;
  event?: Maybe<EventCreateOneWithoutCommentsInput>;
}

export interface UserCreateOneWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface ChatCreateManyWithoutCreatorInput {
  create?: Maybe<
    ChatCreateWithoutCreatorInput[] | ChatCreateWithoutCreatorInput
  >;
  connect?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
}

export interface ChatCreateWithoutCreatorInput {
  id?: Maybe<ID_Input>;
  title: String;
  members?: Maybe<UserCreateManyWithoutChatsInput>;
  messages?: Maybe<MessageCreateManyWithoutChatInput>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface UserCreateManyWithoutChatsInput {
  create?: Maybe<UserCreateWithoutChatsInput[] | UserCreateWithoutChatsInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface UserCreateWithoutChatsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
}

export interface MessageCreateManyWithoutChatInput {
  create?: Maybe<
    MessageCreateWithoutChatInput[] | MessageCreateWithoutChatInput
  >;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
}

export interface MessageCreateWithoutChatInput {
  id?: Maybe<ID_Input>;
  text: String;
  link?: Maybe<String>;
  from: UserCreateOneInput;
  date: DateTimeInput;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseCreateManyWithoutUserInput>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface ChatCreateManyWithoutMembersInput {
  create?: Maybe<
    ChatCreateWithoutMembersInput[] | ChatCreateWithoutMembersInput
  >;
  connect?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
}

export interface ChatCreateWithoutMembersInput {
  id?: Maybe<ID_Input>;
  title: String;
  creator: UserCreateOneWithoutOwnChatsInput;
  messages?: Maybe<MessageCreateManyWithoutChatInput>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface PostCreateOneWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  text: String;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author: UserCreateOneWithoutPostsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedPostsInput>;
  date: DateTimeInput;
}

export interface EventCreateOneWithoutCommentsInput {
  create?: Maybe<EventCreateWithoutCommentsInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventCreateWithoutCommentsInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  date: DateTimeInput;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  supporters?: Maybe<UserCreateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikedEventsInput>;
  owner: UserCreateOneInput;
  todos?: Maybe<TodoCreateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface TodoCreateManyWithoutEventInput {
  create?: Maybe<TodoCreateWithoutEventInput[] | TodoCreateWithoutEventInput>;
  connect?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
}

export interface TodoCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  due: DateTimeInput;
  text: String;
  done?: Maybe<Boolean>;
  assigned?: Maybe<UserCreateOneInput>;
  link?: Maybe<String>;
  doneBy?: Maybe<UserCreateOneInput>;
  doneAt?: Maybe<DateTimeInput>;
}

export interface CommentCreateManyWithoutEventInput {
  create?: Maybe<
    CommentCreateWithoutEventInput[] | CommentCreateWithoutEventInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutEventInput {
  id?: Maybe<ID_Input>;
  text: String;
  link?: Maybe<String>;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostCreateOneWithoutCommentsInput>;
}

export interface CommentCreateManyWithoutPostInput {
  create?: Maybe<
    CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput
  >;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
}

export interface CommentCreateWithoutPostInput {
  id?: Maybe<ID_Input>;
  text: String;
  link?: Maybe<String>;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedCommentsInput>;
  event?: Maybe<EventCreateOneWithoutCommentsInput>;
}

export interface PurchaseCreateOneWithoutTransactionInput {
  create?: Maybe<PurchaseCreateWithoutTransactionInput>;
  connect?: Maybe<PurchaseWhereUniqueInput>;
}

export interface PurchaseCreateWithoutTransactionInput {
  id?: Maybe<ID_Input>;
  items?: Maybe<ItemCreateManyInput>;
  total: Float;
  user: UserCreateOneWithoutPurchasesInput;
  date: DateTimeInput;
}

export interface UserCreateOneWithoutPurchasesInput {
  create?: Maybe<UserCreateWithoutPurchasesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutPurchasesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email: String;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  payments?: Maybe<PaymentCreateManyWithoutUserInput>;
  transactions?: Maybe<TransactionCreateManyWithoutUserInput>;
  items?: Maybe<ItemCreateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostCreateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventCreateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventCreateManyWithoutSupportersInput>;
  comments?: Maybe<CommentCreateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentCreateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatCreateManyWithoutCreatorInput>;
  chats?: Maybe<ChatCreateManyWithoutMembersInput>;
}

export interface TransactionCreateOneWithoutPurchaseInput {
  create?: Maybe<TransactionCreateWithoutPurchaseInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface TransactionCreateWithoutPurchaseInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  payment?: Maybe<PaymentCreateOneWithoutTransactionInput>;
}

export interface ChatUpdateInput {
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredWithoutOwnChatsInput>;
  members?: Maybe<UserUpdateManyWithoutChatsInput>;
  messages?: Maybe<MessageUpdateManyWithoutChatInput>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface UserUpdateOneRequiredWithoutOwnChatsInput {
  create?: Maybe<UserCreateWithoutOwnChatsInput>;
  update?: Maybe<UserUpdateWithoutOwnChatsDataInput>;
  upsert?: Maybe<UserUpsertWithoutOwnChatsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutOwnChatsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface PurchaseUpdateManyWithoutUserInput {
  create?: Maybe<
    PurchaseCreateWithoutUserInput[] | PurchaseCreateWithoutUserInput
  >;
  delete?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  connect?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  set?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  disconnect?: Maybe<PurchaseWhereUniqueInput[] | PurchaseWhereUniqueInput>;
  update?: Maybe<
    | PurchaseUpdateWithWhereUniqueWithoutUserInput[]
    | PurchaseUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | PurchaseUpsertWithWhereUniqueWithoutUserInput[]
    | PurchaseUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
  updateMany?: Maybe<
    | PurchaseUpdateManyWithWhereNestedInput[]
    | PurchaseUpdateManyWithWhereNestedInput
  >;
}

export interface PurchaseUpdateWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput;
  data: PurchaseUpdateWithoutUserDataInput;
}

export interface PurchaseUpdateWithoutUserDataInput {
  items?: Maybe<ItemUpdateManyInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutPurchaseInput>;
  total?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface ItemUpdateManyInput {
  create?: Maybe<ItemCreateInput[] | ItemCreateInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueNestedInput[]
    | ItemUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueNestedInput[]
    | ItemUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateDataInput;
}

export interface ItemUpdateDataInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutItemsInput>;
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface ProductUpdateOneRequiredInput {
  create?: Maybe<ProductCreateInput>;
  update?: Maybe<ProductUpdateDataInput>;
  upsert?: Maybe<ProductUpsertNestedInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductUpdateDataInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  index?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  deleted?: Maybe<Boolean>;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface UserUpdateOneRequiredWithoutItemsInput {
  create?: Maybe<UserCreateWithoutItemsInput>;
  update?: Maybe<UserUpdateWithoutItemsDataInput>;
  upsert?: Maybe<UserUpsertWithoutItemsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutItemsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface PaymentUpdateManyWithoutUserInput {
  create?: Maybe<
    PaymentCreateWithoutUserInput[] | PaymentCreateWithoutUserInput
  >;
  delete?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  connect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  set?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  disconnect?: Maybe<PaymentWhereUniqueInput[] | PaymentWhereUniqueInput>;
  update?: Maybe<
    | PaymentUpdateWithWhereUniqueWithoutUserInput[]
    | PaymentUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | PaymentUpsertWithWhereUniqueWithoutUserInput[]
    | PaymentUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  updateMany?: Maybe<
    | PaymentUpdateManyWithWhereNestedInput[]
    | PaymentUpdateManyWithWhereNestedInput
  >;
}

export interface PaymentUpdateWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput;
  data: PaymentUpdateWithoutUserDataInput;
}

export interface PaymentUpdateWithoutUserDataInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutPaymentInput>;
}

export interface TransactionUpdateOneRequiredWithoutPaymentInput {
  create?: Maybe<TransactionCreateWithoutPaymentInput>;
  update?: Maybe<TransactionUpdateWithoutPaymentDataInput>;
  upsert?: Maybe<TransactionUpsertWithoutPaymentInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface TransactionUpdateWithoutPaymentDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
  purchase?: Maybe<PurchaseUpdateOneWithoutTransactionInput>;
}

export interface UserUpdateOneRequiredWithoutTransactionsInput {
  create?: Maybe<UserCreateWithoutTransactionsInput>;
  update?: Maybe<UserUpdateWithoutTransactionsDataInput>;
  upsert?: Maybe<UserUpsertWithoutTransactionsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutTransactionsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface ItemUpdateManyWithoutUserInput {
  create?: Maybe<ItemCreateWithoutUserInput[] | ItemCreateWithoutUserInput>;
  delete?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  connect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  set?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  disconnect?: Maybe<ItemWhereUniqueInput[] | ItemWhereUniqueInput>;
  update?: Maybe<
    | ItemUpdateWithWhereUniqueWithoutUserInput[]
    | ItemUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | ItemUpsertWithWhereUniqueWithoutUserInput[]
    | ItemUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  updateMany?: Maybe<
    ItemUpdateManyWithWhereNestedInput[] | ItemUpdateManyWithWhereNestedInput
  >;
}

export interface ItemUpdateWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  data: ItemUpdateWithoutUserDataInput;
}

export interface ItemUpdateWithoutUserDataInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface ItemUpsertWithWhereUniqueWithoutUserInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateWithoutUserDataInput;
  create: ItemCreateWithoutUserInput;
}

export interface ItemScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  price?: Maybe<Float>;
  price_not?: Maybe<Float>;
  price_in?: Maybe<Float[] | Float>;
  price_not_in?: Maybe<Float[] | Float>;
  price_lt?: Maybe<Float>;
  price_lte?: Maybe<Float>;
  price_gt?: Maybe<Float>;
  price_gte?: Maybe<Float>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  OR?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
  NOT?: Maybe<ItemScalarWhereInput[] | ItemScalarWhereInput>;
}

export interface ItemUpdateManyWithWhereNestedInput {
  where: ItemScalarWhereInput;
  data: ItemUpdateManyDataInput;
}

export interface ItemUpdateManyDataInput {
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface PostUpdateWithoutAuthorDataInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedPostsInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpdateManyWithoutLikedPostsInput {
  create?: Maybe<
    UserCreateWithoutLikedPostsInput[] | UserCreateWithoutLikedPostsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutLikedPostsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedPostsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutLikedPostsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedPostsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedPostsDataInput;
}

export interface UserUpdateWithoutLikedPostsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface TransactionUpdateManyWithoutUserInput {
  create?: Maybe<
    TransactionCreateWithoutUserInput[] | TransactionCreateWithoutUserInput
  >;
  delete?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  connect?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  set?: Maybe<TransactionWhereUniqueInput[] | TransactionWhereUniqueInput>;
  disconnect?: Maybe<
    TransactionWhereUniqueInput[] | TransactionWhereUniqueInput
  >;
  update?: Maybe<
    | TransactionUpdateWithWhereUniqueWithoutUserInput[]
    | TransactionUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | TransactionUpsertWithWhereUniqueWithoutUserInput[]
    | TransactionUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<
    TransactionScalarWhereInput[] | TransactionScalarWhereInput
  >;
  updateMany?: Maybe<
    | TransactionUpdateManyWithWhereNestedInput[]
    | TransactionUpdateManyWithWhereNestedInput
  >;
}

export interface TransactionUpdateWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  data: TransactionUpdateWithoutUserDataInput;
}

export interface TransactionUpdateWithoutUserDataInput {
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
  payment?: Maybe<PaymentUpdateOneWithoutTransactionInput>;
  purchase?: Maybe<PurchaseUpdateOneWithoutTransactionInput>;
}

export interface PaymentUpdateOneWithoutTransactionInput {
  create?: Maybe<PaymentCreateWithoutTransactionInput>;
  update?: Maybe<PaymentUpdateWithoutTransactionDataInput>;
  upsert?: Maybe<PaymentUpsertWithoutTransactionInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PaymentWhereUniqueInput>;
}

export interface PaymentUpdateWithoutTransactionDataInput {
  amount?: Maybe<Float>;
  user?: Maybe<UserUpdateOneRequiredWithoutPaymentsInput>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
}

export interface UserUpdateOneRequiredWithoutPaymentsInput {
  create?: Maybe<UserCreateWithoutPaymentsInput>;
  update?: Maybe<UserUpdateWithoutPaymentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPaymentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPaymentsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface PostUpdateManyWithoutLikedByInput {
  create?: Maybe<
    PostCreateWithoutLikedByInput[] | PostCreateWithoutLikedByInput
  >;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutLikedByInput[]
    | PostUpdateWithWhereUniqueWithoutLikedByInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutLikedByInput[]
    | PostUpsertWithWhereUniqueWithoutLikedByInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpdateWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutLikedByDataInput;
}

export interface PostUpdateWithoutLikedByDataInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpdateOneRequiredWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  update?: Maybe<UserUpdateWithoutPostsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPostsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface EventUpdateManyWithoutLikedByInput {
  create?: Maybe<
    EventCreateWithoutLikedByInput[] | EventCreateWithoutLikedByInput
  >;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutLikedByInput[]
    | EventUpdateWithWhereUniqueWithoutLikedByInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutLikedByInput[]
    | EventUpsertWithWhereUniqueWithoutLikedByInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpdateWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutLikedByDataInput;
}

export interface EventUpdateWithoutLikedByDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  supporters?: Maybe<UserUpdateManyWithoutSupportedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  comments?: Maybe<CommentUpdateManyWithoutEventInput>;
  todos?: Maybe<TodoUpdateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface UserUpdateManyWithoutSupportedEventsInput {
  create?: Maybe<
    | UserCreateWithoutSupportedEventsInput[]
    | UserCreateWithoutSupportedEventsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutSupportedEventsInput[]
    | UserUpdateWithWhereUniqueWithoutSupportedEventsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutSupportedEventsInput[]
    | UserUpsertWithWhereUniqueWithoutSupportedEventsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutSupportedEventsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutSupportedEventsDataInput;
}

export interface UserUpdateWithoutSupportedEventsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface CommentUpdateManyWithoutAuthorInput {
  create?: Maybe<
    CommentCreateWithoutAuthorInput[] | CommentCreateWithoutAuthorInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutAuthorInput[]
    | CommentUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutAuthorInput[]
    | CommentUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutAuthorDataInput;
}

export interface CommentUpdateWithoutAuthorDataInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostUpdateOneWithoutCommentsInput>;
  event?: Maybe<EventUpdateOneWithoutCommentsInput>;
}

export interface UserUpdateManyWithoutLikedCommentsInput {
  create?: Maybe<
    UserCreateWithoutLikedCommentsInput[] | UserCreateWithoutLikedCommentsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutLikedCommentsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedCommentsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutLikedCommentsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedCommentsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedCommentsDataInput;
}

export interface UserUpdateWithoutLikedCommentsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface EventUpdateManyWithoutSupportersInput {
  create?: Maybe<
    EventCreateWithoutSupportersInput[] | EventCreateWithoutSupportersInput
  >;
  delete?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  connect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  set?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  disconnect?: Maybe<EventWhereUniqueInput[] | EventWhereUniqueInput>;
  update?: Maybe<
    | EventUpdateWithWhereUniqueWithoutSupportersInput[]
    | EventUpdateWithWhereUniqueWithoutSupportersInput
  >;
  upsert?: Maybe<
    | EventUpsertWithWhereUniqueWithoutSupportersInput[]
    | EventUpsertWithWhereUniqueWithoutSupportersInput
  >;
  deleteMany?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  updateMany?: Maybe<
    EventUpdateManyWithWhereNestedInput[] | EventUpdateManyWithWhereNestedInput
  >;
}

export interface EventUpdateWithWhereUniqueWithoutSupportersInput {
  where: EventWhereUniqueInput;
  data: EventUpdateWithoutSupportersDataInput;
}

export interface EventUpdateWithoutSupportersDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  comments?: Maybe<CommentUpdateManyWithoutEventInput>;
  todos?: Maybe<TodoUpdateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface UserUpdateManyWithoutLikedEventsInput {
  create?: Maybe<
    UserCreateWithoutLikedEventsInput[] | UserCreateWithoutLikedEventsInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutLikedEventsInput[]
    | UserUpdateWithWhereUniqueWithoutLikedEventsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutLikedEventsInput[]
    | UserUpsertWithWhereUniqueWithoutLikedEventsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikedEventsDataInput;
}

export interface UserUpdateWithoutLikedEventsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface CommentUpdateManyWithoutLikedByInput {
  create?: Maybe<
    CommentCreateWithoutLikedByInput[] | CommentCreateWithoutLikedByInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutLikedByInput[]
    | CommentUpdateWithWhereUniqueWithoutLikedByInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutLikedByInput[]
    | CommentUpsertWithWhereUniqueWithoutLikedByInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutLikedByDataInput;
}

export interface CommentUpdateWithoutLikedByDataInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  post?: Maybe<PostUpdateOneWithoutCommentsInput>;
  event?: Maybe<EventUpdateOneWithoutCommentsInput>;
}

export interface UserUpdateOneRequiredWithoutCommentsInput {
  create?: Maybe<UserCreateWithoutCommentsInput>;
  update?: Maybe<UserUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<UserUpsertWithoutCommentsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutCommentsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface ChatUpdateManyWithoutCreatorInput {
  create?: Maybe<
    ChatCreateWithoutCreatorInput[] | ChatCreateWithoutCreatorInput
  >;
  delete?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
  connect?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
  set?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
  disconnect?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
  update?: Maybe<
    | ChatUpdateWithWhereUniqueWithoutCreatorInput[]
    | ChatUpdateWithWhereUniqueWithoutCreatorInput
  >;
  upsert?: Maybe<
    | ChatUpsertWithWhereUniqueWithoutCreatorInput[]
    | ChatUpsertWithWhereUniqueWithoutCreatorInput
  >;
  deleteMany?: Maybe<ChatScalarWhereInput[] | ChatScalarWhereInput>;
  updateMany?: Maybe<
    ChatUpdateManyWithWhereNestedInput[] | ChatUpdateManyWithWhereNestedInput
  >;
}

export interface ChatUpdateWithWhereUniqueWithoutCreatorInput {
  where: ChatWhereUniqueInput;
  data: ChatUpdateWithoutCreatorDataInput;
}

export interface ChatUpdateWithoutCreatorDataInput {
  title?: Maybe<String>;
  members?: Maybe<UserUpdateManyWithoutChatsInput>;
  messages?: Maybe<MessageUpdateManyWithoutChatInput>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface UserUpdateManyWithoutChatsInput {
  create?: Maybe<UserCreateWithoutChatsInput[] | UserCreateWithoutChatsInput>;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutChatsInput[]
    | UserUpdateWithWhereUniqueWithoutChatsInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutChatsInput[]
    | UserUpsertWithWhereUniqueWithoutChatsInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutChatsInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutChatsDataInput;
}

export interface UserUpdateWithoutChatsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
}

export interface UserUpsertWithWhereUniqueWithoutChatsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutChatsDataInput;
  create: UserCreateWithoutChatsInput;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  role?: Maybe<UserRole>;
  role_not?: Maybe<UserRole>;
  role_in?: Maybe<UserRole[] | UserRole>;
  role_not_in?: Maybe<UserRole[] | UserRole>;
  avatar?: Maybe<String>;
  avatar_not?: Maybe<String>;
  avatar_in?: Maybe<String[] | String>;
  avatar_not_in?: Maybe<String[] | String>;
  avatar_lt?: Maybe<String>;
  avatar_lte?: Maybe<String>;
  avatar_gt?: Maybe<String>;
  avatar_gte?: Maybe<String>;
  avatar_contains?: Maybe<String>;
  avatar_not_contains?: Maybe<String>;
  avatar_starts_with?: Maybe<String>;
  avatar_not_starts_with?: Maybe<String>;
  avatar_ends_with?: Maybe<String>;
  avatar_not_ends_with?: Maybe<String>;
  balance?: Maybe<Float>;
  balance_not?: Maybe<Float>;
  balance_in?: Maybe<Float[] | Float>;
  balance_not_in?: Maybe<Float[] | Float>;
  balance_lt?: Maybe<Float>;
  balance_lte?: Maybe<Float>;
  balance_gt?: Maybe<Float>;
  balance_gte?: Maybe<Float>;
  isOnline?: Maybe<Boolean>;
  isOnline_not?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  lastOnline_not?: Maybe<DateTimeInput>;
  lastOnline_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastOnline_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastOnline_lt?: Maybe<DateTimeInput>;
  lastOnline_lte?: Maybe<DateTimeInput>;
  lastOnline_gt?: Maybe<DateTimeInput>;
  lastOnline_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserUpdateManyDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  balance?: Maybe<Float>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
}

export interface MessageUpdateManyWithoutChatInput {
  create?: Maybe<
    MessageCreateWithoutChatInput[] | MessageCreateWithoutChatInput
  >;
  delete?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  connect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  set?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  disconnect?: Maybe<MessageWhereUniqueInput[] | MessageWhereUniqueInput>;
  update?: Maybe<
    | MessageUpdateWithWhereUniqueWithoutChatInput[]
    | MessageUpdateWithWhereUniqueWithoutChatInput
  >;
  upsert?: Maybe<
    | MessageUpsertWithWhereUniqueWithoutChatInput[]
    | MessageUpsertWithWhereUniqueWithoutChatInput
  >;
  deleteMany?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  updateMany?: Maybe<
    | MessageUpdateManyWithWhereNestedInput[]
    | MessageUpdateManyWithWhereNestedInput
  >;
}

export interface MessageUpdateWithWhereUniqueWithoutChatInput {
  where: MessageWhereUniqueInput;
  data: MessageUpdateWithoutChatDataInput;
}

export interface MessageUpdateWithoutChatDataInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  from?: Maybe<UserUpdateOneRequiredInput>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface ChatUpdateManyWithoutMembersInput {
  create?: Maybe<
    ChatCreateWithoutMembersInput[] | ChatCreateWithoutMembersInput
  >;
  delete?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
  connect?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
  set?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
  disconnect?: Maybe<ChatWhereUniqueInput[] | ChatWhereUniqueInput>;
  update?: Maybe<
    | ChatUpdateWithWhereUniqueWithoutMembersInput[]
    | ChatUpdateWithWhereUniqueWithoutMembersInput
  >;
  upsert?: Maybe<
    | ChatUpsertWithWhereUniqueWithoutMembersInput[]
    | ChatUpsertWithWhereUniqueWithoutMembersInput
  >;
  deleteMany?: Maybe<ChatScalarWhereInput[] | ChatScalarWhereInput>;
  updateMany?: Maybe<
    ChatUpdateManyWithWhereNestedInput[] | ChatUpdateManyWithWhereNestedInput
  >;
}

export interface ChatUpdateWithWhereUniqueWithoutMembersInput {
  where: ChatWhereUniqueInput;
  data: ChatUpdateWithoutMembersDataInput;
}

export interface ChatUpdateWithoutMembersDataInput {
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredWithoutOwnChatsInput>;
  messages?: Maybe<MessageUpdateManyWithoutChatInput>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface ChatUpsertWithWhereUniqueWithoutMembersInput {
  where: ChatWhereUniqueInput;
  update: ChatUpdateWithoutMembersDataInput;
  create: ChatCreateWithoutMembersInput;
}

export interface ChatScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  AND?: Maybe<ChatScalarWhereInput[] | ChatScalarWhereInput>;
  OR?: Maybe<ChatScalarWhereInput[] | ChatScalarWhereInput>;
  NOT?: Maybe<ChatScalarWhereInput[] | ChatScalarWhereInput>;
}

export interface ChatUpdateManyWithWhereNestedInput {
  where: ChatScalarWhereInput;
  data: ChatUpdateManyDataInput;
}

export interface ChatUpdateManyDataInput {
  title?: Maybe<String>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface MessageUpsertWithWhereUniqueWithoutChatInput {
  where: MessageWhereUniqueInput;
  update: MessageUpdateWithoutChatDataInput;
  create: MessageCreateWithoutChatInput;
}

export interface MessageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  OR?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
  NOT?: Maybe<MessageScalarWhereInput[] | MessageScalarWhereInput>;
}

export interface MessageUpdateManyWithWhereNestedInput {
  where: MessageScalarWhereInput;
  data: MessageUpdateManyDataInput;
}

export interface MessageUpdateManyDataInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface ChatUpsertWithWhereUniqueWithoutCreatorInput {
  where: ChatWhereUniqueInput;
  update: ChatUpdateWithoutCreatorDataInput;
  create: ChatCreateWithoutCreatorInput;
}

export interface UserUpsertWithoutCommentsInput {
  update: UserUpdateWithoutCommentsDataInput;
  create: UserCreateWithoutCommentsInput;
}

export interface PostUpdateOneWithoutCommentsInput {
  create?: Maybe<PostCreateWithoutCommentsInput>;
  update?: Maybe<PostUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<PostUpsertWithoutCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PostWhereUniqueInput>;
}

export interface PostUpdateWithoutCommentsDataInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedPostsInput>;
  date?: Maybe<DateTimeInput>;
}

export interface PostUpsertWithoutCommentsInput {
  update: PostUpdateWithoutCommentsDataInput;
  create: PostCreateWithoutCommentsInput;
}

export interface EventUpdateOneWithoutCommentsInput {
  create?: Maybe<EventCreateWithoutCommentsInput>;
  update?: Maybe<EventUpdateWithoutCommentsDataInput>;
  upsert?: Maybe<EventUpsertWithoutCommentsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutCommentsDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  supporters?: Maybe<UserUpdateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  todos?: Maybe<TodoUpdateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface TodoUpdateManyWithoutEventInput {
  create?: Maybe<TodoCreateWithoutEventInput[] | TodoCreateWithoutEventInput>;
  delete?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
  connect?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
  set?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
  disconnect?: Maybe<TodoWhereUniqueInput[] | TodoWhereUniqueInput>;
  update?: Maybe<
    | TodoUpdateWithWhereUniqueWithoutEventInput[]
    | TodoUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | TodoUpsertWithWhereUniqueWithoutEventInput[]
    | TodoUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<TodoScalarWhereInput[] | TodoScalarWhereInput>;
  updateMany?: Maybe<
    TodoUpdateManyWithWhereNestedInput[] | TodoUpdateManyWithWhereNestedInput
  >;
}

export interface TodoUpdateWithWhereUniqueWithoutEventInput {
  where: TodoWhereUniqueInput;
  data: TodoUpdateWithoutEventDataInput;
}

export interface TodoUpdateWithoutEventDataInput {
  due?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  done?: Maybe<Boolean>;
  assigned?: Maybe<UserUpdateOneInput>;
  link?: Maybe<String>;
  doneBy?: Maybe<UserUpdateOneInput>;
  doneAt?: Maybe<DateTimeInput>;
}

export interface UserUpdateOneInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface TodoUpsertWithWhereUniqueWithoutEventInput {
  where: TodoWhereUniqueInput;
  update: TodoUpdateWithoutEventDataInput;
  create: TodoCreateWithoutEventInput;
}

export interface TodoScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  due?: Maybe<DateTimeInput>;
  due_not?: Maybe<DateTimeInput>;
  due_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  due_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  due_lt?: Maybe<DateTimeInput>;
  due_lte?: Maybe<DateTimeInput>;
  due_gt?: Maybe<DateTimeInput>;
  due_gte?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  done?: Maybe<Boolean>;
  done_not?: Maybe<Boolean>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  doneAt?: Maybe<DateTimeInput>;
  doneAt_not?: Maybe<DateTimeInput>;
  doneAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  doneAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  doneAt_lt?: Maybe<DateTimeInput>;
  doneAt_lte?: Maybe<DateTimeInput>;
  doneAt_gt?: Maybe<DateTimeInput>;
  doneAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<TodoScalarWhereInput[] | TodoScalarWhereInput>;
  OR?: Maybe<TodoScalarWhereInput[] | TodoScalarWhereInput>;
  NOT?: Maybe<TodoScalarWhereInput[] | TodoScalarWhereInput>;
}

export interface TodoUpdateManyWithWhereNestedInput {
  where: TodoScalarWhereInput;
  data: TodoUpdateManyDataInput;
}

export interface TodoUpdateManyDataInput {
  due?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  done?: Maybe<Boolean>;
  link?: Maybe<String>;
  doneAt?: Maybe<DateTimeInput>;
}

export interface EventUpsertWithoutCommentsInput {
  update: EventUpdateWithoutCommentsDataInput;
  create: EventCreateWithoutCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutLikedByInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutLikedByDataInput;
  create: CommentCreateWithoutLikedByInput;
}

export interface CommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  OR?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  NOT?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
}

export interface CommentUpdateManyWithWhereNestedInput {
  where: CommentScalarWhereInput;
  data: CommentUpdateManyDataInput;
}

export interface CommentUpdateManyDataInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpsertWithWhereUniqueWithoutLikedEventsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedEventsDataInput;
  create: UserCreateWithoutLikedEventsInput;
}

export interface CommentUpdateManyWithoutEventInput {
  create?: Maybe<
    CommentCreateWithoutEventInput[] | CommentCreateWithoutEventInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutEventInput[]
    | CommentUpdateWithWhereUniqueWithoutEventInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutEventInput[]
    | CommentUpsertWithWhereUniqueWithoutEventInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutEventDataInput;
}

export interface CommentUpdateWithoutEventDataInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostUpdateOneWithoutCommentsInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutEventInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutEventDataInput;
  create: CommentCreateWithoutEventInput;
}

export interface EventUpsertWithWhereUniqueWithoutSupportersInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutSupportersDataInput;
  create: EventCreateWithoutSupportersInput;
}

export interface EventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  flyer?: Maybe<String>;
  flyer_not?: Maybe<String>;
  flyer_in?: Maybe<String[] | String>;
  flyer_not_in?: Maybe<String[] | String>;
  flyer_lt?: Maybe<String>;
  flyer_lte?: Maybe<String>;
  flyer_gt?: Maybe<String>;
  flyer_gte?: Maybe<String>;
  flyer_contains?: Maybe<String>;
  flyer_not_contains?: Maybe<String>;
  flyer_starts_with?: Maybe<String>;
  flyer_not_starts_with?: Maybe<String>;
  flyer_ends_with?: Maybe<String>;
  flyer_not_ends_with?: Maybe<String>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  AND?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  OR?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
  NOT?: Maybe<EventScalarWhereInput[] | EventScalarWhereInput>;
}

export interface EventUpdateManyWithWhereNestedInput {
  where: EventScalarWhereInput;
  data: EventUpdateManyDataInput;
}

export interface EventUpdateManyDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  published?: Maybe<Boolean>;
}

export interface UserUpsertWithWhereUniqueWithoutLikedCommentsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedCommentsDataInput;
  create: UserCreateWithoutLikedCommentsInput;
}

export interface CommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutAuthorDataInput;
  create: CommentCreateWithoutAuthorInput;
}

export interface UserUpsertWithWhereUniqueWithoutSupportedEventsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutSupportedEventsDataInput;
  create: UserCreateWithoutSupportedEventsInput;
}

export interface EventUpsertWithWhereUniqueWithoutLikedByInput {
  where: EventWhereUniqueInput;
  update: EventUpdateWithoutLikedByDataInput;
  create: EventCreateWithoutLikedByInput;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface CommentUpdateManyWithoutPostInput {
  create?: Maybe<
    CommentCreateWithoutPostInput[] | CommentCreateWithoutPostInput
  >;
  delete?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  connect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  set?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  disconnect?: Maybe<CommentWhereUniqueInput[] | CommentWhereUniqueInput>;
  update?: Maybe<
    | CommentUpdateWithWhereUniqueWithoutPostInput[]
    | CommentUpdateWithWhereUniqueWithoutPostInput
  >;
  upsert?: Maybe<
    | CommentUpsertWithWhereUniqueWithoutPostInput[]
    | CommentUpsertWithWhereUniqueWithoutPostInput
  >;
  deleteMany?: Maybe<CommentScalarWhereInput[] | CommentScalarWhereInput>;
  updateMany?: Maybe<
    | CommentUpdateManyWithWhereNestedInput[]
    | CommentUpdateManyWithWhereNestedInput
  >;
}

export interface CommentUpdateWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  data: CommentUpdateWithoutPostDataInput;
}

export interface CommentUpdateWithoutPostDataInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedCommentsInput>;
  event?: Maybe<EventUpdateOneWithoutCommentsInput>;
}

export interface CommentUpsertWithWhereUniqueWithoutPostInput {
  where: CommentWhereUniqueInput;
  update: CommentUpdateWithoutPostDataInput;
  create: CommentCreateWithoutPostInput;
}

export interface PostUpsertWithWhereUniqueWithoutLikedByInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutLikedByDataInput;
  create: PostCreateWithoutLikedByInput;
}

export interface PostScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  text?: Maybe<String>;
  text_not?: Maybe<String>;
  text_in?: Maybe<String[] | String>;
  text_not_in?: Maybe<String[] | String>;
  text_lt?: Maybe<String>;
  text_lte?: Maybe<String>;
  text_gt?: Maybe<String>;
  text_gte?: Maybe<String>;
  text_contains?: Maybe<String>;
  text_not_contains?: Maybe<String>;
  text_starts_with?: Maybe<String>;
  text_not_starts_with?: Maybe<String>;
  text_ends_with?: Maybe<String>;
  text_not_ends_with?: Maybe<String>;
  image?: Maybe<String>;
  image_not?: Maybe<String>;
  image_in?: Maybe<String[] | String>;
  image_not_in?: Maybe<String[] | String>;
  image_lt?: Maybe<String>;
  image_lte?: Maybe<String>;
  image_gt?: Maybe<String>;
  image_gte?: Maybe<String>;
  image_contains?: Maybe<String>;
  image_not_contains?: Maybe<String>;
  image_starts_with?: Maybe<String>;
  image_not_starts_with?: Maybe<String>;
  image_ends_with?: Maybe<String>;
  image_not_ends_with?: Maybe<String>;
  link?: Maybe<String>;
  link_not?: Maybe<String>;
  link_in?: Maybe<String[] | String>;
  link_not_in?: Maybe<String[] | String>;
  link_lt?: Maybe<String>;
  link_lte?: Maybe<String>;
  link_gt?: Maybe<String>;
  link_gte?: Maybe<String>;
  link_contains?: Maybe<String>;
  link_not_contains?: Maybe<String>;
  link_starts_with?: Maybe<String>;
  link_not_starts_with?: Maybe<String>;
  link_ends_with?: Maybe<String>;
  link_not_ends_with?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface PostUpdateManyDataInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpsertWithoutPaymentsInput {
  update: UserUpdateWithoutPaymentsDataInput;
  create: UserCreateWithoutPaymentsInput;
}

export interface PaymentUpsertWithoutTransactionInput {
  update: PaymentUpdateWithoutTransactionDataInput;
  create: PaymentCreateWithoutTransactionInput;
}

export interface PurchaseUpdateOneWithoutTransactionInput {
  create?: Maybe<PurchaseCreateWithoutTransactionInput>;
  update?: Maybe<PurchaseUpdateWithoutTransactionDataInput>;
  upsert?: Maybe<PurchaseUpsertWithoutTransactionInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<PurchaseWhereUniqueInput>;
}

export interface PurchaseUpdateWithoutTransactionDataInput {
  items?: Maybe<ItemUpdateManyInput>;
  total?: Maybe<Float>;
  user?: Maybe<UserUpdateOneRequiredWithoutPurchasesInput>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpdateOneRequiredWithoutPurchasesInput {
  create?: Maybe<UserCreateWithoutPurchasesInput>;
  update?: Maybe<UserUpdateWithoutPurchasesDataInput>;
  upsert?: Maybe<UserUpsertWithoutPurchasesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutPurchasesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface UserUpsertWithoutPurchasesInput {
  update: UserUpdateWithoutPurchasesDataInput;
  create: UserCreateWithoutPurchasesInput;
}

export interface PurchaseUpsertWithoutTransactionInput {
  update: PurchaseUpdateWithoutTransactionDataInput;
  create: PurchaseCreateWithoutTransactionInput;
}

export interface TransactionUpsertWithWhereUniqueWithoutUserInput {
  where: TransactionWhereUniqueInput;
  update: TransactionUpdateWithoutUserDataInput;
  create: TransactionCreateWithoutUserInput;
}

export interface TransactionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  type_not?: Maybe<TransactionType>;
  type_in?: Maybe<TransactionType[] | TransactionType>;
  type_not_in?: Maybe<TransactionType[] | TransactionType>;
  balance?: Maybe<Float>;
  balance_not?: Maybe<Float>;
  balance_in?: Maybe<Float[] | Float>;
  balance_not_in?: Maybe<Float[] | Float>;
  balance_lt?: Maybe<Float>;
  balance_lte?: Maybe<Float>;
  balance_gt?: Maybe<Float>;
  balance_gte?: Maybe<Float>;
  AND?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  OR?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
  NOT?: Maybe<TransactionScalarWhereInput[] | TransactionScalarWhereInput>;
}

export interface TransactionUpdateManyWithWhereNestedInput {
  where: TransactionScalarWhereInput;
  data: TransactionUpdateManyDataInput;
}

export interface TransactionUpdateManyDataInput {
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
}

export interface UserUpsertWithWhereUniqueWithoutLikedPostsInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikedPostsDataInput;
  create: UserCreateWithoutLikedPostsInput;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface UserUpsertWithoutTransactionsInput {
  update: UserUpdateWithoutTransactionsDataInput;
  create: UserCreateWithoutTransactionsInput;
}

export interface TransactionUpsertWithoutPaymentInput {
  update: TransactionUpdateWithoutPaymentDataInput;
  create: TransactionCreateWithoutPaymentInput;
}

export interface PaymentUpsertWithWhereUniqueWithoutUserInput {
  where: PaymentWhereUniqueInput;
  update: PaymentUpdateWithoutUserDataInput;
  create: PaymentCreateWithoutUserInput;
}

export interface PaymentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  amount?: Maybe<Float>;
  amount_not?: Maybe<Float>;
  amount_in?: Maybe<Float[] | Float>;
  amount_not_in?: Maybe<Float[] | Float>;
  amount_lt?: Maybe<Float>;
  amount_lte?: Maybe<Float>;
  amount_gt?: Maybe<Float>;
  amount_gte?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
  verified_not?: Maybe<Boolean>;
  AND?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  OR?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
  NOT?: Maybe<PaymentScalarWhereInput[] | PaymentScalarWhereInput>;
}

export interface PaymentUpdateManyWithWhereNestedInput {
  where: PaymentScalarWhereInput;
  data: PaymentUpdateManyDataInput;
}

export interface PaymentUpdateManyDataInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
}

export interface UserUpsertWithoutItemsInput {
  update: UserUpdateWithoutItemsDataInput;
  create: UserCreateWithoutItemsInput;
}

export interface ItemUpsertWithWhereUniqueNestedInput {
  where: ItemWhereUniqueInput;
  update: ItemUpdateDataInput;
  create: ItemCreateInput;
}

export interface TransactionUpdateOneRequiredWithoutPurchaseInput {
  create?: Maybe<TransactionCreateWithoutPurchaseInput>;
  update?: Maybe<TransactionUpdateWithoutPurchaseDataInput>;
  upsert?: Maybe<TransactionUpsertWithoutPurchaseInput>;
  connect?: Maybe<TransactionWhereUniqueInput>;
}

export interface TransactionUpdateWithoutPurchaseDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
  payment?: Maybe<PaymentUpdateOneWithoutTransactionInput>;
}

export interface TransactionUpsertWithoutPurchaseInput {
  update: TransactionUpdateWithoutPurchaseDataInput;
  create: TransactionCreateWithoutPurchaseInput;
}

export interface PurchaseUpsertWithWhereUniqueWithoutUserInput {
  where: PurchaseWhereUniqueInput;
  update: PurchaseUpdateWithoutUserDataInput;
  create: PurchaseCreateWithoutUserInput;
}

export interface PurchaseScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  total?: Maybe<Float>;
  total_not?: Maybe<Float>;
  total_in?: Maybe<Float[] | Float>;
  total_not_in?: Maybe<Float[] | Float>;
  total_lt?: Maybe<Float>;
  total_lte?: Maybe<Float>;
  total_gt?: Maybe<Float>;
  total_gte?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  date_not?: Maybe<DateTimeInput>;
  date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  date_lt?: Maybe<DateTimeInput>;
  date_lte?: Maybe<DateTimeInput>;
  date_gt?: Maybe<DateTimeInput>;
  date_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
  OR?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
  NOT?: Maybe<PurchaseScalarWhereInput[] | PurchaseScalarWhereInput>;
}

export interface PurchaseUpdateManyWithWhereNestedInput {
  where: PurchaseScalarWhereInput;
  data: PurchaseUpdateManyDataInput;
}

export interface PurchaseUpdateManyDataInput {
  total?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface UserUpsertWithoutOwnChatsInput {
  update: UserUpdateWithoutOwnChatsDataInput;
  create: UserCreateWithoutOwnChatsInput;
}

export interface ChatUpdateManyMutationInput {
  title?: Maybe<String>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface ClientCreateInput {
  id?: Maybe<ID_Input>;
  identity: String;
  secret: String;
  name: String;
  trusted?: Maybe<Boolean>;
}

export interface ClientUpdateInput {
  identity?: Maybe<String>;
  secret?: Maybe<String>;
  name?: Maybe<String>;
  trusted?: Maybe<Boolean>;
}

export interface ClientUpdateManyMutationInput {
  identity?: Maybe<String>;
  secret?: Maybe<String>;
  name?: Maybe<String>;
  trusted?: Maybe<Boolean>;
}

export interface CommentCreateInput {
  id?: Maybe<ID_Input>;
  text: String;
  link?: Maybe<String>;
  date: DateTimeInput;
  author: UserCreateOneWithoutCommentsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostCreateOneWithoutCommentsInput>;
  event?: Maybe<EventCreateOneWithoutCommentsInput>;
}

export interface CommentUpdateInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  author?: Maybe<UserUpdateOneRequiredWithoutCommentsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedCommentsInput>;
  post?: Maybe<PostUpdateOneWithoutCommentsInput>;
  event?: Maybe<EventUpdateOneWithoutCommentsInput>;
}

export interface CommentUpdateManyMutationInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface EventCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  date: DateTimeInput;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  supporters?: Maybe<UserCreateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikedEventsInput>;
  owner: UserCreateOneInput;
  comments?: Maybe<CommentCreateManyWithoutEventInput>;
  todos?: Maybe<TodoCreateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface EventUpdateInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  supporters?: Maybe<UserUpdateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  comments?: Maybe<CommentUpdateManyWithoutEventInput>;
  todos?: Maybe<TodoUpdateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface EventUpdateManyMutationInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  published?: Maybe<Boolean>;
}

export interface FileCreateInput {
  id?: Maybe<ID_Input>;
  fileId: String;
  hash: String;
  uri: String;
  filename: String;
  path: String;
  mimetype: String;
  extension: String;
}

export interface FileUpdateInput {
  fileId?: Maybe<String>;
  hash?: Maybe<String>;
  uri?: Maybe<String>;
  filename?: Maybe<String>;
  path?: Maybe<String>;
  mimetype?: Maybe<String>;
  extension?: Maybe<String>;
}

export interface FileUpdateManyMutationInput {
  fileId?: Maybe<String>;
  hash?: Maybe<String>;
  uri?: Maybe<String>;
  filename?: Maybe<String>;
  path?: Maybe<String>;
  mimetype?: Maybe<String>;
  extension?: Maybe<String>;
}

export interface ItemUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutItemsInput>;
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface ItemUpdateManyMutationInput {
  price?: Maybe<Float>;
  amount?: Maybe<Int>;
}

export interface MessageCreateInput {
  id?: Maybe<ID_Input>;
  text: String;
  link?: Maybe<String>;
  from: UserCreateOneInput;
  chat: ChatCreateOneWithoutMessagesInput;
  date: DateTimeInput;
}

export interface ChatCreateOneWithoutMessagesInput {
  create?: Maybe<ChatCreateWithoutMessagesInput>;
  connect?: Maybe<ChatWhereUniqueInput>;
}

export interface ChatCreateWithoutMessagesInput {
  id?: Maybe<ID_Input>;
  title: String;
  creator: UserCreateOneWithoutOwnChatsInput;
  members?: Maybe<UserCreateManyWithoutChatsInput>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface MessageUpdateInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  from?: Maybe<UserUpdateOneRequiredInput>;
  chat?: Maybe<ChatUpdateOneRequiredWithoutMessagesInput>;
  date?: Maybe<DateTimeInput>;
}

export interface ChatUpdateOneRequiredWithoutMessagesInput {
  create?: Maybe<ChatCreateWithoutMessagesInput>;
  update?: Maybe<ChatUpdateWithoutMessagesDataInput>;
  upsert?: Maybe<ChatUpsertWithoutMessagesInput>;
  connect?: Maybe<ChatWhereUniqueInput>;
}

export interface ChatUpdateWithoutMessagesDataInput {
  title?: Maybe<String>;
  creator?: Maybe<UserUpdateOneRequiredWithoutOwnChatsInput>;
  members?: Maybe<UserUpdateManyWithoutChatsInput>;
  lastSeen?: Maybe<Json>;
  usersTyping?: Maybe<Json>;
}

export interface ChatUpsertWithoutMessagesInput {
  update: ChatUpdateWithoutMessagesDataInput;
  create: ChatCreateWithoutMessagesInput;
}

export interface MessageUpdateManyMutationInput {
  text?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface PaymentCreateInput {
  id?: Maybe<ID_Input>;
  amount: Float;
  user: UserCreateOneWithoutPaymentsInput;
  date: DateTimeInput;
  verified?: Maybe<Boolean>;
  transaction: TransactionCreateOneWithoutPaymentInput;
}

export interface PaymentUpdateInput {
  amount?: Maybe<Float>;
  user?: Maybe<UserUpdateOneRequiredWithoutPaymentsInput>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutPaymentInput>;
}

export interface PaymentUpdateManyMutationInput {
  amount?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
  verified?: Maybe<Boolean>;
}

export interface PostCreateInput {
  id?: Maybe<ID_Input>;
  text: String;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author: UserCreateOneWithoutPostsInput;
  likedBy?: Maybe<UserCreateManyWithoutLikedPostsInput>;
  comments?: Maybe<CommentCreateManyWithoutPostInput>;
  date: DateTimeInput;
}

export interface PostUpdateInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  author?: Maybe<UserUpdateOneRequiredWithoutPostsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedPostsInput>;
  comments?: Maybe<CommentUpdateManyWithoutPostInput>;
  date?: Maybe<DateTimeInput>;
}

export interface PostUpdateManyMutationInput {
  text?: Maybe<String>;
  image?: Maybe<String>;
  link?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  index?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  deleted?: Maybe<Boolean>;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  price?: Maybe<Float>;
  index?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  deleted?: Maybe<Boolean>;
}

export interface PurchaseCreateInput {
  id?: Maybe<ID_Input>;
  items?: Maybe<ItemCreateManyInput>;
  transaction: TransactionCreateOneWithoutPurchaseInput;
  total: Float;
  user: UserCreateOneWithoutPurchasesInput;
  date: DateTimeInput;
}

export interface PurchaseUpdateInput {
  items?: Maybe<ItemUpdateManyInput>;
  transaction?: Maybe<TransactionUpdateOneRequiredWithoutPurchaseInput>;
  total?: Maybe<Float>;
  user?: Maybe<UserUpdateOneRequiredWithoutPurchasesInput>;
  date?: Maybe<DateTimeInput>;
}

export interface PurchaseUpdateManyMutationInput {
  total?: Maybe<Float>;
  date?: Maybe<DateTimeInput>;
}

export interface TodoCreateInput {
  id?: Maybe<ID_Input>;
  due: DateTimeInput;
  text: String;
  done?: Maybe<Boolean>;
  assigned?: Maybe<UserCreateOneInput>;
  link?: Maybe<String>;
  doneBy?: Maybe<UserCreateOneInput>;
  doneAt?: Maybe<DateTimeInput>;
  event: EventCreateOneWithoutTodosInput;
}

export interface EventCreateOneWithoutTodosInput {
  create?: Maybe<EventCreateWithoutTodosInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventCreateWithoutTodosInput {
  id?: Maybe<ID_Input>;
  title: String;
  description: String;
  date: DateTimeInput;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  supporters?: Maybe<UserCreateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikedEventsInput>;
  owner: UserCreateOneInput;
  comments?: Maybe<CommentCreateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface TodoUpdateInput {
  due?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  done?: Maybe<Boolean>;
  assigned?: Maybe<UserUpdateOneInput>;
  link?: Maybe<String>;
  doneBy?: Maybe<UserUpdateOneInput>;
  doneAt?: Maybe<DateTimeInput>;
  event?: Maybe<EventUpdateOneRequiredWithoutTodosInput>;
}

export interface EventUpdateOneRequiredWithoutTodosInput {
  create?: Maybe<EventCreateWithoutTodosInput>;
  update?: Maybe<EventUpdateWithoutTodosDataInput>;
  upsert?: Maybe<EventUpsertWithoutTodosInput>;
  connect?: Maybe<EventWhereUniqueInput>;
}

export interface EventUpdateWithoutTodosDataInput {
  title?: Maybe<String>;
  description?: Maybe<String>;
  date?: Maybe<DateTimeInput>;
  image?: Maybe<String>;
  flyer?: Maybe<String>;
  supporters?: Maybe<UserUpdateManyWithoutSupportedEventsInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikedEventsInput>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  comments?: Maybe<CommentUpdateManyWithoutEventInput>;
  published?: Maybe<Boolean>;
}

export interface EventUpsertWithoutTodosInput {
  update: EventUpdateWithoutTodosDataInput;
  create: EventCreateWithoutTodosInput;
}

export interface TodoUpdateManyMutationInput {
  due?: Maybe<DateTimeInput>;
  text?: Maybe<String>;
  done?: Maybe<Boolean>;
  link?: Maybe<String>;
  doneAt?: Maybe<DateTimeInput>;
}

export interface TransactionCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutTransactionsInput;
  date: DateTimeInput;
  type: TransactionType;
  balance: Float;
  payment?: Maybe<PaymentCreateOneWithoutTransactionInput>;
  purchase?: Maybe<PurchaseCreateOneWithoutTransactionInput>;
}

export interface TransactionUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutTransactionsInput>;
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
  payment?: Maybe<PaymentUpdateOneWithoutTransactionInput>;
  purchase?: Maybe<PurchaseUpdateOneWithoutTransactionInput>;
}

export interface TransactionUpdateManyMutationInput {
  date?: Maybe<DateTimeInput>;
  type?: Maybe<TransactionType>;
  balance?: Maybe<Float>;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  purchases?: Maybe<PurchaseUpdateManyWithoutUserInput>;
  payments?: Maybe<PaymentUpdateManyWithoutUserInput>;
  transactions?: Maybe<TransactionUpdateManyWithoutUserInput>;
  items?: Maybe<ItemUpdateManyWithoutUserInput>;
  balance?: Maybe<Float>;
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  likedPosts?: Maybe<PostUpdateManyWithoutLikedByInput>;
  likedEvents?: Maybe<EventUpdateManyWithoutLikedByInput>;
  supportedEvents?: Maybe<EventUpdateManyWithoutSupportersInput>;
  comments?: Maybe<CommentUpdateManyWithoutAuthorInput>;
  likedComments?: Maybe<CommentUpdateManyWithoutLikedByInput>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
  ownChats?: Maybe<ChatUpdateManyWithoutCreatorInput>;
  chats?: Maybe<ChatUpdateManyWithoutMembersInput>;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<UserRole>;
  avatar?: Maybe<String>;
  balance?: Maybe<Float>;
  isOnline?: Maybe<Boolean>;
  lastOnline?: Maybe<DateTimeInput>;
}

export interface ChatSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChatWhereInput>;
  AND?: Maybe<ChatSubscriptionWhereInput[] | ChatSubscriptionWhereInput>;
  OR?: Maybe<ChatSubscriptionWhereInput[] | ChatSubscriptionWhereInput>;
  NOT?: Maybe<ChatSubscriptionWhereInput[] | ChatSubscriptionWhereInput>;
}

export interface ClientSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ClientWhereInput>;
  AND?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  OR?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
  NOT?: Maybe<ClientSubscriptionWhereInput[] | ClientSubscriptionWhereInput>;
}

export interface CommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CommentWhereInput>;
  AND?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  OR?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
  NOT?: Maybe<CommentSubscriptionWhereInput[] | CommentSubscriptionWhereInput>;
}

export interface EventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EventWhereInput>;
  AND?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  OR?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
  NOT?: Maybe<EventSubscriptionWhereInput[] | EventSubscriptionWhereInput>;
}

export interface FileSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<FileWhereInput>;
  AND?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  OR?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
  NOT?: Maybe<FileSubscriptionWhereInput[] | FileSubscriptionWhereInput>;
}

export interface ItemSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ItemWhereInput>;
  AND?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  OR?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
  NOT?: Maybe<ItemSubscriptionWhereInput[] | ItemSubscriptionWhereInput>;
}

export interface MessageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MessageWhereInput>;
  AND?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  OR?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
  NOT?: Maybe<MessageSubscriptionWhereInput[] | MessageSubscriptionWhereInput>;
}

export interface PaymentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PaymentWhereInput>;
  AND?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  OR?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
  NOT?: Maybe<PaymentSubscriptionWhereInput[] | PaymentSubscriptionWhereInput>;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  OR?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
  NOT?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface PurchaseSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PurchaseWhereInput>;
  AND?: Maybe<
    PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput
  >;
  OR?: Maybe<PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput>;
  NOT?: Maybe<
    PurchaseSubscriptionWhereInput[] | PurchaseSubscriptionWhereInput
  >;
}

export interface TodoSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TodoWhereInput>;
  AND?: Maybe<TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput>;
  OR?: Maybe<TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput>;
  NOT?: Maybe<TodoSubscriptionWhereInput[] | TodoSubscriptionWhereInput>;
}

export interface TransactionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TransactionWhereInput>;
  AND?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  OR?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TransactionSubscriptionWhereInput[] | TransactionSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Chat {
  id: ID_Output;
  title: String;
  lastSeen?: Json;
  usersTyping?: Json;
}

export interface ChatPromise extends Promise<Chat>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  creator: <T = UserPromise>() => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastSeen: () => Promise<Json>;
  usersTyping: () => Promise<Json>;
}

export interface ChatSubscription
  extends Promise<AsyncIterator<Chat>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  creator: <T = UserSubscription>() => T;
  members: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = Promise<AsyncIterator<MessageSubscription>>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastSeen: () => Promise<AsyncIterator<Json>>;
  usersTyping: () => Promise<AsyncIterator<Json>>;
}

export interface ChatNullablePromise
  extends Promise<Chat | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  creator: <T = UserPromise>() => T;
  members: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  messages: <T = FragmentableArray<Message>>(args?: {
    where?: MessageWhereInput;
    orderBy?: MessageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  lastSeen: () => Promise<Json>;
  usersTyping: () => Promise<Json>;
}

export interface User {
  id: ID_Output;
  name: String;
  email: String;
  role: UserRole;
  avatar?: String;
  balance: Float;
  isOnline: Boolean;
  lastOnline?: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<UserRole>;
  avatar: () => Promise<String>;
  purchases: <T = FragmentableArray<Purchase>>(args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  balance: () => Promise<Float>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedPosts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  supportedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedComments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isOnline: () => Promise<Boolean>;
  lastOnline: () => Promise<DateTimeOutput>;
  ownChats: <T = FragmentableArray<Chat>>(args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chats: <T = FragmentableArray<Chat>>(args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  avatar: () => Promise<AsyncIterator<String>>;
  purchases: <T = Promise<AsyncIterator<PurchaseSubscription>>>(args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = Promise<AsyncIterator<PaymentSubscription>>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transactions: <T = Promise<AsyncIterator<TransactionSubscription>>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  balance: () => Promise<AsyncIterator<Float>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedPosts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedEvents: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  supportedEvents: <T = Promise<AsyncIterator<EventSubscription>>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedComments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isOnline: () => Promise<AsyncIterator<Boolean>>;
  lastOnline: () => Promise<AsyncIterator<DateTimeOutput>>;
  ownChats: <T = Promise<AsyncIterator<ChatSubscription>>>(args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chats: <T = Promise<AsyncIterator<ChatSubscription>>>(args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<UserRole>;
  avatar: () => Promise<String>;
  purchases: <T = FragmentableArray<Purchase>>(args?: {
    where?: PurchaseWhereInput;
    orderBy?: PurchaseOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  payments: <T = FragmentableArray<Payment>>(args?: {
    where?: PaymentWhereInput;
    orderBy?: PaymentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transactions: <T = FragmentableArray<Transaction>>(args?: {
    where?: TransactionWhereInput;
    orderBy?: TransactionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  balance: () => Promise<Float>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedPosts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  supportedEvents: <T = FragmentableArray<Event>>(args?: {
    where?: EventWhereInput;
    orderBy?: EventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedComments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isOnline: () => Promise<Boolean>;
  lastOnline: () => Promise<DateTimeOutput>;
  ownChats: <T = FragmentableArray<Chat>>(args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chats: <T = FragmentableArray<Chat>>(args?: {
    where?: ChatWhereInput;
    orderBy?: ChatOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Purchase {
  id: ID_Output;
  total: Float;
  date: DateTimeOutput;
}

export interface PurchasePromise extends Promise<Purchase>, Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionPromise>() => T;
  total: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface PurchaseSubscription
  extends Promise<AsyncIterator<Purchase>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  items: <T = Promise<AsyncIterator<ItemSubscription>>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionSubscription>() => T;
  total: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PurchaseNullablePromise
  extends Promise<Purchase | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  items: <T = FragmentableArray<Item>>(args?: {
    where?: ItemWhereInput;
    orderBy?: ItemOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  transaction: <T = TransactionPromise>() => T;
  total: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface Item {
  id: ID_Output;
  price: Float;
  amount: Int;
}

export interface ItemPromise extends Promise<Item>, Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  user: <T = UserPromise>() => T;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface ItemSubscription
  extends Promise<AsyncIterator<Item>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  user: <T = UserSubscription>() => T;
  price: () => Promise<AsyncIterator<Float>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface ItemNullablePromise
  extends Promise<Item | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  user: <T = UserPromise>() => T;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface Product {
  id: ID_Output;
  name: String;
  price: Float;
  index: Int;
  thumbnail?: String;
  deleted: Boolean;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  deleted: () => Promise<Boolean>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  index: () => Promise<AsyncIterator<Int>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  deleted: () => Promise<Boolean>;
}

export interface Transaction {
  id: ID_Output;
  date: DateTimeOutput;
  type: TransactionType;
  balance: Float;
}

export interface TransactionPromise extends Promise<Transaction>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
  balance: () => Promise<Float>;
  payment: <T = PaymentPromise>() => T;
  purchase: <T = PurchasePromise>() => T;
}

export interface TransactionSubscription
  extends Promise<AsyncIterator<Transaction>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  balance: () => Promise<AsyncIterator<Float>>;
  payment: <T = PaymentSubscription>() => T;
  purchase: <T = PurchaseSubscription>() => T;
}

export interface TransactionNullablePromise
  extends Promise<Transaction | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
  balance: () => Promise<Float>;
  payment: <T = PaymentPromise>() => T;
  purchase: <T = PurchasePromise>() => T;
}

export interface Payment {
  id: ID_Output;
  amount: Float;
  date: DateTimeOutput;
  verified: Boolean;
}

export interface PaymentPromise extends Promise<Payment>, Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  verified: () => Promise<Boolean>;
  transaction: <T = TransactionPromise>() => T;
}

export interface PaymentSubscription
  extends Promise<AsyncIterator<Payment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  user: <T = UserSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
  transaction: <T = TransactionSubscription>() => T;
}

export interface PaymentNullablePromise
  extends Promise<Payment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  user: <T = UserPromise>() => T;
  date: () => Promise<DateTimeOutput>;
  verified: () => Promise<Boolean>;
  transaction: <T = TransactionPromise>() => T;
}

export interface Post {
  id: ID_Output;
  text: String;
  image?: String;
  link?: String;
  date: DateTimeOutput;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<DateTimeOutput>;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PostNullablePromise
  extends Promise<Post | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  date: () => Promise<DateTimeOutput>;
}

export interface Comment {
  id: ID_Output;
  text: String;
  link?: String;
  date: DateTimeOutput;
}

export interface CommentPromise extends Promise<Comment>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  link: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  post: <T = PostPromise>() => T;
  event: <T = EventPromise>() => T;
}

export interface CommentSubscription
  extends Promise<AsyncIterator<Comment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = UserSubscription>() => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  post: <T = PostSubscription>() => T;
  event: <T = EventSubscription>() => T;
}

export interface CommentNullablePromise
  extends Promise<Comment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  link: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  post: <T = PostPromise>() => T;
  event: <T = EventPromise>() => T;
}

export interface Event {
  id: ID_Output;
  title: String;
  description: String;
  date: DateTimeOutput;
  image?: String;
  flyer?: String;
  published: Boolean;
}

export interface EventPromise extends Promise<Event>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  image: () => Promise<String>;
  flyer: () => Promise<String>;
  supporters: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  todos: <T = FragmentableArray<Todo>>(args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  published: () => Promise<Boolean>;
}

export interface EventSubscription
  extends Promise<AsyncIterator<Event>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  image: () => Promise<AsyncIterator<String>>;
  flyer: () => Promise<AsyncIterator<String>>;
  supporters: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<CommentSubscription>>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  todos: <T = Promise<AsyncIterator<TodoSubscription>>>(args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  published: () => Promise<AsyncIterator<Boolean>>;
}

export interface EventNullablePromise
  extends Promise<Event | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  image: () => Promise<String>;
  flyer: () => Promise<String>;
  supporters: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = UserPromise>() => T;
  comments: <T = FragmentableArray<Comment>>(args?: {
    where?: CommentWhereInput;
    orderBy?: CommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  todos: <T = FragmentableArray<Todo>>(args?: {
    where?: TodoWhereInput;
    orderBy?: TodoOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  published: () => Promise<Boolean>;
}

export interface Todo {
  id: ID_Output;
  due: DateTimeOutput;
  text: String;
  done?: Boolean;
  link?: String;
  doneAt?: DateTimeOutput;
}

export interface TodoPromise extends Promise<Todo>, Fragmentable {
  id: () => Promise<ID_Output>;
  due: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  done: () => Promise<Boolean>;
  assigned: <T = UserPromise>() => T;
  link: () => Promise<String>;
  doneBy: <T = UserPromise>() => T;
  doneAt: () => Promise<DateTimeOutput>;
  event: <T = EventPromise>() => T;
}

export interface TodoSubscription
  extends Promise<AsyncIterator<Todo>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  due: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  done: () => Promise<AsyncIterator<Boolean>>;
  assigned: <T = UserSubscription>() => T;
  link: () => Promise<AsyncIterator<String>>;
  doneBy: <T = UserSubscription>() => T;
  doneAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  event: <T = EventSubscription>() => T;
}

export interface TodoNullablePromise
  extends Promise<Todo | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  due: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  done: () => Promise<Boolean>;
  assigned: <T = UserPromise>() => T;
  link: () => Promise<String>;
  doneBy: <T = UserPromise>() => T;
  doneAt: () => Promise<DateTimeOutput>;
  event: <T = EventPromise>() => T;
}

export interface Message {
  id: ID_Output;
  text: String;
  link?: String;
  date: DateTimeOutput;
}

export interface MessagePromise extends Promise<Message>, Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  link: () => Promise<String>;
  from: <T = UserPromise>() => T;
  chat: <T = ChatPromise>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface MessageSubscription
  extends Promise<AsyncIterator<Message>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  from: <T = UserSubscription>() => T;
  chat: <T = ChatSubscription>() => T;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface MessageNullablePromise
  extends Promise<Message | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  link: () => Promise<String>;
  from: <T = UserPromise>() => T;
  chat: <T = ChatPromise>() => T;
  date: () => Promise<DateTimeOutput>;
}

export interface ChatConnection {
  pageInfo: PageInfo;
  edges: ChatEdge[];
}

export interface ChatConnectionPromise
  extends Promise<ChatConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChatEdge>>() => T;
  aggregate: <T = AggregateChatPromise>() => T;
}

export interface ChatConnectionSubscription
  extends Promise<AsyncIterator<ChatConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChatEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChatSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface ChatEdge {
  node: Chat;
  cursor: String;
}

export interface ChatEdgePromise extends Promise<ChatEdge>, Fragmentable {
  node: <T = ChatPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChatEdgeSubscription
  extends Promise<AsyncIterator<ChatEdge>>,
    Fragmentable {
  node: <T = ChatSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChat {
  count: Int;
}

export interface AggregateChatPromise
  extends Promise<AggregateChat>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChatSubscription
  extends Promise<AsyncIterator<AggregateChat>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Client {
  id: ID_Output;
  identity: String;
  secret: String;
  name: String;
  trusted: Boolean;
}

export interface ClientPromise extends Promise<Client>, Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientSubscription
  extends Promise<AsyncIterator<Client>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identity: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trusted: () => Promise<AsyncIterator<Boolean>>;
}

export interface ClientNullablePromise
  extends Promise<Client | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientConnection {
  pageInfo: PageInfo;
  edges: ClientEdge[];
}

export interface ClientConnectionPromise
  extends Promise<ClientConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ClientEdge>>() => T;
  aggregate: <T = AggregateClientPromise>() => T;
}

export interface ClientConnectionSubscription
  extends Promise<AsyncIterator<ClientConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ClientEdgeSubscription>>>() => T;
  aggregate: <T = AggregateClientSubscription>() => T;
}

export interface ClientEdge {
  node: Client;
  cursor: String;
}

export interface ClientEdgePromise extends Promise<ClientEdge>, Fragmentable {
  node: <T = ClientPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ClientEdgeSubscription
  extends Promise<AsyncIterator<ClientEdge>>,
    Fragmentable {
  node: <T = ClientSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateClient {
  count: Int;
}

export interface AggregateClientPromise
  extends Promise<AggregateClient>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateClientSubscription
  extends Promise<AsyncIterator<AggregateClient>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CommentConnection {
  pageInfo: PageInfo;
  edges: CommentEdge[];
}

export interface CommentConnectionPromise
  extends Promise<CommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CommentEdge>>() => T;
  aggregate: <T = AggregateCommentPromise>() => T;
}

export interface CommentConnectionSubscription
  extends Promise<AsyncIterator<CommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCommentSubscription>() => T;
}

export interface CommentEdge {
  node: Comment;
  cursor: String;
}

export interface CommentEdgePromise extends Promise<CommentEdge>, Fragmentable {
  node: <T = CommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CommentEdgeSubscription
  extends Promise<AsyncIterator<CommentEdge>>,
    Fragmentable {
  node: <T = CommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateComment {
  count: Int;
}

export interface AggregateCommentPromise
  extends Promise<AggregateComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCommentSubscription
  extends Promise<AsyncIterator<AggregateComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface EventConnection {
  pageInfo: PageInfo;
  edges: EventEdge[];
}

export interface EventConnectionPromise
  extends Promise<EventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EventEdge>>() => T;
  aggregate: <T = AggregateEventPromise>() => T;
}

export interface EventConnectionSubscription
  extends Promise<AsyncIterator<EventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EventEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEventSubscription>() => T;
}

export interface EventEdge {
  node: Event;
  cursor: String;
}

export interface EventEdgePromise extends Promise<EventEdge>, Fragmentable {
  node: <T = EventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EventEdgeSubscription
  extends Promise<AsyncIterator<EventEdge>>,
    Fragmentable {
  node: <T = EventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateEvent {
  count: Int;
}

export interface AggregateEventPromise
  extends Promise<AggregateEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEventSubscription
  extends Promise<AsyncIterator<AggregateEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface File {
  id: ID_Output;
  fileId: String;
  hash: String;
  uri: String;
  filename: String;
  path: String;
  mimetype: String;
  extension: String;
  createdAt: DateTimeOutput;
}

export interface FilePromise extends Promise<File>, Fragmentable {
  id: () => Promise<ID_Output>;
  fileId: () => Promise<String>;
  hash: () => Promise<String>;
  uri: () => Promise<String>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FileSubscription
  extends Promise<AsyncIterator<File>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileId: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  extension: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface FileNullablePromise
  extends Promise<File | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileId: () => Promise<String>;
  hash: () => Promise<String>;
  uri: () => Promise<String>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FileConnection {
  pageInfo: PageInfo;
  edges: FileEdge[];
}

export interface FileConnectionPromise
  extends Promise<FileConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<FileEdge>>() => T;
  aggregate: <T = AggregateFilePromise>() => T;
}

export interface FileConnectionSubscription
  extends Promise<AsyncIterator<FileConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<FileEdgeSubscription>>>() => T;
  aggregate: <T = AggregateFileSubscription>() => T;
}

export interface FileEdge {
  node: File;
  cursor: String;
}

export interface FileEdgePromise extends Promise<FileEdge>, Fragmentable {
  node: <T = FilePromise>() => T;
  cursor: () => Promise<String>;
}

export interface FileEdgeSubscription
  extends Promise<AsyncIterator<FileEdge>>,
    Fragmentable {
  node: <T = FileSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateFile {
  count: Int;
}

export interface AggregateFilePromise
  extends Promise<AggregateFile>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateFileSubscription
  extends Promise<AsyncIterator<AggregateFile>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ItemConnection {
  pageInfo: PageInfo;
  edges: ItemEdge[];
}

export interface ItemConnectionPromise
  extends Promise<ItemConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ItemEdge>>() => T;
  aggregate: <T = AggregateItemPromise>() => T;
}

export interface ItemConnectionSubscription
  extends Promise<AsyncIterator<ItemConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ItemEdgeSubscription>>>() => T;
  aggregate: <T = AggregateItemSubscription>() => T;
}

export interface ItemEdge {
  node: Item;
  cursor: String;
}

export interface ItemEdgePromise extends Promise<ItemEdge>, Fragmentable {
  node: <T = ItemPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ItemEdgeSubscription
  extends Promise<AsyncIterator<ItemEdge>>,
    Fragmentable {
  node: <T = ItemSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateItem {
  count: Int;
}

export interface AggregateItemPromise
  extends Promise<AggregateItem>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateItemSubscription
  extends Promise<AsyncIterator<AggregateItem>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface MessageConnection {
  pageInfo: PageInfo;
  edges: MessageEdge[];
}

export interface MessageConnectionPromise
  extends Promise<MessageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MessageEdge>>() => T;
  aggregate: <T = AggregateMessagePromise>() => T;
}

export interface MessageConnectionSubscription
  extends Promise<AsyncIterator<MessageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MessageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMessageSubscription>() => T;
}

export interface MessageEdge {
  node: Message;
  cursor: String;
}

export interface MessageEdgePromise extends Promise<MessageEdge>, Fragmentable {
  node: <T = MessagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface MessageEdgeSubscription
  extends Promise<AsyncIterator<MessageEdge>>,
    Fragmentable {
  node: <T = MessageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMessage {
  count: Int;
}

export interface AggregateMessagePromise
  extends Promise<AggregateMessage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMessageSubscription
  extends Promise<AsyncIterator<AggregateMessage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PaymentConnection {
  pageInfo: PageInfo;
  edges: PaymentEdge[];
}

export interface PaymentConnectionPromise
  extends Promise<PaymentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PaymentEdge>>() => T;
  aggregate: <T = AggregatePaymentPromise>() => T;
}

export interface PaymentConnectionSubscription
  extends Promise<AsyncIterator<PaymentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PaymentEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePaymentSubscription>() => T;
}

export interface PaymentEdge {
  node: Payment;
  cursor: String;
}

export interface PaymentEdgePromise extends Promise<PaymentEdge>, Fragmentable {
  node: <T = PaymentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PaymentEdgeSubscription
  extends Promise<AsyncIterator<PaymentEdge>>,
    Fragmentable {
  node: <T = PaymentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePayment {
  count: Int;
}

export interface AggregatePaymentPromise
  extends Promise<AggregatePayment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePaymentSubscription
  extends Promise<AsyncIterator<AggregatePayment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PurchaseConnection {
  pageInfo: PageInfo;
  edges: PurchaseEdge[];
}

export interface PurchaseConnectionPromise
  extends Promise<PurchaseConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PurchaseEdge>>() => T;
  aggregate: <T = AggregatePurchasePromise>() => T;
}

export interface PurchaseConnectionSubscription
  extends Promise<AsyncIterator<PurchaseConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PurchaseEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePurchaseSubscription>() => T;
}

export interface PurchaseEdge {
  node: Purchase;
  cursor: String;
}

export interface PurchaseEdgePromise
  extends Promise<PurchaseEdge>,
    Fragmentable {
  node: <T = PurchasePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PurchaseEdgeSubscription
  extends Promise<AsyncIterator<PurchaseEdge>>,
    Fragmentable {
  node: <T = PurchaseSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePurchase {
  count: Int;
}

export interface AggregatePurchasePromise
  extends Promise<AggregatePurchase>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePurchaseSubscription
  extends Promise<AsyncIterator<AggregatePurchase>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TodoConnection {
  pageInfo: PageInfo;
  edges: TodoEdge[];
}

export interface TodoConnectionPromise
  extends Promise<TodoConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TodoEdge>>() => T;
  aggregate: <T = AggregateTodoPromise>() => T;
}

export interface TodoConnectionSubscription
  extends Promise<AsyncIterator<TodoConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TodoEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTodoSubscription>() => T;
}

export interface TodoEdge {
  node: Todo;
  cursor: String;
}

export interface TodoEdgePromise extends Promise<TodoEdge>, Fragmentable {
  node: <T = TodoPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TodoEdgeSubscription
  extends Promise<AsyncIterator<TodoEdge>>,
    Fragmentable {
  node: <T = TodoSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTodo {
  count: Int;
}

export interface AggregateTodoPromise
  extends Promise<AggregateTodo>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTodoSubscription
  extends Promise<AsyncIterator<AggregateTodo>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TransactionConnection {
  pageInfo: PageInfo;
  edges: TransactionEdge[];
}

export interface TransactionConnectionPromise
  extends Promise<TransactionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TransactionEdge>>() => T;
  aggregate: <T = AggregateTransactionPromise>() => T;
}

export interface TransactionConnectionSubscription
  extends Promise<AsyncIterator<TransactionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TransactionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTransactionSubscription>() => T;
}

export interface TransactionEdge {
  node: Transaction;
  cursor: String;
}

export interface TransactionEdgePromise
  extends Promise<TransactionEdge>,
    Fragmentable {
  node: <T = TransactionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TransactionEdgeSubscription
  extends Promise<AsyncIterator<TransactionEdge>>,
    Fragmentable {
  node: <T = TransactionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTransaction {
  count: Int;
}

export interface AggregateTransactionPromise
  extends Promise<AggregateTransaction>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTransactionSubscription
  extends Promise<AsyncIterator<AggregateTransaction>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ChatSubscriptionPayload {
  mutation: MutationType;
  node: Chat;
  updatedFields: String[];
  previousValues: ChatPreviousValues;
}

export interface ChatSubscriptionPayloadPromise
  extends Promise<ChatSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChatPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChatPreviousValuesPromise>() => T;
}

export interface ChatSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChatSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChatSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChatPreviousValuesSubscription>() => T;
}

export interface ChatPreviousValues {
  id: ID_Output;
  title: String;
  lastSeen?: Json;
  usersTyping?: Json;
}

export interface ChatPreviousValuesPromise
  extends Promise<ChatPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  lastSeen: () => Promise<Json>;
  usersTyping: () => Promise<Json>;
}

export interface ChatPreviousValuesSubscription
  extends Promise<AsyncIterator<ChatPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  lastSeen: () => Promise<AsyncIterator<Json>>;
  usersTyping: () => Promise<AsyncIterator<Json>>;
}

export interface ClientSubscriptionPayload {
  mutation: MutationType;
  node: Client;
  updatedFields: String[];
  previousValues: ClientPreviousValues;
}

export interface ClientSubscriptionPayloadPromise
  extends Promise<ClientSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ClientPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ClientPreviousValuesPromise>() => T;
}

export interface ClientSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ClientSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ClientSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ClientPreviousValuesSubscription>() => T;
}

export interface ClientPreviousValues {
  id: ID_Output;
  identity: String;
  secret: String;
  name: String;
  trusted: Boolean;
}

export interface ClientPreviousValuesPromise
  extends Promise<ClientPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  identity: () => Promise<String>;
  secret: () => Promise<String>;
  name: () => Promise<String>;
  trusted: () => Promise<Boolean>;
}

export interface ClientPreviousValuesSubscription
  extends Promise<AsyncIterator<ClientPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  identity: () => Promise<AsyncIterator<String>>;
  secret: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  trusted: () => Promise<AsyncIterator<Boolean>>;
}

export interface CommentSubscriptionPayload {
  mutation: MutationType;
  node: Comment;
  updatedFields: String[];
  previousValues: CommentPreviousValues;
}

export interface CommentSubscriptionPayloadPromise
  extends Promise<CommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CommentPreviousValuesPromise>() => T;
}

export interface CommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CommentPreviousValuesSubscription>() => T;
}

export interface CommentPreviousValues {
  id: ID_Output;
  text: String;
  link?: String;
  date: DateTimeOutput;
}

export interface CommentPreviousValuesPromise
  extends Promise<CommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  link: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
}

export interface CommentPreviousValuesSubscription
  extends Promise<AsyncIterator<CommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface EventSubscriptionPayload {
  mutation: MutationType;
  node: Event;
  updatedFields: String[];
  previousValues: EventPreviousValues;
}

export interface EventSubscriptionPayloadPromise
  extends Promise<EventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EventPreviousValuesPromise>() => T;
}

export interface EventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EventPreviousValuesSubscription>() => T;
}

export interface EventPreviousValues {
  id: ID_Output;
  title: String;
  description: String;
  date: DateTimeOutput;
  image?: String;
  flyer?: String;
  published: Boolean;
}

export interface EventPreviousValuesPromise
  extends Promise<EventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
  image: () => Promise<String>;
  flyer: () => Promise<String>;
  published: () => Promise<Boolean>;
}

export interface EventPreviousValuesSubscription
  extends Promise<AsyncIterator<EventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  image: () => Promise<AsyncIterator<String>>;
  flyer: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
}

export interface FileSubscriptionPayload {
  mutation: MutationType;
  node: File;
  updatedFields: String[];
  previousValues: FilePreviousValues;
}

export interface FileSubscriptionPayloadPromise
  extends Promise<FileSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = FilePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = FilePreviousValuesPromise>() => T;
}

export interface FileSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<FileSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = FileSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = FilePreviousValuesSubscription>() => T;
}

export interface FilePreviousValues {
  id: ID_Output;
  fileId: String;
  hash: String;
  uri: String;
  filename: String;
  path: String;
  mimetype: String;
  extension: String;
  createdAt: DateTimeOutput;
}

export interface FilePreviousValuesPromise
  extends Promise<FilePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  fileId: () => Promise<String>;
  hash: () => Promise<String>;
  uri: () => Promise<String>;
  filename: () => Promise<String>;
  path: () => Promise<String>;
  mimetype: () => Promise<String>;
  extension: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface FilePreviousValuesSubscription
  extends Promise<AsyncIterator<FilePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  fileId: () => Promise<AsyncIterator<String>>;
  hash: () => Promise<AsyncIterator<String>>;
  uri: () => Promise<AsyncIterator<String>>;
  filename: () => Promise<AsyncIterator<String>>;
  path: () => Promise<AsyncIterator<String>>;
  mimetype: () => Promise<AsyncIterator<String>>;
  extension: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ItemSubscriptionPayload {
  mutation: MutationType;
  node: Item;
  updatedFields: String[];
  previousValues: ItemPreviousValues;
}

export interface ItemSubscriptionPayloadPromise
  extends Promise<ItemSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ItemPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ItemPreviousValuesPromise>() => T;
}

export interface ItemSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ItemSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ItemSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ItemPreviousValuesSubscription>() => T;
}

export interface ItemPreviousValues {
  id: ID_Output;
  price: Float;
  amount: Int;
}

export interface ItemPreviousValuesPromise
  extends Promise<ItemPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  price: () => Promise<Float>;
  amount: () => Promise<Int>;
}

export interface ItemPreviousValuesSubscription
  extends Promise<AsyncIterator<ItemPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  price: () => Promise<AsyncIterator<Float>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface MessageSubscriptionPayload {
  mutation: MutationType;
  node: Message;
  updatedFields: String[];
  previousValues: MessagePreviousValues;
}

export interface MessageSubscriptionPayloadPromise
  extends Promise<MessageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MessagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MessagePreviousValuesPromise>() => T;
}

export interface MessageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MessageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MessageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MessagePreviousValuesSubscription>() => T;
}

export interface MessagePreviousValues {
  id: ID_Output;
  text: String;
  link?: String;
  date: DateTimeOutput;
}

export interface MessagePreviousValuesPromise
  extends Promise<MessagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  link: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
}

export interface MessagePreviousValuesSubscription
  extends Promise<AsyncIterator<MessagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PaymentSubscriptionPayload {
  mutation: MutationType;
  node: Payment;
  updatedFields: String[];
  previousValues: PaymentPreviousValues;
}

export interface PaymentSubscriptionPayloadPromise
  extends Promise<PaymentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PaymentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PaymentPreviousValuesPromise>() => T;
}

export interface PaymentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PaymentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PaymentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PaymentPreviousValuesSubscription>() => T;
}

export interface PaymentPreviousValues {
  id: ID_Output;
  amount: Float;
  date: DateTimeOutput;
  verified: Boolean;
}

export interface PaymentPreviousValuesPromise
  extends Promise<PaymentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  amount: () => Promise<Float>;
  date: () => Promise<DateTimeOutput>;
  verified: () => Promise<Boolean>;
}

export interface PaymentPreviousValuesSubscription
  extends Promise<AsyncIterator<PaymentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  amount: () => Promise<AsyncIterator<Float>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  verified: () => Promise<AsyncIterator<Boolean>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface PostPreviousValues {
  id: ID_Output;
  text: String;
  image?: String;
  link?: String;
  date: DateTimeOutput;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  text: () => Promise<String>;
  image: () => Promise<String>;
  link: () => Promise<String>;
  date: () => Promise<DateTimeOutput>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  text: () => Promise<AsyncIterator<String>>;
  image: () => Promise<AsyncIterator<String>>;
  link: () => Promise<AsyncIterator<String>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  price: Float;
  index: Int;
  thumbnail?: String;
  deleted: Boolean;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  price: () => Promise<Float>;
  index: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  deleted: () => Promise<Boolean>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  price: () => Promise<AsyncIterator<Float>>;
  index: () => Promise<AsyncIterator<Int>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  deleted: () => Promise<AsyncIterator<Boolean>>;
}

export interface PurchaseSubscriptionPayload {
  mutation: MutationType;
  node: Purchase;
  updatedFields: String[];
  previousValues: PurchasePreviousValues;
}

export interface PurchaseSubscriptionPayloadPromise
  extends Promise<PurchaseSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PurchasePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PurchasePreviousValuesPromise>() => T;
}

export interface PurchaseSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PurchaseSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PurchaseSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PurchasePreviousValuesSubscription>() => T;
}

export interface PurchasePreviousValues {
  id: ID_Output;
  total: Float;
  date: DateTimeOutput;
}

export interface PurchasePreviousValuesPromise
  extends Promise<PurchasePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  total: () => Promise<Float>;
  date: () => Promise<DateTimeOutput>;
}

export interface PurchasePreviousValuesSubscription
  extends Promise<AsyncIterator<PurchasePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  total: () => Promise<AsyncIterator<Float>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TodoSubscriptionPayload {
  mutation: MutationType;
  node: Todo;
  updatedFields: String[];
  previousValues: TodoPreviousValues;
}

export interface TodoSubscriptionPayloadPromise
  extends Promise<TodoSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TodoPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TodoPreviousValuesPromise>() => T;
}

export interface TodoSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TodoSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TodoSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TodoPreviousValuesSubscription>() => T;
}

export interface TodoPreviousValues {
  id: ID_Output;
  due: DateTimeOutput;
  text: String;
  done?: Boolean;
  link?: String;
  doneAt?: DateTimeOutput;
}

export interface TodoPreviousValuesPromise
  extends Promise<TodoPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  due: () => Promise<DateTimeOutput>;
  text: () => Promise<String>;
  done: () => Promise<Boolean>;
  link: () => Promise<String>;
  doneAt: () => Promise<DateTimeOutput>;
}

export interface TodoPreviousValuesSubscription
  extends Promise<AsyncIterator<TodoPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  due: () => Promise<AsyncIterator<DateTimeOutput>>;
  text: () => Promise<AsyncIterator<String>>;
  done: () => Promise<AsyncIterator<Boolean>>;
  link: () => Promise<AsyncIterator<String>>;
  doneAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface TransactionSubscriptionPayload {
  mutation: MutationType;
  node: Transaction;
  updatedFields: String[];
  previousValues: TransactionPreviousValues;
}

export interface TransactionSubscriptionPayloadPromise
  extends Promise<TransactionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TransactionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TransactionPreviousValuesPromise>() => T;
}

export interface TransactionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TransactionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TransactionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TransactionPreviousValuesSubscription>() => T;
}

export interface TransactionPreviousValues {
  id: ID_Output;
  date: DateTimeOutput;
  type: TransactionType;
  balance: Float;
}

export interface TransactionPreviousValuesPromise
  extends Promise<TransactionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  date: () => Promise<DateTimeOutput>;
  type: () => Promise<TransactionType>;
  balance: () => Promise<Float>;
}

export interface TransactionPreviousValuesSubscription
  extends Promise<AsyncIterator<TransactionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  date: () => Promise<AsyncIterator<DateTimeOutput>>;
  type: () => Promise<AsyncIterator<TransactionType>>;
  balance: () => Promise<AsyncIterator<Float>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  email: String;
  role: UserRole;
  avatar?: String;
  balance: Float;
  isOnline: Boolean;
  lastOnline?: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<UserRole>;
  avatar: () => Promise<String>;
  balance: () => Promise<Float>;
  isOnline: () => Promise<Boolean>;
  lastOnline: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<UserRole>>;
  avatar: () => Promise<AsyncIterator<String>>;
  balance: () => Promise<AsyncIterator<Float>>;
  isOnline: () => Promise<AsyncIterator<Boolean>>;
  lastOnline: () => Promise<AsyncIterator<DateTimeOutput>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Json = any;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Client",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "UserRole",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Item",
    embedded: false
  },
  {
    name: "Purchase",
    embedded: false
  },
  {
    name: "Payment",
    embedded: false
  },
  {
    name: "Transaction",
    embedded: false
  },
  {
    name: "TransactionType",
    embedded: false
  },
  {
    name: "Event",
    embedded: false
  },
  {
    name: "File",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "Comment",
    embedded: false
  },
  {
    name: "Todo",
    embedded: false
  },
  {
    name: "Message",
    embedded: false
  },
  {
    name: "Chat",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
